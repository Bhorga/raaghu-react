//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';
import Instance  from './interceptor';

export class ServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : Instance;

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param includeTypes (optional) 
     * @return Success
     */
    apiDefinition(includeTypes: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationApiDescriptionModel> {
        let url_ = this.baseUrl + "/api/abp/api-definition?";
        if (includeTypes === null)
            throw new Error("The parameter 'includeTypes' cannot be null.");
        else if (includeTypes !== undefined)
            url_ += "IncludeTypes=" + encodeURIComponent("" + includeTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApiDefinition(_response);
        });
    }

    protected processApiDefinition(response: AxiosResponse): Promise<ApplicationApiDescriptionModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationApiDescriptionModel.fromJS(resultData200);
            return Promise.resolve<ApplicationApiDescriptionModel>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationApiDescriptionModel>(null as any);
    }

    /**
     * @param includeLocalizationResources (optional) 
     * @return Success
     */
    applicationConfiguration(includeLocalizationResources: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/abp/application-configuration?";
        if (includeLocalizationResources === null)
            throw new Error("The parameter 'includeLocalizationResources' cannot be null.");
        else if (includeLocalizationResources !== undefined)
            url_ += "IncludeLocalizationResources=" + encodeURIComponent("" + includeLocalizationResources) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationConfiguration(_response);
        });
    }

    protected processApplicationConfiguration(response: AxiosResponse): Promise<ApplicationConfigurationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationConfigurationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationConfigurationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationConfigurationDto>(null as any);
    }

    /**
     * @param onlyDynamics (optional) 
     * @return Success
     */
    applicationLocalization(cultureName: string, onlyDynamics: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationLocalizationDto> {
        let url_ = this.baseUrl + "/api/abp/application-localization?";
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined and cannot be null.");
        else
            url_ += "CultureName=" + encodeURIComponent("" + cultureName) + "&";
        if (onlyDynamics === null)
            throw new Error("The parameter 'onlyDynamics' cannot be null.");
        else if (onlyDynamics !== undefined)
            url_ += "OnlyDynamics=" + encodeURIComponent("" + onlyDynamics) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationLocalization(_response);
        });
    }

    protected processApplicationLocalization(response: AxiosResponse): Promise<ApplicationLocalizationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationLocalizationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationLocalizationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationLocalizationDto>(null as any);
    }

    /**
     * @return Success
     */
    byName(name: string , cancelToken?: CancelToken | undefined): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/tenants/by-name/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByName(_response);
        });
    }

    protected processByName(response: AxiosResponse): Promise<FindTenantResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200);
            return Promise.resolve<FindTenantResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(null as any);
    }

    /**
     * @return Success
     */
    byId(id: string , cancelToken?: CancelToken | undefined): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/tenants/by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processById(_response);
        });
    }

    protected processById(response: AxiosResponse): Promise<FindTenantResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200);
            return Promise.resolve<FindTenantResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-password-reset-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendPasswordResetCode(_response);
        });
    }

    protected processSendPasswordResetCode(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyPasswordResetToken(body: VerifyPasswordResetTokenInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/verify-password-reset-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyPasswordResetToken(_response);
        });
    }

    protected processVerifyPasswordResetToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    confirmationState(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserConfirmationStateDto> {
        let url_ = this.baseUrl + "/api/account/confirmation-state?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmationState(_response);
        });
    }

    protected processConfirmationState(response: AxiosResponse): Promise<IdentityUserConfirmationStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserConfirmationStateDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserConfirmationStateDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserConfirmationStateDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPhoneNumberConfirmationToken(body: SendPhoneNumberConfirmationTokenDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-phone-number-confirmation-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendPhoneNumberConfirmationToken(_response);
        });
    }

    protected processSendPhoneNumberConfirmationToken(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailConfirmationToken(body: SendEmailConfirmationTokenDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-email-confirmation-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendEmailConfirmationToken(_response);
        });
    }

    protected processSendEmailConfirmationToken(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyEmailConfirmationToken(body: VerifyEmailConfirmationTokenInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/verify-email-confirmation-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyEmailConfirmationToken(_response);
        });
    }

    protected processVerifyEmailConfirmationToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmPhoneNumber(body: ConfirmPhoneNumberInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/confirm-phone-number";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmPhoneNumber(_response);
        });
    }

    protected processConfirmPhoneNumber(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmEmail(body: ConfirmEmailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/confirm-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param type (optional) 
     * @param imageContent (optional) 
     * @return Success
     */
    profilePicturePOST(type: ProfilePictureType | undefined, imageContent: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/profile-picture?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imageContent === null || imageContent === undefined)
            throw new Error("The parameter 'imageContent' cannot be null.");
        else
            content_.append("ImageContent", imageContent.data, imageContent.fileName ? imageContent.fileName : "ImageContent");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfilePicturePOST(_response);
        });
    }

    protected processProfilePicturePOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    profilePictureGET(id: string , cancelToken?: CancelToken | undefined): Promise<ProfilePictureSourceDto> {
        let url_ = this.baseUrl + "/api/account/profile-picture/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfilePictureGET(_response);
        });
    }

    protected processProfilePictureGET(response: AxiosResponse): Promise<ProfilePictureSourceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfilePictureSourceDto.fromJS(resultData200);
            return Promise.resolve<ProfilePictureSourceDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfilePictureSourceDto>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorProviders(userId: string, token: string , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/account/two-factor-providers?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "Token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorProviders(_response);
        });
    }

    protected processTwoFactorProviders(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorCode(body: SendTwoFactorCodeInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-two-factor-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendTwoFactorCode(_response);
        });
    }

    protected processSendTwoFactorCode(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param applicationName (optional) 
     * @param identity (optional) 
     * @param action (optional) 
     * @param userName (optional) 
     * @param clientId (optional) 
     * @param correlationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    securityLogs(startTime: Date | undefined, endTime: Date | undefined, applicationName: string | undefined, identity: string | undefined, action: string | undefined, userName: string | undefined, clientId: string | undefined, correlationId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/account/security-logs?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (applicationName === null)
            throw new Error("The parameter 'applicationName' cannot be null.");
        else if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (identity === null)
            throw new Error("The parameter 'identity' cannot be null.");
        else if (identity !== undefined)
            url_ += "Identity=" + encodeURIComponent("" + identity) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "Action=" + encodeURIComponent("" + action) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (correlationId === null)
            throw new Error("The parameter 'correlationId' cannot be null.");
        else if (correlationId !== undefined)
            url_ += "CorrelationId=" + encodeURIComponent("" + correlationId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSecurityLogs(_response);
        });
    }

    protected processSecurityLogs(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    profilePictureFile(id: string , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/account/profile-picture-file/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfilePictureFile(_response);
        });
    }

    protected processProfilePictureFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param captchaResponse (optional) 
     * @return Success
     */
    recaptchaValidate(captchaResponse: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/recaptcha-validate?";
        if (captchaResponse === null)
            throw new Error("The parameter 'captchaResponse' cannot be null.");
        else if (captchaResponse !== undefined)
            url_ += "captchaResponse=" + encodeURIComponent("" + captchaResponse) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecaptchaValidate(_response);
        });
    }

    protected processRecaptchaValidate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalProviderGET(  cancelToken?: CancelToken | undefined): Promise<ExternalProviderDto> {
        let url_ = this.baseUrl + "/api/account/external-provider";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalProviderGET(_response);
        });
    }

    protected processExternalProviderGET(response: AxiosResponse): Promise<ExternalProviderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalProviderDto.fromJS(resultData200);
            return Promise.resolve<ExternalProviderDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalProviderDto>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param name (optional) 
     * @return Success
     */
    byName2(tenantId: string | undefined, name: string | undefined , cancelToken?: CancelToken | undefined): Promise<ExternalProviderItemWithSecretDto> {
        let url_ = this.baseUrl + "/api/account/external-provider/by-name?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByName2(_response);
        });
    }

    protected processByName2(response: AxiosResponse): Promise<ExternalProviderItemWithSecretDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalProviderItemWithSecretDto.fromJS(resultData200);
            return Promise.resolve<ExternalProviderItemWithSecretDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalProviderItemWithSecretDto>(null as any);
    }

    /**
     * @return Success
     */
    settingsGET(  cancelToken?: CancelToken | undefined): Promise<AccountSettingsDto> {
        let url_ = this.baseUrl + "/api/account-admin/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsGET(_response);
        });
    }

    protected processSettingsGET(response: AxiosResponse): Promise<AccountSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountSettingsDto.fromJS(resultData200);
            return Promise.resolve<AccountSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    settingsPUT(body: AccountSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account-admin/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsPUT(_response);
        });
    }

    protected processSettingsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorGET(  cancelToken?: CancelToken | undefined): Promise<AccountTwoFactorSettingsDto> {
        let url_ = this.baseUrl + "/api/account-admin/settings/two-factor";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorGET(_response);
        });
    }

    protected processTwoFactorGET(response: AxiosResponse): Promise<AccountTwoFactorSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountTwoFactorSettingsDto.fromJS(resultData200);
            return Promise.resolve<AccountTwoFactorSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountTwoFactorSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    twoFactorPUT(body: AccountTwoFactorSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account-admin/settings/two-factor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorPUT(_response);
        });
    }

    protected processTwoFactorPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    recaptchaGET(  cancelToken?: CancelToken | undefined): Promise<AccountRecaptchaSettingsDto> {
        let url_ = this.baseUrl + "/api/account-admin/settings/recaptcha";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecaptchaGET(_response);
        });
    }

    protected processRecaptchaGET(response: AxiosResponse): Promise<AccountRecaptchaSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountRecaptchaSettingsDto.fromJS(resultData200);
            return Promise.resolve<AccountRecaptchaSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountRecaptchaSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recaptchaPUT(body: AccountRecaptchaSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account-admin/settings/recaptcha";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecaptchaPUT(_response);
        });
    }

    protected processRecaptchaPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalProviderGET2(  cancelToken?: CancelToken | undefined): Promise<AccountExternalProviderSettingsDto> {
        let url_ = this.baseUrl + "/api/account-admin/settings/external-provider";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalProviderGET2(_response);
        });
    }

    protected processExternalProviderGET2(response: AxiosResponse): Promise<AccountExternalProviderSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountExternalProviderSettingsDto.fromJS(resultData200);
            return Promise.resolve<AccountExternalProviderSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountExternalProviderSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalProviderPUT(body: UpdateExternalProviderDto[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account-admin/settings/external-provider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalProviderPUT(_response);
        });
    }

    protected processExternalProviderPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    applicationsGET(id: string , cancelToken?: CancelToken | undefined): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/openiddict/applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsGET(_response);
        });
    }

    protected processApplicationsGET(response: AxiosResponse): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applicationsPUT(id: string, body: UpdateApplicationInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/openiddict/applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsPUT(_response);
        });
    }

    protected processApplicationsPUT(response: AxiosResponse): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    applicationsGET2(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/openiddict/applications?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsGET2(_response);
        });
    }

    protected processApplicationsGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applicationsPOST(body: CreateApplicationInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/openiddict/applications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsPOST(_response);
        });
    }

    protected processApplicationsPOST(response: AxiosResponse): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    applicationsDELETE(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/openiddict/applications?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsDELETE(_response);
        });
    }

    protected processApplicationsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param url (optional) 
     * @param userName (optional) 
     * @param applicationName (optional) 
     * @param clientIpAddress (optional) 
     * @param correlationId (optional) 
     * @param httpMethod (optional) 
     * @param httpStatusCode (optional) 
     * @param maxExecutionDuration (optional) 
     * @param minExecutionDuration (optional) 
     * @param hasException (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    auditLogs(startTime: Date | undefined, endTime: Date | undefined, url: string | undefined, userName: string | undefined, applicationName: string | undefined, clientIpAddress: string | undefined, correlationId: string | undefined, httpMethod: string | undefined, httpStatusCode: HttpStatusCode | undefined, maxExecutionDuration: number | undefined, minExecutionDuration: number | undefined, hasException: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (url === null)
            throw new Error("The parameter 'url' cannot be null.");
        else if (url !== undefined)
            url_ += "Url=" + encodeURIComponent("" + url) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (applicationName === null)
            throw new Error("The parameter 'applicationName' cannot be null.");
        else if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (clientIpAddress === null)
            throw new Error("The parameter 'clientIpAddress' cannot be null.");
        else if (clientIpAddress !== undefined)
            url_ += "ClientIpAddress=" + encodeURIComponent("" + clientIpAddress) + "&";
        if (correlationId === null)
            throw new Error("The parameter 'correlationId' cannot be null.");
        else if (correlationId !== undefined)
            url_ += "CorrelationId=" + encodeURIComponent("" + correlationId) + "&";
        if (httpMethod === null)
            throw new Error("The parameter 'httpMethod' cannot be null.");
        else if (httpMethod !== undefined)
            url_ += "HttpMethod=" + encodeURIComponent("" + httpMethod) + "&";
        if (httpStatusCode === null)
            throw new Error("The parameter 'httpStatusCode' cannot be null.");
        else if (httpStatusCode !== undefined)
            url_ += "HttpStatusCode=" + encodeURIComponent("" + httpStatusCode) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuditLogs(_response);
        });
    }

    protected processAuditLogs(response: AxiosResponse): Promise<PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    auditLogs2(id: string , cancelToken?: CancelToken | undefined): Promise<AuditLogDto> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuditLogs2(_response);
        });
    }

    protected processAuditLogs2(response: AxiosResponse): Promise<AuditLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuditLogDto.fromJS(resultData200);
            return Promise.resolve<AuditLogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuditLogDto>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    errorRate(startDate: Date | undefined, endDate: Date | undefined , cancelToken?: CancelToken | undefined): Promise<GetErrorRateOutput> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/statistics/error-rate?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processErrorRate(_response);
        });
    }

    protected processErrorRate(response: AxiosResponse): Promise<GetErrorRateOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetErrorRateOutput.fromJS(resultData200);
            return Promise.resolve<GetErrorRateOutput>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetErrorRateOutput>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    averageExecutionDurationPerDay(startDate: Date | undefined, endDate: Date | undefined , cancelToken?: CancelToken | undefined): Promise<GetAverageExecutionDurationPerDayOutput> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/statistics/average-execution-duration-per-day?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAverageExecutionDurationPerDay(_response);
        });
    }

    protected processAverageExecutionDurationPerDay(response: AxiosResponse): Promise<GetAverageExecutionDurationPerDayOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAverageExecutionDurationPerDayOutput.fromJS(resultData200);
            return Promise.resolve<GetAverageExecutionDurationPerDayOutput>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAverageExecutionDurationPerDayOutput>(null as any);
    }

    /**
     * @param auditLogId (optional) 
     * @param entityChangeType (optional) 
     * @param entityId (optional) 
     * @param entityTypeFullName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    entityChanges(auditLogId: string | undefined, entityChangeType: EntityChangeType | undefined, entityId: string | undefined, entityTypeFullName: string | undefined, startDate: Date | undefined, endDate: Date | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/entity-changes?";
        if (auditLogId === null)
            throw new Error("The parameter 'auditLogId' cannot be null.");
        else if (auditLogId !== undefined)
            url_ += "AuditLogId=" + encodeURIComponent("" + auditLogId) + "&";
        if (entityChangeType === null)
            throw new Error("The parameter 'entityChangeType' cannot be null.");
        else if (entityChangeType !== undefined)
            url_ += "EntityChangeType=" + encodeURIComponent("" + entityChangeType) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityChanges(_response);
        });
    }

    protected processEntityChanges(response: AxiosResponse): Promise<PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param entityTypeFullName (optional) 
     * @return Success
     */
    entityChangesWithUsername(entityId: string | undefined, entityTypeFullName: string | undefined , cancelToken?: CancelToken | undefined): Promise<EntityChangeWithUsernameDto[]> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/entity-changes-with-username?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityChangesWithUsername(_response);
        });
    }

    protected processEntityChangesWithUsername(response: AxiosResponse): Promise<EntityChangeWithUsernameDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityChangeWithUsernameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<EntityChangeWithUsernameDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityChangeWithUsernameDto[]>(null as any);
    }

    /**
     * @return Success
     */
    entityChangeWithUsername(entityChangeId: string , cancelToken?: CancelToken | undefined): Promise<EntityChangeWithUsernameDto> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/entity-change-with-username/{entityChangeId}";
        if (entityChangeId === undefined || entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' must be defined.");
        url_ = url_.replace("{entityChangeId}", encodeURIComponent("" + entityChangeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityChangeWithUsername(_response);
        });
    }

    protected processEntityChangeWithUsername(response: AxiosResponse): Promise<EntityChangeWithUsernameDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityChangeWithUsernameDto.fromJS(resultData200);
            return Promise.resolve<EntityChangeWithUsernameDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityChangeWithUsernameDto>(null as any);
    }

    /**
     * @return Success
     */
    entityChanges2(entityChangeId: string , cancelToken?: CancelToken | undefined): Promise<EntityChangeDto> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/entity-changes/{entityChangeId}";
        if (entityChangeId === undefined || entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' must be defined.");
        url_ = url_.replace("{entityChangeId}", encodeURIComponent("" + entityChangeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityChanges2(_response);
        });
    }

    protected processEntityChanges2(response: AxiosResponse): Promise<EntityChangeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityChangeDto.fromJS(resultData200);
            return Promise.resolve<EntityChangeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityChangeDto>(null as any);
    }

    /**
     * @return Success
     */
    blogsGET(id: string , cancelToken?: CancelToken | undefined): Promise<BlogDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogsGET(_response);
        });
    }

    protected processBlogsGET(response: AxiosResponse): Promise<BlogDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogDto2.fromJS(resultData200);
            return Promise.resolve<BlogDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogDto2>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blogsPUT(id: string, body: UpdateBlogDto2 | undefined , cancelToken?: CancelToken | undefined): Promise<BlogDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogsPUT(_response);
        });
    }

    protected processBlogsPUT(response: AxiosResponse): Promise<BlogDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogDto2.fromJS(resultData200);
            return Promise.resolve<BlogDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogDto2>(null as any);
    }

    /**
     * @return Success
     */
    blogsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogsDELETE(_response);
        });
    }

    protected processBlogsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    blogsGET2(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogsGET2(_response);
        });
    }

    protected processBlogsGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blogsPOST(body: CreateBlogDto2 | undefined , cancelToken?: CancelToken | undefined): Promise<BlogDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogsPOST(_response);
        });
    }

    protected processBlogsPOST(response: AxiosResponse): Promise<BlogDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogDto2.fromJS(resultData200);
            return Promise.resolve<BlogDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogDto2>(null as any);
    }

    /**
     * @return Success
     */
    featuresGET(blogId: string, featureName: string , cancelToken?: CancelToken | undefined): Promise<BlogFeatureDto> {
        let url_ = this.baseUrl + "/api/cms-kit/blogs/{blogId}/features/{featureName}";
        if (blogId === undefined || blogId === null)
            throw new Error("The parameter 'blogId' must be defined.");
        url_ = url_.replace("{blogId}", encodeURIComponent("" + blogId));
        if (featureName === undefined || featureName === null)
            throw new Error("The parameter 'featureName' must be defined.");
        url_ = url_.replace("{featureName}", encodeURIComponent("" + featureName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesGET(_response);
        });
    }

    protected processFeaturesGET(response: AxiosResponse): Promise<BlogFeatureDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogFeatureDto.fromJS(resultData200);
            return Promise.resolve<BlogFeatureDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogFeatureDto>(null as any);
    }

    /**
     * @return Success
     */
    featuresAll(blogId: string , cancelToken?: CancelToken | undefined): Promise<BlogFeatureDto[]> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/{blogId}/features";
        if (blogId === undefined || blogId === null)
            throw new Error("The parameter 'blogId' must be defined.");
        url_ = url_.replace("{blogId}", encodeURIComponent("" + blogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesAll(_response);
        });
    }

    protected processFeaturesAll(response: AxiosResponse): Promise<BlogFeatureDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlogFeatureDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BlogFeatureDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogFeatureDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    featuresPUT(blogId: string, body: BlogFeatureInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/{blogId}/features";
        if (blogId === undefined || blogId === null)
            throw new Error("The parameter 'blogId' must be defined.");
        url_ = url_.replace("{blogId}", encodeURIComponent("" + blogId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesPUT(_response);
        });
    }

    protected processFeaturesPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    files(name: string , cancelToken?: CancelToken | undefined): Promise<RawFileDto> {
        let url_ = this.baseUrl + "/api/blogging/files/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFiles(_response);
        });
    }

    protected processFiles(response: AxiosResponse): Promise<RawFileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RawFileDto.fromJS(resultData200);
            return Promise.resolve<RawFileDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RawFileDto>(null as any);
    }

    /**
     * @return Success
     */
    www(name: string , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/blogging/files/www/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWww(_response);
        });
    }

    protected processWww(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    upload(name: string, file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<FileUploadOutputDto> {
        let url_ = this.baseUrl + "/api/blogging/files/images/upload?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: AxiosResponse): Promise<FileUploadOutputDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileUploadOutputDto.fromJS(resultData200);
            return Promise.resolve<FileUploadOutputDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileUploadOutputDto>(null as any);
    }

    /**
     * @return Success
     */
    adminGET(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/blogging/blogs/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdminGET(_response);
        });
    }

    protected processAdminGET(response: AxiosResponse): Promise<ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adminPOST(body: CreateBlogDto | undefined , cancelToken?: CancelToken | undefined): Promise<BlogDto> {
        let url_ = this.baseUrl + "/api/blogging/blogs/admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdminPOST(_response);
        });
    }

    protected processAdminPOST(response: AxiosResponse): Promise<BlogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogDto.fromJS(resultData200);
            return Promise.resolve<BlogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogDto>(null as any);
    }

    /**
     * @return Success
     */
    adminGET2(id: string , cancelToken?: CancelToken | undefined): Promise<BlogDto> {
        let url_ = this.baseUrl + "/api/blogging/blogs/admin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdminGET2(_response);
        });
    }

    protected processAdminGET2(response: AxiosResponse): Promise<BlogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogDto.fromJS(resultData200);
            return Promise.resolve<BlogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adminPUT(id: string, body: UpdateBlogDto | undefined , cancelToken?: CancelToken | undefined): Promise<BlogDto> {
        let url_ = this.baseUrl + "/api/blogging/blogs/admin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdminPUT(_response);
        });
    }

    protected processAdminPUT(response: AxiosResponse): Promise<BlogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogDto.fromJS(resultData200);
            return Promise.resolve<BlogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogDto>(null as any);
    }

    /**
     * @return Success
     */
    adminDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/blogging/blogs/admin/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAdminDELETE(_response);
        });
    }

    protected processAdminDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    clearCache(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/blogging/blogs/admin/clear-cache/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearCache(_response);
        });
    }

    protected processClearCache(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blogPostsPOST(body: CreateBlogPostDto | undefined , cancelToken?: CancelToken | undefined): Promise<BlogPostDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogPostsPOST(_response);
        });
    }

    protected processBlogPostsPOST(response: AxiosResponse): Promise<BlogPostDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogPostDto.fromJS(resultData200);
            return Promise.resolve<BlogPostDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogPostDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param blogId (optional) 
     * @param authorId (optional) 
     * @param tagId (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    blogPostsGET(filter: string | undefined, blogId: string | undefined, authorId: string | undefined, tagId: string | undefined, status: BlogPostStatus | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (blogId === null)
            throw new Error("The parameter 'blogId' cannot be null.");
        else if (blogId !== undefined)
            url_ += "BlogId=" + encodeURIComponent("" + blogId) + "&";
        if (authorId === null)
            throw new Error("The parameter 'authorId' cannot be null.");
        else if (authorId !== undefined)
            url_ += "AuthorId=" + encodeURIComponent("" + authorId) + "&";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogPostsGET(_response);
        });
    }

    protected processBlogPostsGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    blogPostsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogPostsDELETE(_response);
        });
    }

    protected processBlogPostsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    blogPostsGET2(id: string , cancelToken?: CancelToken | undefined): Promise<BlogPostDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogPostsGET2(_response);
        });
    }

    protected processBlogPostsGET2(response: AxiosResponse): Promise<BlogPostDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogPostDto.fromJS(resultData200);
            return Promise.resolve<BlogPostDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogPostDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blogPostsPUT(id: string, body: UpdateBlogPostDto | undefined , cancelToken?: CancelToken | undefined): Promise<BlogPostDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogPostsPUT(_response);
        });
    }

    protected processBlogPostsPUT(response: AxiosResponse): Promise<BlogPostDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogPostDto.fromJS(resultData200);
            return Promise.resolve<BlogPostDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogPostDto>(null as any);
    }

    /**
     * @return Success
     */
    publish(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    draft(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/{id}/draft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDraft(_response);
        });
    }

    protected processDraft(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAndPublish(body: CreateBlogPostDto | undefined , cancelToken?: CancelToken | undefined): Promise<BlogPostDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/create-and-publish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAndPublish(_response);
        });
    }

    protected processCreateAndPublish(response: AxiosResponse): Promise<BlogPostDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogPostDto.fromJS(resultData200);
            return Promise.resolve<BlogPostDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogPostDto>(null as any);
    }

    /**
     * @return Success
     */
    sendToReview(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/{id}/send-to-review";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendToReview(_response);
        });
    }

    protected processSendToReview(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAndSendToReview(body: CreateBlogPostDto | undefined , cancelToken?: CancelToken | undefined): Promise<BlogPostDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/create-and-send-to-review";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAndSendToReview(_response);
        });
    }

    protected processCreateAndSendToReview(response: AxiosResponse): Promise<BlogPostDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogPostDto.fromJS(resultData200);
            return Promise.resolve<BlogPostDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogPostDto>(null as any);
    }

    /**
     * @return Success
     */
    hasBlogpostWaitingForReview(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/blogs/blog-posts/has-blogpost-waiting-for-review";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHasBlogpostWaitingForReview(_response);
        });
    }

    protected processHasBlogpostWaitingForReview(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    blogPostsGET3(blogSlug: string, blogPostSlug: string , cancelToken?: CancelToken | undefined): Promise<BlogPostCommonDto> {
        let url_ = this.baseUrl + "/api/cms-kit-public/blog-posts/{blogSlug}/{blogPostSlug}";
        if (blogSlug === undefined || blogSlug === null)
            throw new Error("The parameter 'blogSlug' must be defined.");
        url_ = url_.replace("{blogSlug}", encodeURIComponent("" + blogSlug));
        if (blogPostSlug === undefined || blogPostSlug === null)
            throw new Error("The parameter 'blogPostSlug' must be defined.");
        url_ = url_.replace("{blogPostSlug}", encodeURIComponent("" + blogPostSlug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogPostsGET3(_response);
        });
    }

    protected processBlogPostsGET3(response: AxiosResponse): Promise<BlogPostCommonDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogPostCommonDto.fromJS(resultData200);
            return Promise.resolve<BlogPostCommonDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogPostCommonDto>(null as any);
    }

    /**
     * @param authorId (optional) 
     * @param tagId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    blogPostsGET4(blogSlug: string, authorId: string | undefined, tagId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-public/blog-posts/{blogSlug}?";
        if (blogSlug === undefined || blogSlug === null)
            throw new Error("The parameter 'blogSlug' must be defined.");
        url_ = url_.replace("{blogSlug}", encodeURIComponent("" + blogSlug));
        if (authorId === null)
            throw new Error("The parameter 'authorId' cannot be null.");
        else if (authorId !== undefined)
            url_ += "AuthorId=" + encodeURIComponent("" + authorId) + "&";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogPostsGET4(_response);
        });
    }

    protected processBlogPostsGET4(response: AxiosResponse): Promise<PagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    authors(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-public/blog-posts/authors?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthors(_response);
        });
    }

    protected processAuthors(response: AxiosResponse): Promise<PagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    authors2(id: string , cancelToken?: CancelToken | undefined): Promise<CmsUserDto3> {
        let url_ = this.baseUrl + "/api/cms-kit-public/blog-posts/authors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthors2(_response);
        });
    }

    protected processAuthors2(response: AxiosResponse): Promise<CmsUserDto3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CmsUserDto3.fromJS(resultData200);
            return Promise.resolve<CmsUserDto3>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CmsUserDto3>(null as any);
    }

    /**
     * @return Success
     */
    blogsGET3(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/blogging/blogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogsGET3(_response);
        });
    }

    protected processBlogsGET3(response: AxiosResponse): Promise<ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    byShortname(shortName: string , cancelToken?: CancelToken | undefined): Promise<BlogDto> {
        let url_ = this.baseUrl + "/api/blogging/blogs/by-shortname/{shortName}";
        if (shortName === undefined || shortName === null)
            throw new Error("The parameter 'shortName' must be defined.");
        url_ = url_.replace("{shortName}", encodeURIComponent("" + shortName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByShortname(_response);
        });
    }

    protected processByShortname(response: AxiosResponse): Promise<BlogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogDto.fromJS(resultData200);
            return Promise.resolve<BlogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogDto>(null as any);
    }

    /**
     * @return Success
     */
    blogsGET4(id: string , cancelToken?: CancelToken | undefined): Promise<BlogDto> {
        let url_ = this.baseUrl + "/api/blogging/blogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBlogsGET4(_response);
        });
    }

    protected processBlogsGET4(response: AxiosResponse): Promise<BlogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BlogDto.fromJS(resultData200);
            return Promise.resolve<BlogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BlogDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    claimTypesGET(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/claim-types?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesGET(_response);
        });
    }

    protected processClaimTypesGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claimTypesPOST(body: CreateClaimTypeDto | undefined , cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto> {
        let url_ = this.baseUrl + "/api/identity/claim-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesPOST(_response);
        });
    }

    protected processClaimTypesPOST(response: AxiosResponse): Promise<ClaimTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClaimTypeDto.fromJS(resultData200);
            return Promise.resolve<ClaimTypeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto>(null as any);
    }

    /**
     * @return Success
     */
    claimTypesGET2(id: string , cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto> {
        let url_ = this.baseUrl + "/api/identity/claim-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesGET2(_response);
        });
    }

    protected processClaimTypesGET2(response: AxiosResponse): Promise<ClaimTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClaimTypeDto.fromJS(resultData200);
            return Promise.resolve<ClaimTypeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claimTypesPUT(id: string, body: UpdateClaimTypeDto | undefined , cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto> {
        let url_ = this.baseUrl + "/api/identity/claim-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesPUT(_response);
        });
    }

    protected processClaimTypesPUT(response: AxiosResponse): Promise<ClaimTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClaimTypeDto.fromJS(resultData200);
            return Promise.resolve<ClaimTypeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto>(null as any);
    }

    /**
     * @return Success
     */
    claimTypesDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/claim-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesDELETE(_response);
        });
    }

    protected processClaimTypesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param entityType (optional) 
     * @param text (optional) 
     * @param repliedCommentId (optional) 
     * @param author (optional) 
     * @param creationStartDate (optional) 
     * @param creationEndDate (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    commentsGET(entityType: string | undefined, text: string | undefined, repliedCommentId: string | undefined, author: string | undefined, creationStartDate: Date | undefined, creationEndDate: Date | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/comments?";
        if (entityType === null)
            throw new Error("The parameter 'entityType' cannot be null.");
        else if (entityType !== undefined)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (text === null)
            throw new Error("The parameter 'text' cannot be null.");
        else if (text !== undefined)
            url_ += "Text=" + encodeURIComponent("" + text) + "&";
        if (repliedCommentId === null)
            throw new Error("The parameter 'repliedCommentId' cannot be null.");
        else if (repliedCommentId !== undefined)
            url_ += "RepliedCommentId=" + encodeURIComponent("" + repliedCommentId) + "&";
        if (author === null)
            throw new Error("The parameter 'author' cannot be null.");
        else if (author !== undefined)
            url_ += "Author=" + encodeURIComponent("" + author) + "&";
        if (creationStartDate === null)
            throw new Error("The parameter 'creationStartDate' cannot be null.");
        else if (creationStartDate !== undefined)
            url_ += "CreationStartDate=" + encodeURIComponent(creationStartDate ? "" + creationStartDate.toISOString() : "") + "&";
        if (creationEndDate === null)
            throw new Error("The parameter 'creationEndDate' cannot be null.");
        else if (creationEndDate !== undefined)
            url_ += "CreationEndDate=" + encodeURIComponent(creationEndDate ? "" + creationEndDate.toISOString() : "") + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsGET(_response);
        });
    }

    protected processCommentsGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    commentsGET2(id: string , cancelToken?: CancelToken | undefined): Promise<CommentWithAuthorDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsGET2(_response);
        });
    }

    protected processCommentsGET2(response: AxiosResponse): Promise<CommentWithAuthorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommentWithAuthorDto.fromJS(resultData200);
            return Promise.resolve<CommentWithAuthorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommentWithAuthorDto>(null as any);
    }

    /**
     * @return Success
     */
    commentsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsDELETE(_response);
        });
    }

    protected processCommentsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    commentsGET3(entityType: string, entityId: string , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-public/comments/{entityType}/{entityId}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsGET3(_response);
        });
    }

    protected processCommentsGET3(response: AxiosResponse): Promise<ListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPOST(entityType: string, entityId: string, body: CreateCommentInput | undefined , cancelToken?: CancelToken | undefined): Promise<CommentDto> {
        let url_ = this.baseUrl + "/api/cms-kit-public/comments/{entityType}/{entityId}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsPOST(_response);
        });
    }

    protected processCommentsPOST(response: AxiosResponse): Promise<CommentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommentDto.fromJS(resultData200);
            return Promise.resolve<CommentDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPUT(id: string, body: UpdateCommentInput | undefined , cancelToken?: CancelToken | undefined): Promise<CommentDto> {
        let url_ = this.baseUrl + "/api/cms-kit-public/comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsPUT(_response);
        });
    }

    protected processCommentsPUT(response: AxiosResponse): Promise<CommentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommentDto.fromJS(resultData200);
            return Promise.resolve<CommentDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommentDto>(null as any);
    }

    /**
     * @return Success
     */
    commentsDELETE2(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-public/comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsDELETE2(_response);
        });
    }

    protected processCommentsDELETE2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    hierarchical(postId: string , cancelToken?: CancelToken | undefined): Promise<CommentWithRepliesDto[]> {
        let url_ = this.baseUrl + "/api/blogging/comments/hierarchical/{postId}";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHierarchical(_response);
        });
    }

    protected processHierarchical(response: AxiosResponse): Promise<CommentWithRepliesDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommentWithRepliesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CommentWithRepliesDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommentWithRepliesDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPOST2(body: CreateCommentDto | undefined , cancelToken?: CancelToken | undefined): Promise<CommentWithDetailsDto> {
        let url_ = this.baseUrl + "/api/blogging/comments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsPOST2(_response);
        });
    }

    protected processCommentsPOST2(response: AxiosResponse): Promise<CommentWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommentWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<CommentWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommentWithDetailsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    commentsPUT2(id: string, body: UpdateCommentDto | undefined , cancelToken?: CancelToken | undefined): Promise<CommentWithDetailsDto> {
        let url_ = this.baseUrl + "/api/blogging/comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsPUT2(_response);
        });
    }

    protected processCommentsPUT2(response: AxiosResponse): Promise<CommentWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommentWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<CommentWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommentWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    commentsDELETE3(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/blogging/comments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommentsDELETE3(_response);
        });
    }

    protected processCommentsDELETE3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param includeOtherContacts (optional) 
     * @return Success
     */
    contactsAll(filter: string | undefined, includeOtherContacts: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ChatContactDto[]> {
        let url_ = this.baseUrl + "/api/chat/contact/contacts?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (includeOtherContacts === null)
            throw new Error("The parameter 'includeOtherContacts' cannot be null.");
        else if (includeOtherContacts !== undefined)
            url_ += "IncludeOtherContacts=" + encodeURIComponent("" + includeOtherContacts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContactsAll(_response);
        });
    }

    protected processContactsAll(response: AxiosResponse): Promise<ChatContactDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatContactDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ChatContactDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChatContactDto[]>(null as any);
    }

    /**
     * @return Success
     */
    totalUnreadMessageCount(  cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/chat/contact/total-unread-message-count";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTotalUnreadMessageCount(_response);
        });
    }

    protected processTotalUnreadMessageCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contacts(body: ContactCreateInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-public/contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContacts(_response);
        });
    }

    protected processContacts(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    settingsGET2(  cancelToken?: CancelToken | undefined): Promise<CmsKitContactSettingDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/contact/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsGET2(_response);
        });
    }

    protected processSettingsGET2(response: AxiosResponse): Promise<CmsKitContactSettingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CmsKitContactSettingDto.fromJS(resultData200);
            return Promise.resolve<CmsKitContactSettingDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CmsKitContactSettingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    settingsPOST(body: UpdateCmsKitContactSettingDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/contact/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsPOST(_response);
        });
    }

    protected processSettingsPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendMessage(body: SendMessageInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/chat/conversation/send-message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param targetUserId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    conversation(targetUserId: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ChatConversationDto> {
        let url_ = this.baseUrl + "/api/chat/conversation/conversation?";
        if (targetUserId === null)
            throw new Error("The parameter 'targetUserId' cannot be null.");
        else if (targetUserId !== undefined)
            url_ += "TargetUserId=" + encodeURIComponent("" + targetUserId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConversation(_response);
        });
    }

    protected processConversation(response: AxiosResponse): Promise<ChatConversationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChatConversationDto.fromJS(resultData200);
            return Promise.resolve<ChatConversationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChatConversationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markConversationAsRead(body: MarkConversationAsReadInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/chat/conversation/mark-conversation-as-read";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkConversationAsRead(_response);
        });
    }

    protected processMarkConversationAsRead(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    directoryDescriptorGET(id: string , cancelToken?: CancelToken | undefined): Promise<DirectoryDescriptorDto> {
        let url_ = this.baseUrl + "/api/file-management/directory-descriptor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDirectoryDescriptorGET(_response);
        });
    }

    protected processDirectoryDescriptorGET(response: AxiosResponse): Promise<DirectoryDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DirectoryDescriptorDto.fromJS(resultData200);
            return Promise.resolve<DirectoryDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DirectoryDescriptorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    directoryDescriptorPOST(id: string, body: RenameDirectoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<DirectoryDescriptorDto> {
        let url_ = this.baseUrl + "/api/file-management/directory-descriptor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDirectoryDescriptorPOST(_response);
        });
    }

    protected processDirectoryDescriptorPOST(response: AxiosResponse): Promise<DirectoryDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DirectoryDescriptorDto.fromJS(resultData200);
            return Promise.resolve<DirectoryDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DirectoryDescriptorDto>(null as any);
    }

    /**
     * @return Success
     */
    directoryDescriptorDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/file-management/directory-descriptor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDirectoryDescriptorDELETE(_response);
        });
    }

    protected processDirectoryDescriptorDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    subDirectories(parentId: string | undefined , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/file-management/directory-descriptor/sub-directories?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubDirectories(_response);
        });
    }

    protected processSubDirectories(response: AxiosResponse): Promise<ListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    directoryDescriptorPOST2(body: CreateDirectoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<DirectoryDescriptorDto> {
        let url_ = this.baseUrl + "/api/file-management/directory-descriptor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDirectoryDescriptorPOST2(_response);
        });
    }

    protected processDirectoryDescriptorPOST2(response: AxiosResponse): Promise<DirectoryDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DirectoryDescriptorDto.fromJS(resultData200);
            return Promise.resolve<DirectoryDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DirectoryDescriptorDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    directoryDescriptorGET2(filter: string | undefined, id: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/file-management/directory-descriptor?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDirectoryDescriptorGET2(_response);
        });
    }

    protected processDirectoryDescriptorGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    movePOST(body: MoveDirectoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<DirectoryDescriptorDto> {
        let url_ = this.baseUrl + "/api/file-management/directory-descriptor/move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMovePOST(_response);
        });
    }

    protected processMovePOST(response: AxiosResponse): Promise<DirectoryDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DirectoryDescriptorDto.fromJS(resultData200);
            return Promise.resolve<DirectoryDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DirectoryDescriptorDto>(null as any);
    }

    /**
     * @return Success
     */
    editionsGET(id: string , cancelToken?: CancelToken | undefined): Promise<EditionDto> {
        let url_ = this.baseUrl + "/api/saas/editions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsGET(_response);
        });
    }

    protected processEditionsGET(response: AxiosResponse): Promise<EditionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EditionDto.fromJS(resultData200);
            return Promise.resolve<EditionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EditionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editionsPUT(id: string, body: EditionUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<EditionDto> {
        let url_ = this.baseUrl + "/api/saas/editions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsPUT(_response);
        });
    }

    protected processEditionsPUT(response: AxiosResponse): Promise<EditionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EditionDto.fromJS(resultData200);
            return Promise.resolve<EditionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EditionDto>(null as any);
    }

    /**
     * @return Success
     */
    editionsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/editions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsDELETE(_response);
        });
    }

    protected processEditionsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    editionsGET2(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/saas/editions?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsGET2(_response);
        });
    }

    protected processEditionsGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editionsPOST(body: EditionCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<EditionDto> {
        let url_ = this.baseUrl + "/api/saas/editions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsPOST(_response);
        });
    }

    protected processEditionsPOST(response: AxiosResponse): Promise<EditionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EditionDto.fromJS(resultData200);
            return Promise.resolve<EditionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EditionDto>(null as any);
    }

    /**
     * @return Success
     */
    usageStatistic(  cancelToken?: CancelToken | undefined): Promise<GetEditionUsageStatisticsResultDto> {
        let url_ = this.baseUrl + "/api/saas/editions/statistics/usage-statistic";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsageStatistic(_response);
        });
    }

    protected processUsageStatistic(response: AxiosResponse): Promise<GetEditionUsageStatisticsResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetEditionUsageStatisticsResultDto.fromJS(resultData200);
            return Promise.resolve<GetEditionUsageStatisticsResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetEditionUsageStatisticsResultDto>(null as any);
    }

    /**
     * @return Success
     */
    planLookup(  cancelToken?: CancelToken | undefined): Promise<PlanDto[]> {
        let url_ = this.baseUrl + "/api/saas/editions/plan-lookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlanLookup(_response);
        });
    }

    protected processPlanLookup(response: AxiosResponse): Promise<PlanDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlanDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PlanDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto[]>(null as any);
    }

    /**
     * @param editionId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    subscription(editionId: string | undefined, tenantId: string | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentRequestWithDetailsDto> {
        let url_ = this.baseUrl + "/api/saas/subscription?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscription(_response);
        });
    }

    protected processSubscription(response: AxiosResponse): Promise<PaymentRequestWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentRequestWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PaymentRequestWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentRequestWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    emailingGET(  cancelToken?: CancelToken | undefined): Promise<EmailSettingsDto> {
        let url_ = this.baseUrl + "/api/setting-management/emailing";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailingGET(_response);
        });
    }

    protected processEmailingGET(response: AxiosResponse): Promise<EmailSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EmailSettingsDto.fromJS(resultData200);
            return Promise.resolve<EmailSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmailSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    emailingPOST(body: UpdateEmailSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/setting-management/emailing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailingPOST(_response);
        });
    }

    protected processEmailingPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/setting-management/emailing/send-test-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendTestEmail(_response);
        });
    }

    protected processSendTestEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    entityTagsPOST(body: EntityTagCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/entity-tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityTagsPOST(_response);
        });
    }

    protected processEntityTagsPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    entityTagsDELETE(tagId: string, entityType: string, entityId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/entity-tags?";
        if (tagId === undefined || tagId === null)
            throw new Error("The parameter 'tagId' must be defined and cannot be null.");
        else
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined and cannot be null.");
        else
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityTagsDELETE(_response);
        });
    }

    protected processEntityTagsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    entityTagsPUT(body: EntityTagSetDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/entity-tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityTagsPUT(_response);
        });
    }

    protected processEntityTagsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalLogin(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/external-login";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalLogin(_response);
        });
    }

    protected processExternalLogin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    featuresGET2(providerName: string | undefined, providerKey: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetFeatureListResultDto> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesGET2(_response);
        });
    }

    protected processFeaturesGET2(response: AxiosResponse): Promise<GetFeatureListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetFeatureListResultDto.fromJS(resultData200);
            return Promise.resolve<GetFeatureListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetFeatureListResultDto>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    featuresPUT2(providerName: string | undefined, providerKey: string | undefined, body: UpdateFeaturesDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesPUT2(_response);
        });
    }

    protected processFeaturesPUT2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    featuresDELETE(providerName: string | undefined, providerKey: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesDELETE(_response);
        });
    }

    protected processFeaturesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    fileDescriptorGET(id: string , cancelToken?: CancelToken | undefined): Promise<FileDescriptorDto> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFileDescriptorGET(_response);
        });
    }

    protected processFileDescriptorGET(response: AxiosResponse): Promise<FileDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDescriptorDto.fromJS(resultData200);
            return Promise.resolve<FileDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDescriptorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    fileDescriptorPOST(id: string, body: RenameFileInput | undefined , cancelToken?: CancelToken | undefined): Promise<FileDescriptorDto> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFileDescriptorPOST(_response);
        });
    }

    protected processFileDescriptorPOST(response: AxiosResponse): Promise<FileDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDescriptorDto.fromJS(resultData200);
            return Promise.resolve<FileDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDescriptorDto>(null as any);
    }

    /**
     * @return Success
     */
    fileDescriptorDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFileDescriptorDELETE(_response);
        });
    }

    protected processFileDescriptorDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param directoryId (optional) 
     * @return Success
     */
    fileDescriptorGET2(directoryId: string | undefined , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor?";
        if (directoryId === null)
            throw new Error("The parameter 'directoryId' cannot be null.");
        else if (directoryId !== undefined)
            url_ += "directoryId=" + encodeURIComponent("" + directoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFileDescriptorGET2(_response);
        });
    }

    protected processFileDescriptorGET2(response: AxiosResponse): Promise<ListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param directoryId (optional) 
     * @param extraProperties (optional) 
     * @param file (optional) 
     * @return Success
     */
    upload2(directoryId: string | undefined, name: string, extraProperties: { [key: string]: any; } | undefined, file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<FileDescriptorDto> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/upload?";
        if (directoryId === null)
            throw new Error("The parameter 'directoryId' cannot be null.");
        else if (directoryId !== undefined)
            url_ += "directoryId=" + encodeURIComponent("" + directoryId) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (extraProperties === null)
            throw new Error("The parameter 'extraProperties' cannot be null.");
        else if (extraProperties !== undefined)
            url_ += "ExtraProperties=" + encodeURIComponent("" + extraProperties) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpload2(_response);
        });
    }

    protected processUpload2(response: AxiosResponse): Promise<FileDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDescriptorDto.fromJS(resultData200);
            return Promise.resolve<FileDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDescriptorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    movePOST2(body: MoveFileInput | undefined , cancelToken?: CancelToken | undefined): Promise<FileDescriptorDto> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMovePOST2(_response);
        });
    }

    protected processMovePOST2(response: AxiosResponse): Promise<FileDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDescriptorDto.fromJS(resultData200);
            return Promise.resolve<FileDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDescriptorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    preUploadInfo(body: FileUploadPreInfoRequest[] | undefined , cancelToken?: CancelToken | undefined): Promise<FileUploadPreInfoDto[]> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/pre-upload-info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPreUploadInfo(_response);
        });
    }

    protected processPreUploadInfo(response: AxiosResponse): Promise<FileUploadPreInfoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FileUploadPreInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<FileUploadPreInfoDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileUploadPreInfoDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    content(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/content?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContent(_response);
        });
    }

    protected processContent(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    token(id: string , cancelToken?: CancelToken | undefined): Promise<DownloadTokenResultDto2> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/download/{id}/token";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToken(_response);
        });
    }

    protected processToken(response: AxiosResponse): Promise<DownloadTokenResultDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DownloadTokenResultDto2.fromJS(resultData200);
            return Promise.resolve<DownloadTokenResultDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DownloadTokenResultDto2>(null as any);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    download(id: string, token: string | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/file-management/file-descriptor/download/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    responsesGET(id: string , cancelToken?: CancelToken | undefined): Promise<FormResponseDto> {
        let url_ = this.baseUrl + "/api/responses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponsesGET(_response);
        });
    }

    protected processResponsesGET(response: AxiosResponse): Promise<FormResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormResponseDto.fromJS(resultData200);
            return Promise.resolve<FormResponseDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    responsesPOST(id: string, body: UpdateResponseDto | undefined , cancelToken?: CancelToken | undefined): Promise<FormResponseDto> {
        let url_ = this.baseUrl + "/api/responses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponsesPOST(_response);
        });
    }

    protected processResponsesPOST(response: AxiosResponse): Promise<FormResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormResponseDto.fromJS(resultData200);
            return Promise.resolve<FormResponseDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    responsesDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/responses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponsesDELETE(_response);
        });
    }

    protected processResponsesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    responsesGET2(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/responses?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponsesGET2(_response);
        });
    }

    protected processResponsesGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param formId (optional) 
     * @param body (optional) 
     * @return Success
     */
    responsesPOST2(formId: string | undefined, body: CreateResponseDto | undefined , cancelToken?: CancelToken | undefined): Promise<FormResponseDto> {
        let url_ = this.baseUrl + "/api/responses?";
        if (formId === null)
            throw new Error("The parameter 'formId' cannot be null.");
        else if (formId !== undefined)
            url_ += "formId=" + encodeURIComponent("" + formId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponsesPOST2(_response);
        });
    }

    protected processResponsesPOST2(response: AxiosResponse): Promise<FormResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormResponseDto.fromJS(resultData200);
            return Promise.resolve<FormResponseDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    questionsWithAnswers(id: string , cancelToken?: CancelToken | undefined): Promise<QuestionWithAnswersDto[]> {
        let url_ = this.baseUrl + "/api/responses/{id}/questions-with-answers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionsWithAnswers(_response);
        });
    }

    protected processQuestionsWithAnswers(response: AxiosResponse): Promise<QuestionWithAnswersDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionWithAnswersDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<QuestionWithAnswersDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuestionWithAnswersDto[]>(null as any);
    }

    /**
     * @return Success
     */
    formDetails(formId: string , cancelToken?: CancelToken | undefined): Promise<FormDto> {
        let url_ = this.baseUrl + "/api/responses/form-details/{formId}";
        if (formId === undefined || formId === null)
            throw new Error("The parameter 'formId' must be defined.");
        url_ = url_.replace("{formId}", encodeURIComponent("" + formId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormDetails(_response);
        });
    }

    protected processFormDetails(response: AxiosResponse): Promise<FormDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormDto.fromJS(resultData200);
            return Promise.resolve<FormDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormDto>(null as any);
    }

    /**
     * @return Success
     */
    response(userId: string , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/responses/{userId}/response";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponse(_response);
        });
    }

    protected processResponse(response: AxiosResponse): Promise<PagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    questionsAll(input: GetQuestionListDto | undefined , cancelToken?: CancelToken | undefined): Promise<QuestionDto[]> {
        let url_ = this.baseUrl + "/api/questions?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionsAll(_response);
        });
    }

    protected processQuestionsAll(response: AxiosResponse): Promise<QuestionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<QuestionDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuestionDto[]>(null as any);
    }

    /**
     * @return Success
     */
    questionsGET(id: string , cancelToken?: CancelToken | undefined): Promise<QuestionDto> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionsGET(_response);
        });
    }

    protected processQuestionsGET(response: AxiosResponse): Promise<QuestionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuestionDto.fromJS(resultData200);
            return Promise.resolve<QuestionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuestionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    questionsPUT(id: string, body: UpdateQuestionDto | undefined , cancelToken?: CancelToken | undefined): Promise<QuestionDto> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionsPUT(_response);
        });
    }

    protected processQuestionsPUT(response: AxiosResponse): Promise<QuestionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuestionDto.fromJS(resultData200);
            return Promise.resolve<QuestionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuestionDto>(null as any);
    }

    /**
     * @return Success
     */
    questionsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/questions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionsDELETE(_response);
        });
    }

    protected processQuestionsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    formsGET(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/forms?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormsGET(_response);
        });
    }

    protected processFormsGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    formsPOST(body: CreateFormDto | undefined , cancelToken?: CancelToken | undefined): Promise<FormDto> {
        let url_ = this.baseUrl + "/api/forms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormsPOST(_response);
        });
    }

    protected processFormsPOST(response: AxiosResponse): Promise<FormDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormDto.fromJS(resultData200);
            return Promise.resolve<FormDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    responsesGET3(id: string, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/forms/{id}/responses?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponsesGET3(_response);
        });
    }

    protected processResponsesGET3(response: AxiosResponse): Promise<PagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    responsesDELETE2(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/forms/{id}/responses";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponsesDELETE2(_response);
        });
    }

    protected processResponsesDELETE2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    downloadResponsesCsv(id: string, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/forms/{id}/download-responses-csv?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadResponsesCsv(_response);
        });
    }

    protected processDownloadResponsesCsv(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    responsesCount(id: string , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/forms/{id}/responses-count";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResponsesCount(_response);
        });
    }

    protected processResponsesCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    invite(body: FormInviteEmailInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/invite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInvite(_response);
        });
    }

    protected processInvite(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    formsGET2(id: string , cancelToken?: CancelToken | undefined): Promise<FormWithDetailsDto> {
        let url_ = this.baseUrl + "/api/forms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormsGET2(_response);
        });
    }

    protected processFormsGET2(response: AxiosResponse): Promise<FormWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<FormWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormWithDetailsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    formsPUT(id: string, body: UpdateFormDto | undefined , cancelToken?: CancelToken | undefined): Promise<FormDto> {
        let url_ = this.baseUrl + "/api/forms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormsPUT(_response);
        });
    }

    protected processFormsPUT(response: AxiosResponse): Promise<FormDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormDto.fromJS(resultData200);
            return Promise.resolve<FormDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormDto>(null as any);
    }

    /**
     * @return Success
     */
    formsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/forms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormsDELETE(_response);
        });
    }

    protected processFormsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    settingsPUT2(id: string, body: UpdateFormSettingInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/forms/{id}/settings";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsPUT2(_response);
        });
    }

    protected processSettingsPUT2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    settingsGET3(id: string , cancelToken?: CancelToken | undefined): Promise<FormSettingsDto> {
        let url_ = this.baseUrl + "/api/forms/{id}/settings";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsGET3(_response);
        });
    }

    protected processSettingsGET3(response: AxiosResponse): Promise<FormSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FormSettingsDto.fromJS(resultData200);
            return Promise.resolve<FormSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FormSettingsDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    questionsAll2(id: string, input: GetQuestionListDto | undefined , cancelToken?: CancelToken | undefined): Promise<QuestionDto[]> {
        let url_ = this.baseUrl + "/api/forms/{id}/questions?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionsAll2(_response);
        });
    }

    protected processQuestionsAll2(response: AxiosResponse): Promise<QuestionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<QuestionDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuestionDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    questionsPOST(id: string, body: CreateQuestionDto | undefined , cancelToken?: CancelToken | undefined): Promise<QuestionDto> {
        let url_ = this.baseUrl + "/api/forms/{id}/questions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processQuestionsPOST(_response);
        });
    }

    protected processQuestionsPOST(response: AxiosResponse): Promise<QuestionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = QuestionDto.fromJS(resultData200);
            return Promise.resolve<QuestionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<QuestionDto>(null as any);
    }

    /**
     * @return Success
     */
    gateways(  cancelToken?: CancelToken | undefined): Promise<GatewayDto[]> {
        let url_ = this.baseUrl + "/api/payment/gateways";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGateways(_response);
        });
    }

    protected processGateways(response: AxiosResponse): Promise<GatewayDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GatewayDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GatewayDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GatewayDto[]>(null as any);
    }

    /**
     * @return Success
     */
    subscriptionSupported(  cancelToken?: CancelToken | undefined): Promise<GatewayDto[]> {
        let url_ = this.baseUrl + "/api/payment/gateways/subscription-supported";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscriptionSupported(_response);
        });
    }

    protected processSubscriptionSupported(response: AxiosResponse): Promise<GatewayDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GatewayDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GatewayDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GatewayDto[]>(null as any);
    }

    /**
     * @return Success
     */
    prepareData(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/gdpr/requests/prepare-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrepareData(_response);
        });
    }

    protected processPrepareData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    downloadToken(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<DownloadTokenResultDto> {
        let url_ = this.baseUrl + "/api/gdpr/requests/download-token?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadToken(_response);
        });
    }

    protected processDownloadToken(response: AxiosResponse): Promise<DownloadTokenResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DownloadTokenResultDto.fromJS(resultData200);
            return Promise.resolve<DownloadTokenResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DownloadTokenResultDto>(null as any);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    data(requestId: string, token: string | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/gdpr/requests/data/{requestId}?";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processData(_response);
        });
    }

    protected processData(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    isRequestAllowed(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/gdpr/requests/is-request-allowed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsRequestAllowed(_response);
        });
    }

    protected processIsRequestAllowed(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    list(userId: string, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/gdpr/requests/list?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    requestsDELETE(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/gdpr/requests";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestsDELETE(_response);
        });
    }

    protected processRequestsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    globalResourcesGET(  cancelToken?: CancelToken | undefined): Promise<GlobalResourcesDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/global-resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalResourcesGET(_response);
        });
    }

    protected processGlobalResourcesGET(response: AxiosResponse): Promise<GlobalResourcesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GlobalResourcesDto.fromJS(resultData200);
            return Promise.resolve<GlobalResourcesDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GlobalResourcesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    globalResourcesPOST(body: GlobalResourcesUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/global-resources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGlobalResourcesPOST(_response);
        });
    }

    protected processGlobalResourcesPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    script(  cancelToken?: CancelToken | undefined): Promise<GlobalResourceDto> {
        let url_ = this.baseUrl + "/api/cms-kit-public/global-resources/script";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScript(_response);
        });
    }

    protected processScript(response: AxiosResponse): Promise<GlobalResourceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GlobalResourceDto.fromJS(resultData200);
            return Promise.resolve<GlobalResourceDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GlobalResourceDto>(null as any);
    }

    /**
     * @return Success
     */
    style(  cancelToken?: CancelToken | undefined): Promise<GlobalResourceDto> {
        let url_ = this.baseUrl + "/api/cms-kit-public/global-resources/style";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStyle(_response);
        });
    }

    protected processStyle(response: AxiosResponse): Promise<GlobalResourceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GlobalResourceDto.fromJS(resultData200);
            return Promise.resolve<GlobalResourceDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GlobalResourceDto>(null as any);
    }

    /**
     * @return Success
     */
    all(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/language-management/languages/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: AxiosResponse): Promise<ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param resourceName (optional) 
     * @param baseCultureName (optional) 
     * @param targetCultureName (optional) 
     * @param getOnlyEmptyValues (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    languagesGET(filter: string | undefined, resourceName: string | undefined, baseCultureName: string | undefined, targetCultureName: string | undefined, getOnlyEmptyValues: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/language-management/languages?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (resourceName === null)
            throw new Error("The parameter 'resourceName' cannot be null.");
        else if (resourceName !== undefined)
            url_ += "ResourceName=" + encodeURIComponent("" + resourceName) + "&";
        if (baseCultureName === null)
            throw new Error("The parameter 'baseCultureName' cannot be null.");
        else if (baseCultureName !== undefined)
            url_ += "BaseCultureName=" + encodeURIComponent("" + baseCultureName) + "&";
        if (targetCultureName === null)
            throw new Error("The parameter 'targetCultureName' cannot be null.");
        else if (targetCultureName !== undefined)
            url_ += "TargetCultureName=" + encodeURIComponent("" + targetCultureName) + "&";
        if (getOnlyEmptyValues === null)
            throw new Error("The parameter 'getOnlyEmptyValues' cannot be null.");
        else if (getOnlyEmptyValues !== undefined)
            url_ += "GetOnlyEmptyValues=" + encodeURIComponent("" + getOnlyEmptyValues) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesGET(_response);
        });
    }

    protected processLanguagesGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    languagesPOST(body: CreateLanguageDto | undefined , cancelToken?: CancelToken | undefined): Promise<LanguageDto> {
        let url_ = this.baseUrl + "/api/language-management/languages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesPOST(_response);
        });
    }

    protected processLanguagesPOST(response: AxiosResponse): Promise<LanguageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageDto.fromJS(resultData200);
            return Promise.resolve<LanguageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageDto>(null as any);
    }

    /**
     * @return Success
     */
    languagesGET2(id: string , cancelToken?: CancelToken | undefined): Promise<LanguageDto> {
        let url_ = this.baseUrl + "/api/language-management/languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesGET2(_response);
        });
    }

    protected processLanguagesGET2(response: AxiosResponse): Promise<LanguageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageDto.fromJS(resultData200);
            return Promise.resolve<LanguageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    languagesPUT(id: string, body: UpdateLanguageDto | undefined , cancelToken?: CancelToken | undefined): Promise<LanguageDto> {
        let url_ = this.baseUrl + "/api/language-management/languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesPUT(_response);
        });
    }

    protected processLanguagesPUT(response: AxiosResponse): Promise<LanguageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageDto.fromJS(resultData200);
            return Promise.resolve<LanguageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageDto>(null as any);
    }

    /**
     * @return Success
     */
    languagesDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/language-management/languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesDELETE(_response);
        });
    }

    protected processLanguagesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    setAsDefault(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/language-management/languages/{id}/set-as-default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetAsDefault(_response);
        });
    }

    protected processSetAsDefault(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    resources(  cancelToken?: CancelToken | undefined): Promise<LanguageResourceDto[]> {
        let url_ = this.baseUrl + "/api/language-management/languages/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResources(_response);
        });
    }

    protected processResources(response: AxiosResponse): Promise<LanguageResourceDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageResourceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LanguageResourceDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageResourceDto[]>(null as any);
    }

    /**
     * @return Success
     */
    cultureList(  cancelToken?: CancelToken | undefined): Promise<CultureInfoDto[]> {
        let url_ = this.baseUrl + "/api/language-management/languages/culture-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCultureList(_response);
        });
    }

    protected processCultureList(response: AxiosResponse): Promise<CultureInfoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CultureInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CultureInfoDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CultureInfoDto[]>(null as any);
    }

    /**
     * @return Success
     */
    flagList(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/language-management/languages/flag-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFlagList(_response);
        });
    }

    protected processFlagList(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param resourceName (optional) 
     * @param baseCultureName (optional) 
     * @param targetCultureName (optional) 
     * @param getOnlyEmptyValues (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    languageTextsGET(filter: string | undefined, resourceName: string | undefined, baseCultureName: string | undefined, targetCultureName: string | undefined, getOnlyEmptyValues: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/language-management/language-texts?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (resourceName === null)
            throw new Error("The parameter 'resourceName' cannot be null.");
        else if (resourceName !== undefined)
            url_ += "ResourceName=" + encodeURIComponent("" + resourceName) + "&";
        if (baseCultureName === null)
            throw new Error("The parameter 'baseCultureName' cannot be null.");
        else if (baseCultureName !== undefined)
            url_ += "BaseCultureName=" + encodeURIComponent("" + baseCultureName) + "&";
        if (targetCultureName === null)
            throw new Error("The parameter 'targetCultureName' cannot be null.");
        else if (targetCultureName !== undefined)
            url_ += "TargetCultureName=" + encodeURIComponent("" + targetCultureName) + "&";
        if (getOnlyEmptyValues === null)
            throw new Error("The parameter 'getOnlyEmptyValues' cannot be null.");
        else if (getOnlyEmptyValues !== undefined)
            url_ += "GetOnlyEmptyValues=" + encodeURIComponent("" + getOnlyEmptyValues) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageTextsGET(_response);
        });
    }

    protected processLanguageTextsGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param baseCultureName (optional) 
     * @return Success
     */
    languageTextsGET2(resourceName: string, cultureName: string, name: string, baseCultureName: string | undefined , cancelToken?: CancelToken | undefined): Promise<LanguageTextDto> {
        let url_ = this.baseUrl + "/api/language-management/language-texts/{resourceName}/{cultureName}/{name}?";
        if (resourceName === undefined || resourceName === null)
            throw new Error("The parameter 'resourceName' must be defined.");
        url_ = url_.replace("{resourceName}", encodeURIComponent("" + resourceName));
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined.");
        url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (baseCultureName === null)
            throw new Error("The parameter 'baseCultureName' cannot be null.");
        else if (baseCultureName !== undefined)
            url_ += "baseCultureName=" + encodeURIComponent("" + baseCultureName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageTextsGET2(_response);
        });
    }

    protected processLanguageTextsGET2(response: AxiosResponse): Promise<LanguageTextDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageTextDto.fromJS(resultData200);
            return Promise.resolve<LanguageTextDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageTextDto>(null as any);
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    languageTextsPUT(resourceName: string, cultureName: string, name: string, value: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/language-management/language-texts/{resourceName}/{cultureName}/{name}?";
        if (resourceName === undefined || resourceName === null)
            throw new Error("The parameter 'resourceName' must be defined.");
        url_ = url_.replace("{resourceName}", encodeURIComponent("" + resourceName));
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined.");
        url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageTextsPUT(_response);
        });
    }

    protected processLanguageTextsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    restore(resourceName: string, cultureName: string, name: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/language-management/language-texts/{resourceName}/{cultureName}/{name}/restore";
        if (resourceName === undefined || resourceName === null)
            throw new Error("The parameter 'resourceName' must be defined.");
        url_ = url_.replace("{resourceName}", encodeURIComponent("" + resourceName));
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined.");
        url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestore(_response);
        });
    }

    protected processRestore(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: UserLoginInfo | undefined , cancelToken?: CancelToken | undefined): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<AbpLoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AbpLoginResult.fromJS(resultData200);
            return Promise.resolve<AbpLoginResult>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AbpLoginResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkLogin(body: LinkUserLoginInfo | undefined , cancelToken?: CancelToken | undefined): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/linkLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLinkLogin(_response);
        });
    }

    protected processLinkLogin(response: AxiosResponse): Promise<AbpLoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AbpLoginResult.fromJS(resultData200);
            return Promise.resolve<AbpLoginResult>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AbpLoginResult>(null as any);
    }

    /**
     * @return Success
     */
    logout(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPassword(body: UserLoginInfo | undefined , cancelToken?: CancelToken | undefined): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/checkPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPassword(_response);
        });
    }

    protected processCheckPassword(response: AxiosResponse): Promise<AbpLoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AbpLoginResult.fromJS(resultData200);
            return Promise.resolve<AbpLoginResult>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AbpLoginResult>(null as any);
    }

    /**
     * @return Success
     */
    mediaGET(id: string , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/cms-kit/media/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMediaGET(_response);
        });
    }

    protected processMediaGET(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    mediaPOST(entityType: string, name: string, file: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<MediaDescriptorDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/media/{entityType}?";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMediaPOST(_response);
        });
    }

    protected processMediaPOST(response: AxiosResponse): Promise<MediaDescriptorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MediaDescriptorDto.fromJS(resultData200);
            return Promise.resolve<MediaDescriptorDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MediaDescriptorDto>(null as any);
    }

    /**
     * @return Success
     */
    mediaDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/media/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMediaDELETE(_response);
        });
    }

    protected processMediaDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    menuItemsGET(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/menu-items";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsGET(_response);
        });
    }

    protected processMenuItemsGET(response: AxiosResponse): Promise<ListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    menuItemsPOST(body: MenuItemCreateInput | undefined , cancelToken?: CancelToken | undefined): Promise<MenuItemDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/menu-items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsPOST(_response);
        });
    }

    protected processMenuItemsPOST(response: AxiosResponse): Promise<MenuItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuItemDto.fromJS(resultData200);
            return Promise.resolve<MenuItemDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuItemDto>(null as any);
    }

    /**
     * @return Success
     */
    menuItemsGET2(id: string , cancelToken?: CancelToken | undefined): Promise<MenuItemDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/menu-items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsGET2(_response);
        });
    }

    protected processMenuItemsGET2(response: AxiosResponse): Promise<MenuItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuItemDto.fromJS(resultData200);
            return Promise.resolve<MenuItemDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuItemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    menuItemsPUT(id: string, body: MenuItemUpdateInput | undefined , cancelToken?: CancelToken | undefined): Promise<MenuItemDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/menu-items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsPUT(_response);
        });
    }

    protected processMenuItemsPUT(response: AxiosResponse): Promise<MenuItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MenuItemDto.fromJS(resultData200);
            return Promise.resolve<MenuItemDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuItemDto>(null as any);
    }

    /**
     * @return Success
     */
    menuItemsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/menu-items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsDELETE(_response);
        });
    }

    protected processMenuItemsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    movePUT(id: string, body: MenuItemMoveInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/menu-items/{id}/move";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMovePUT(_response);
        });
    }

    protected processMovePUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    pagesGET(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/menu-items/lookup/pages?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPagesGET(_response);
        });
    }

    protected processPagesGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    menuItemsAll(  cancelToken?: CancelToken | undefined): Promise<MenuItemDto[]> {
        let url_ = this.baseUrl + "/api/cms-kit-public/menu-items";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMenuItemsAll(_response);
        });
    }

    protected processMenuItemsAll(response: AxiosResponse): Promise<MenuItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MenuItemDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MenuItemDto[]>(null as any);
    }

    /**
     * @param preference (optional) 
     * @param source (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    newsletterGET(preference: string | undefined, source: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/newsletter?";
        if (preference === null)
            throw new Error("The parameter 'preference' cannot be null.");
        else if (preference !== undefined)
            url_ += "Preference=" + encodeURIComponent("" + preference) + "&";
        if (source === null)
            throw new Error("The parameter 'source' cannot be null.");
        else if (source !== undefined)
            url_ += "Source=" + encodeURIComponent("" + source) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewsletterGET(_response);
        });
    }

    protected processNewsletterGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    newsletterGET2(id: string , cancelToken?: CancelToken | undefined): Promise<NewsletterRecordWithDetailsDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/newsletter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewsletterGET2(_response);
        });
    }

    protected processNewsletterGET2(response: AxiosResponse): Promise<NewsletterRecordWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsletterRecordWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<NewsletterRecordWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsletterRecordWithDetailsDto>(null as any);
    }

    /**
     * @param preference (optional) 
     * @param source (optional) 
     * @return Success
     */
    csvDetail(preference: string | undefined, source: string | undefined , cancelToken?: CancelToken | undefined): Promise<NewsletterRecordCsvDto[]> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/newsletter/csv-detail?";
        if (preference === null)
            throw new Error("The parameter 'preference' cannot be null.");
        else if (preference !== undefined)
            url_ += "Preference=" + encodeURIComponent("" + preference) + "&";
        if (source === null)
            throw new Error("The parameter 'source' cannot be null.");
        else if (source !== undefined)
            url_ += "Source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCsvDetail(_response);
        });
    }

    protected processCsvDetail(response: AxiosResponse): Promise<NewsletterRecordCsvDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsletterRecordCsvDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsletterRecordCsvDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsletterRecordCsvDto[]>(null as any);
    }

    /**
     * @return Success
     */
    preferences(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/newsletter/preferences";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPreferences(_response);
        });
    }

    protected processPreferences(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param preference (optional) 
     * @param source (optional) 
     * @return Success
     */
    exportCsv(preference: string | undefined, source: string | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/newsletter/export-csv?";
        if (preference === null)
            throw new Error("The parameter 'preference' cannot be null.");
        else if (preference !== undefined)
            url_ += "Preference=" + encodeURIComponent("" + preference) + "&";
        if (source === null)
            throw new Error("The parameter 'source' cannot be null.");
        else if (source !== undefined)
            url_ += "Source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportCsv(_response);
        });
    }

    protected processExportCsv(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    newsletterPOST(body: CreateNewsletterRecordInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-public/newsletter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewsletterPOST(_response);
        });
    }

    protected processNewsletterPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    newsletterPUT(body: UpdatePreferenceRequestInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-public/newsletter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewsletterPUT(_response);
        });
    }

    protected processNewsletterPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param emailAddress (optional) 
     * @return Success
     */
    emailAddress(emailAddress: string | undefined , cancelToken?: CancelToken | undefined): Promise<NewsletterPreferenceDetailsDto[]> {
        let url_ = this.baseUrl + "/api/cms-kit-public/newsletter/emailAddress?";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "emailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailAddress(_response);
        });
    }

    protected processEmailAddress(response: AxiosResponse): Promise<NewsletterPreferenceDetailsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NewsletterPreferenceDetailsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<NewsletterPreferenceDetailsDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsletterPreferenceDetailsDto[]>(null as any);
    }

    /**
     * @param preference (optional) 
     * @return Success
     */
    preferenceOptions(preference: string | undefined , cancelToken?: CancelToken | undefined): Promise<NewsletterEmailOptionsDto> {
        let url_ = this.baseUrl + "/api/cms-kit-public/newsletter/preference-options?";
        if (preference === null)
            throw new Error("The parameter 'preference' cannot be null.");
        else if (preference !== undefined)
            url_ += "preference=" + encodeURIComponent("" + preference) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPreferenceOptions(_response);
        });
    }

    protected processPreferenceOptions(response: AxiosResponse): Promise<NewsletterEmailOptionsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsletterEmailOptionsDto.fromJS(resultData200);
            return Promise.resolve<NewsletterEmailOptionsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsletterEmailOptionsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT(id: string, body: OrganizationUnitRoleInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPUT(_response);
        });
    }

    protected processRolesPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    rolesGET(id: string, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/roles?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET(_response);
        });
    }

    protected processRolesGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    membersPUT(id: string, body: OrganizationUnitUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/members";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMembersPUT(_response);
        });
    }

    protected processMembersPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @param userName (optional) 
     * @param phoneNumber (optional) 
     * @param emailAddress (optional) 
     * @param isLockedOut (optional) 
     * @param notActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    membersGET(id: string, filter: string | undefined, roleId: string | undefined, organizationUnitId: string | undefined, userName: string | undefined, phoneNumber: string | undefined, emailAddress: string | undefined, isLockedOut: boolean | undefined, notActive: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/members?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "EmailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (isLockedOut === null)
            throw new Error("The parameter 'isLockedOut' cannot be null.");
        else if (isLockedOut !== undefined)
            url_ += "IsLockedOut=" + encodeURIComponent("" + isLockedOut) + "&";
        if (notActive === null)
            throw new Error("The parameter 'notActive' cannot be null.");
        else if (notActive !== undefined)
            url_ += "NotActive=" + encodeURIComponent("" + notActive) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMembersGET(_response);
        });
    }

    protected processMembersGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    organizationUnitsPOST(body: OrganizationUnitCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitWithDetailsDto> {
        let url_ = this.baseUrl + "/api/identity/organization-units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsPOST(_response);
        });
    }

    protected processOrganizationUnitsPOST(response: AxiosResponse): Promise<OrganizationUnitWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<OrganizationUnitWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitWithDetailsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    organizationUnitsDELETE(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsDELETE(_response);
        });
    }

    protected processOrganizationUnitsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    organizationUnitsGET(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsGET(_response);
        });
    }

    protected processOrganizationUnitsGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    organizationUnitsGET2(id: string , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitWithDetailsDto> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsGET2(_response);
        });
    }

    protected processOrganizationUnitsGET2(response: AxiosResponse): Promise<OrganizationUnitWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<OrganizationUnitWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitWithDetailsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    organizationUnitsPUT(id: string, body: OrganizationUnitUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitWithDetailsDto> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsPUT(_response);
        });
    }

    protected processOrganizationUnitsPUT(response: AxiosResponse): Promise<OrganizationUnitWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<OrganizationUnitWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    all2(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll2(_response);
        });
    }

    protected processAll2(response: AxiosResponse): Promise<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    movePUT2(id: string, body: OrganizationUnitMoveInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/move";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMovePUT2(_response);
        });
    }

    protected processMovePUT2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    availableUsers(filter: string | undefined, id: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/available-users?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAvailableUsers(_response);
        });
    }

    protected processAvailableUsers(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    availableRoles(filter: string | undefined, id: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/available-roles?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAvailableRoles(_response);
        });
    }

    protected processAvailableRoles(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    membersDELETE(id: string, memberId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/members/{memberId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (memberId === undefined || memberId === null)
            throw new Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMembersDELETE(_response);
        });
    }

    protected processMembersDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    rolesDELETE(id: string, roleId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/roles/{roleId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesDELETE(_response);
        });
    }

    protected processRolesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    pagesGET2(id: string , cancelToken?: CancelToken | undefined): Promise<PageDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/pages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPagesGET2(_response);
        });
    }

    protected processPagesGET2(response: AxiosResponse): Promise<PageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageDto.fromJS(resultData200);
            return Promise.resolve<PageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pagesPUT(id: string, body: UpdatePageInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<PageDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/pages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPagesPUT(_response);
        });
    }

    protected processPagesPUT(response: AxiosResponse): Promise<PageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageDto.fromJS(resultData200);
            return Promise.resolve<PageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageDto>(null as any);
    }

    /**
     * @return Success
     */
    pagesDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/pages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPagesDELETE(_response);
        });
    }

    protected processPagesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    pagesGET3(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/pages?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPagesGET3(_response);
        });
    }

    protected processPagesGET3(response: AxiosResponse): Promise<PagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pagesPOST(body: CreatePageInputDto | undefined , cancelToken?: CancelToken | undefined): Promise<PageDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/pages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPagesPOST(_response);
        });
    }

    protected processPagesPOST(response: AxiosResponse): Promise<PageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageDto.fromJS(resultData200);
            return Promise.resolve<PageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageDto>(null as any);
    }

    /**
     * @return Success
     */
    setashomepage(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/pages/setashomepage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetashomepage(_response);
        });
    }

    protected processSetashomepage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    pagesGET4(slug: string , cancelToken?: CancelToken | undefined): Promise<PageDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-public/pages/{slug}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPagesGET4(_response);
        });
    }

    protected processPagesGET4(response: AxiosResponse): Promise<PageDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageDto2.fromJS(resultData200);
            return Promise.resolve<PageDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageDto2>(null as any);
    }

    /**
     * @return Success
     */
    pagesGET5(  cancelToken?: CancelToken | undefined): Promise<PageDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-public/pages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPagesGET5(_response);
        });
    }

    protected processPagesGET5(response: AxiosResponse): Promise<PageDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PageDto2.fromJS(resultData200);
            return Promise.resolve<PageDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PageDto2>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    complete(paymentMethod: string, body: { [key: string]: string; } | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentRequestWithDetailsDto> {
        let url_ = this.baseUrl + "/api/payment/{paymentMethod}/complete";
        if (paymentMethod === undefined || paymentMethod === null)
            throw new Error("The parameter 'paymentMethod' must be defined.");
        url_ = url_.replace("{paymentMethod}", encodeURIComponent("" + paymentMethod));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processComplete(_response);
        });
    }

    protected processComplete(response: AxiosResponse): Promise<PaymentRequestWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentRequestWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PaymentRequestWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentRequestWithDetailsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestsPOST(body: PaymentRequestCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentRequestWithDetailsDto> {
        let url_ = this.baseUrl + "/api/payment/requests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestsPOST(_response);
        });
    }

    protected processRequestsPOST(response: AxiosResponse): Promise<PaymentRequestWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentRequestWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PaymentRequestWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentRequestWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    requestsGET(id: string , cancelToken?: CancelToken | undefined): Promise<PaymentRequestWithDetailsDto> {
        let url_ = this.baseUrl + "/api/payment/requests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestsGET(_response);
        });
    }

    protected processRequestsGET(response: AxiosResponse): Promise<PaymentRequestWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentRequestWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PaymentRequestWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentRequestWithDetailsDto>(null as any);
    }

    /**
     * @param payload (optional) 
     * @param headers (optional) 
     * @return Success
     */
    webhook(paymentMethod: string, payload: string | undefined, headers: { [key: string]: string; } | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/payment/{paymentMethod}/webhook?";
        if (paymentMethod === undefined || paymentMethod === null)
            throw new Error("The parameter 'paymentMethod' must be defined.");
        url_ = url_.replace("{paymentMethod}", encodeURIComponent("" + paymentMethod));
        if (payload === null)
            throw new Error("The parameter 'payload' cannot be null.");
        else if (payload !== undefined)
            url_ += "payload=" + encodeURIComponent("" + payload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "headers": headers !== undefined && headers !== null ? "" + headers : "",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWebhook(_response);
        });
    }

    protected processWebhook(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    start(paymentMethod: string, body: PaymentRequestStartDto | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentRequestStartResultDto> {
        let url_ = this.baseUrl + "/api/payment/{paymentMethod}/start";
        if (paymentMethod === undefined || paymentMethod === null)
            throw new Error("The parameter 'paymentMethod' must be defined.");
        url_ = url_.replace("{paymentMethod}", encodeURIComponent("" + paymentMethod));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStart(_response);
        });
    }

    protected processStart(response: AxiosResponse): Promise<PaymentRequestStartResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentRequestStartResultDto.fromJS(resultData200);
            return Promise.resolve<PaymentRequestStartResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentRequestStartResultDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param creationDateMax (optional) 
     * @param creationDateMin (optional) 
     * @param paymentType (optional) 
     * @param status (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    paymentRequests(filter: string | undefined, creationDateMax: Date | undefined, creationDateMin: Date | undefined, paymentType: PaymentType | undefined, status: PaymentRequestState | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/payment-admin/payment-requests?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (creationDateMax === null)
            throw new Error("The parameter 'creationDateMax' cannot be null.");
        else if (creationDateMax !== undefined)
            url_ += "CreationDateMax=" + encodeURIComponent(creationDateMax ? "" + creationDateMax.toISOString() : "") + "&";
        if (creationDateMin === null)
            throw new Error("The parameter 'creationDateMin' cannot be null.");
        else if (creationDateMin !== undefined)
            url_ += "CreationDateMin=" + encodeURIComponent(creationDateMin ? "" + creationDateMin.toISOString() : "") + "&";
        if (paymentType === null)
            throw new Error("The parameter 'paymentType' cannot be null.");
        else if (paymentType !== undefined)
            url_ += "PaymentType=" + encodeURIComponent("" + paymentType) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaymentRequests(_response);
        });
    }

    protected processPaymentRequests(response: AxiosResponse): Promise<PagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    paymentRequests2(id: string , cancelToken?: CancelToken | undefined): Promise<PaymentRequestWithDetailsDto> {
        let url_ = this.baseUrl + "/api/payment-admin/payment-requests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPaymentRequests2(_response);
        });
    }

    protected processPaymentRequests2(response: AxiosResponse): Promise<PaymentRequestWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentRequestWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PaymentRequestWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentRequestWithDetailsDto>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    permissionsGET(providerName: string | undefined, providerKey: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetPermissionListResultDto> {
        let url_ = this.baseUrl + "/api/permission-management/permissions?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsGET(_response);
        });
    }

    protected processPermissionsGET(response: AxiosResponse): Promise<GetPermissionListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetPermissionListResultDto.fromJS(resultData200);
            return Promise.resolve<GetPermissionListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPermissionListResultDto>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    permissionsPUT(providerName: string | undefined, providerKey: string | undefined, body: UpdatePermissionsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/permission-management/permissions?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsPUT(_response);
        });
    }

    protected processPermissionsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    plansGET(planId: string, gateway: string , cancelToken?: CancelToken | undefined): Promise<GatewayPlanDto> {
        let url_ = this.baseUrl + "/api/payment/plans/{planId}/{gateway}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (gateway === undefined || gateway === null)
            throw new Error("The parameter 'gateway' must be defined.");
        url_ = url_.replace("{gateway}", encodeURIComponent("" + gateway));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlansGET(_response);
        });
    }

    protected processPlansGET(response: AxiosResponse): Promise<GatewayPlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GatewayPlanDto.fromJS(resultData200);
            return Promise.resolve<GatewayPlanDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GatewayPlanDto>(null as any);
    }

    /**
     * @return Success
     */
    plansAll(  cancelToken?: CancelToken | undefined): Promise<PlanDto[]> {
        let url_ = this.baseUrl + "/api/payment/plans";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlansAll(_response);
        });
    }

    protected processPlansAll(response: AxiosResponse): Promise<PlanDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlanDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PlanDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto[]>(null as any);
    }

    /**
     * @return Success
     */
    plansGET2(planId: string , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/payment/plans/{planId}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlansGET2(_response);
        });
    }

    protected processPlansGET2(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200);
            return Promise.resolve<PlanDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    many(ids: string[] | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto[]> {
        let url_ = this.baseUrl + "/api/payment/plans/many?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMany(_response);
        });
    }

    protected processMany(response: AxiosResponse): Promise<PlanDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlanDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PlanDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    plansPOST(body: PlanCreateInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/payment-admin/plans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlansPOST(_response);
        });
    }

    protected processPlansPOST(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200);
            return Promise.resolve<PlanDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    plansDELETE(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/payment-admin/plans?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlansDELETE(_response);
        });
    }

    protected processPlansDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    plansGET3(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/payment-admin/plans?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlansGET3(_response);
        });
    }

    protected processPlansGET3(response: AxiosResponse): Promise<PagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalPlansPOST(planId: string, body: GatewayPlanCreateInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/payment-admin/plans/{planId}/external-plans";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalPlansPOST(_response);
        });
    }

    protected processExternalPlansPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    externalPlansGET(planId: string, filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/payment-admin/plans/{planId}/external-plans?";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalPlansGET(_response);
        });
    }

    protected processExternalPlansGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    externalPlansDELETE(planId: string, gateway: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/payment-admin/plans/{planId}/external-plans/{gateway}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (gateway === undefined || gateway === null)
            throw new Error("The parameter 'gateway' must be defined.");
        url_ = url_.replace("{gateway}", encodeURIComponent("" + gateway));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalPlansDELETE(_response);
        });
    }

    protected processExternalPlansDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalPlansPUT(planId: string, gateway: string, body: GatewayPlanUpdateInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/payment-admin/plans/{planId}/external-plans/{gateway}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (gateway === undefined || gateway === null)
            throw new Error("The parameter 'gateway' must be defined.");
        url_ = url_.replace("{gateway}", encodeURIComponent("" + gateway));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalPlansPUT(_response);
        });
    }

    protected processExternalPlansPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    plansGET4(id: string , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/payment-admin/plans/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlansGET4(_response);
        });
    }

    protected processPlansGET4(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200);
            return Promise.resolve<PlanDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    plansPUT(id: string, body: PlanUpdateInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/payment-admin/plans/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlansPUT(_response);
        });
    }

    protected processPlansPUT(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200);
            return Promise.resolve<PlanDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    pollGET(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/poll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPollGET(_response);
        });
    }

    protected processPollGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pollPOST(body: CreatePollDto | undefined , cancelToken?: CancelToken | undefined): Promise<PollWithDetailsDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/poll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPollPOST(_response);
        });
    }

    protected processPollPOST(response: AxiosResponse): Promise<PollWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PollWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PollWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PollWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    pollGET2(id: string , cancelToken?: CancelToken | undefined): Promise<PollWithDetailsDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/poll/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPollGET2(_response);
        });
    }

    protected processPollGET2(response: AxiosResponse): Promise<PollWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PollWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PollWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PollWithDetailsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pollPUT(id: string, body: UpdatePollDto | undefined , cancelToken?: CancelToken | undefined): Promise<PollWithDetailsDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/poll/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPollPUT(_response);
        });
    }

    protected processPollPUT(response: AxiosResponse): Promise<PollWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PollWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PollWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PollWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    pollDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/poll/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPollDELETE(_response);
        });
    }

    protected processPollDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    widgets(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/poll/widgets";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWidgets(_response);
        });
    }

    protected processWidgets(response: AxiosResponse): Promise<ListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    result(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetResultDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/poll/result?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResult(_response);
        });
    }

    protected processResult(response: AxiosResponse): Promise<GetResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetResultDto.fromJS(resultData200);
            return Promise.resolve<GetResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetResultDto>(null as any);
    }

    /**
     * @param widgetName (optional) 
     * @return Success
     */
    findbywidget(widgetName: string | undefined , cancelToken?: CancelToken | undefined): Promise<PollWithDetailsDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-public/poll/findbywidget?";
        if (widgetName === null)
            throw new Error("The parameter 'widgetName' cannot be null.");
        else if (widgetName !== undefined)
            url_ += "widgetName=" + encodeURIComponent("" + widgetName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindbywidget(_response);
        });
    }

    protected processFindbywidget(response: AxiosResponse): Promise<PollWithDetailsDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PollWithDetailsDto2.fromJS(resultData200);
            return Promise.resolve<PollWithDetailsDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PollWithDetailsDto2>(null as any);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    findbycode(code: string | undefined , cancelToken?: CancelToken | undefined): Promise<PollWithDetailsDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-public/poll/findbycode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindbycode(_response);
        });
    }

    protected processFindbycode(response: AxiosResponse): Promise<PollWithDetailsDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PollWithDetailsDto2.fromJS(resultData200);
            return Promise.resolve<PollWithDetailsDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PollWithDetailsDto2>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    showresult(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetResultDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-public/poll/showresult?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShowresult(_response);
        });
    }

    protected processShowresult(response: AxiosResponse): Promise<GetResultDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetResultDto2.fromJS(resultData200);
            return Promise.resolve<GetResultDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetResultDto2>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    pollPOST2(id: string, body: SubmitPollInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-public/poll/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPollPOST2(_response);
        });
    }

    protected processPollPOST2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param tagName (optional) 
     * @return Success
     */
    all3(blogId: string, tagName: string | undefined , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/blogging/posts/{blogId}/all?";
        if (blogId === undefined || blogId === null)
            throw new Error("The parameter 'blogId' must be defined.");
        url_ = url_.replace("{blogId}", encodeURIComponent("" + blogId));
        if (tagName === null)
            throw new Error("The parameter 'tagName' cannot be null.");
        else if (tagName !== undefined)
            url_ += "tagName=" + encodeURIComponent("" + tagName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll3(_response);
        });
    }

    protected processAll3(response: AxiosResponse): Promise<ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    byTime(blogId: string , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/blogging/posts/{blogId}/all/by-time";
        if (blogId === undefined || blogId === null)
            throw new Error("The parameter 'blogId' must be defined.");
        url_ = url_.replace("{blogId}", encodeURIComponent("" + blogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByTime(_response);
        });
    }

    protected processByTime(response: AxiosResponse): Promise<ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param blogId (optional) 
     * @return Success
     */
    read(url: string, blogId: string | undefined , cancelToken?: CancelToken | undefined): Promise<PostWithDetailsDto> {
        let url_ = this.baseUrl + "/api/blogging/posts/read?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined and cannot be null.");
        else
            url_ += "Url=" + encodeURIComponent("" + url) + "&";
        if (blogId === null)
            throw new Error("The parameter 'blogId' cannot be null.");
        else if (blogId !== undefined)
            url_ += "BlogId=" + encodeURIComponent("" + blogId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRead(_response);
        });
    }

    protected processRead(response: AxiosResponse): Promise<PostWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PostWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    postsGET(id: string , cancelToken?: CancelToken | undefined): Promise<PostWithDetailsDto> {
        let url_ = this.baseUrl + "/api/blogging/posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostsGET(_response);
        });
    }

    protected processPostsGET(response: AxiosResponse): Promise<PostWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PostWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostWithDetailsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postsPUT(id: string, body: UpdatePostDto | undefined , cancelToken?: CancelToken | undefined): Promise<PostWithDetailsDto> {
        let url_ = this.baseUrl + "/api/blogging/posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostsPUT(_response);
        });
    }

    protected processPostsPUT(response: AxiosResponse): Promise<PostWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PostWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    postsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/blogging/posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostsDELETE(_response);
        });
    }

    protected processPostsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postsPOST(body: CreatePostDto | undefined , cancelToken?: CancelToken | undefined): Promise<PostWithDetailsDto> {
        let url_ = this.baseUrl + "/api/blogging/posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPostsPOST(_response);
        });
    }

    protected processPostsPOST(response: AxiosResponse): Promise<PostWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PostWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PostWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PostWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    myProfileGET(  cancelToken?: CancelToken | undefined): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/account/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMyProfileGET(_response);
        });
    }

    protected processMyProfileGET(response: AxiosResponse): Promise<ProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileDto.fromJS(resultData200);
            return Promise.resolve<ProfileDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    myProfilePUT(body: UpdateProfileDto | undefined , cancelToken?: CancelToken | undefined): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/account/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMyProfilePUT(_response);
        });
    }

    protected processMyProfilePUT(response: AxiosResponse): Promise<ProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileDto.fromJS(resultData200);
            return Promise.resolve<ProfileDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePasswordPOST(body: ChangePasswordInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/my-profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePasswordPOST(_response);
        });
    }

    protected processChangePasswordPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorEnabled(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/my-profile/two-factor-enabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorEnabled(_response);
        });
    }

    protected processTwoFactorEnabled(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param enabled (optional) 
     * @return Success
     */
    setTwoFactorEnabled(enabled: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/my-profile/set-two-factor-enabled?";
        if (enabled === null)
            throw new Error("The parameter 'enabled' cannot be null.");
        else if (enabled !== undefined)
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetTwoFactorEnabled(_response);
        });
    }

    protected processSetTwoFactorEnabled(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ratingsPUT(entityType: string, entityId: string, body: CreateUpdateRatingInput | undefined , cancelToken?: CancelToken | undefined): Promise<RatingDto> {
        let url_ = this.baseUrl + "/api/cms-kit-public/ratings/{entityType}/{entityId}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRatingsPUT(_response);
        });
    }

    protected processRatingsPUT(response: AxiosResponse): Promise<RatingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RatingDto.fromJS(resultData200);
            return Promise.resolve<RatingDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RatingDto>(null as any);
    }

    /**
     * @return Success
     */
    ratingsDELETE(entityType: string, entityId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-public/ratings/{entityType}/{entityId}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRatingsDELETE(_response);
        });
    }

    protected processRatingsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    ratingsAll(entityType: string, entityId: string , cancelToken?: CancelToken | undefined): Promise<RatingWithStarCountDto[]> {
        let url_ = this.baseUrl + "/api/cms-kit-public/ratings/{entityType}/{entityId}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRatingsAll(_response);
        });
    }

    protected processRatingsAll(response: AxiosResponse): Promise<RatingWithStarCountDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RatingWithStarCountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RatingWithStarCountDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RatingWithStarCountDto[]>(null as any);
    }

    /**
     * @return Success
     */
    reactionsGET(entityType: string, entityId: string , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-public/reactions/{entityType}/{entityId}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReactionsGET(_response);
        });
    }

    protected processReactionsGET(response: AxiosResponse): Promise<ListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    reactionsPUT(entityType: string, entityId: string, reaction: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-public/reactions/{entityType}/{entityId}/{reaction}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (reaction === undefined || reaction === null)
            throw new Error("The parameter 'reaction' must be defined.");
        url_ = url_.replace("{reaction}", encodeURIComponent("" + reaction));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReactionsPUT(_response);
        });
    }

    protected processReactionsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    reactionsDELETE(entityType: string, entityId: string, reaction: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-public/reactions/{entityType}/{entityId}/{reaction}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (reaction === undefined || reaction === null)
            throw new Error("The parameter 'reaction' must be defined.");
        url_ = url_.replace("{reaction}", encodeURIComponent("" + reaction));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReactionsDELETE(_response);
        });
    }

    protected processReactionsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    rolesGET2(id: string , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET2(_response);
        });
    }

    protected processRolesGET2(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT2(id: string, body: IdentityRoleUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPUT2(_response);
        });
    }

    protected processRolesPUT2(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @return Success
     */
    rolesDELETE2(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesDELETE2(_response);
        });
    }

    protected processRolesDELETE2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPOST(body: IdentityRoleCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPOST(_response);
        });
    }

    protected processRolesPOST(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    rolesGET3(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/roles?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET3(_response);
        });
    }

    protected processRolesGET3(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    all4(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/roles/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll4(_response);
        });
    }

    protected processAll4(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claims(id: string, body: IdentityRoleClaimDto[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaims(_response);
        });
    }

    protected processClaims(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    claimsAll(id: string , cancelToken?: CancelToken | undefined): Promise<IdentityRoleClaimDto[]> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimsAll(_response);
        });
    }

    protected processClaimsAll(response: AxiosResponse): Promise<IdentityRoleClaimDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityRoleClaimDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<IdentityRoleClaimDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleClaimDto[]>(null as any);
    }

    /**
     * @return Success
     */
    allClaimTypes(  cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto[]> {
        let url_ = this.baseUrl + "/api/identity/roles/all-claim-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAllClaimTypes(_response);
        });
    }

    protected processAllClaimTypes(response: AxiosResponse): Promise<ClaimTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ClaimTypeDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    scopesGET(id: string , cancelToken?: CancelToken | undefined): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/openiddict/scopes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesGET(_response);
        });
    }

    protected processScopesGET(response: AxiosResponse): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScopeDto.fromJS(resultData200);
            return Promise.resolve<ScopeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    scopesPUT(id: string, body: UpdateScopeInput | undefined , cancelToken?: CancelToken | undefined): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/openiddict/scopes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesPUT(_response);
        });
    }

    protected processScopesPUT(response: AxiosResponse): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScopeDto.fromJS(resultData200);
            return Promise.resolve<ScopeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    scopesGET2(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/openiddict/scopes?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesGET2(_response);
        });
    }

    protected processScopesGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    scopesPOST(body: CreateScopeInput | undefined , cancelToken?: CancelToken | undefined): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/openiddict/scopes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesPOST(_response);
        });
    }

    protected processScopesPOST(response: AxiosResponse): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScopeDto.fromJS(resultData200);
            return Promise.resolve<ScopeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    scopesDELETE(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/openiddict/scopes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesDELETE(_response);
        });
    }

    protected processScopesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    allAll(  cancelToken?: CancelToken | undefined): Promise<ScopeDto[]> {
        let url_ = this.baseUrl + "/api/openiddict/scopes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAllAll(_response);
        });
    }

    protected processAllAll(response: AxiosResponse): Promise<ScopeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScopeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ScopeDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopeDto[]>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param applicationName (optional) 
     * @param identity (optional) 
     * @param action (optional) 
     * @param userName (optional) 
     * @param clientId (optional) 
     * @param correlationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    securityLogs2(startTime: Date | undefined, endTime: Date | undefined, applicationName: string | undefined, identity: string | undefined, action: string | undefined, userName: string | undefined, clientId: string | undefined, correlationId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/security-logs?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (applicationName === null)
            throw new Error("The parameter 'applicationName' cannot be null.");
        else if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (identity === null)
            throw new Error("The parameter 'identity' cannot be null.");
        else if (identity !== undefined)
            url_ += "Identity=" + encodeURIComponent("" + identity) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "Action=" + encodeURIComponent("" + action) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (correlationId === null)
            throw new Error("The parameter 'correlationId' cannot be null.");
        else if (correlationId !== undefined)
            url_ += "CorrelationId=" + encodeURIComponent("" + correlationId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSecurityLogs2(_response);
        });
    }

    protected processSecurityLogs2(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    securityLogs3(id: string , cancelToken?: CancelToken | undefined): Promise<IdentitySecurityLogDto> {
        let url_ = this.baseUrl + "/api/identity/security-logs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSecurityLogs3(_response);
        });
    }

    protected processSecurityLogs3(response: AxiosResponse): Promise<IdentitySecurityLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentitySecurityLogDto.fromJS(resultData200);
            return Promise.resolve<IdentitySecurityLogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentitySecurityLogDto>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param applicationName (optional) 
     * @param identity (optional) 
     * @param action (optional) 
     * @param userName (optional) 
     * @param clientId (optional) 
     * @param correlationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    my(startTime: Date | undefined, endTime: Date | undefined, applicationName: string | undefined, identity: string | undefined, action: string | undefined, userName: string | undefined, clientId: string | undefined, correlationId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/security-logs/my?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (applicationName === null)
            throw new Error("The parameter 'applicationName' cannot be null.");
        else if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (identity === null)
            throw new Error("The parameter 'identity' cannot be null.");
        else if (identity !== undefined)
            url_ += "Identity=" + encodeURIComponent("" + identity) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "Action=" + encodeURIComponent("" + action) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (correlationId === null)
            throw new Error("The parameter 'correlationId' cannot be null.");
        else if (correlationId !== undefined)
            url_ += "CorrelationId=" + encodeURIComponent("" + correlationId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMy(_response);
        });
    }

    protected processMy(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    my2(id: string , cancelToken?: CancelToken | undefined): Promise<IdentitySecurityLogDto> {
        let url_ = this.baseUrl + "/api/identity/security-logs/my/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMy2(_response);
        });
    }

    protected processMy2(response: AxiosResponse): Promise<IdentitySecurityLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentitySecurityLogDto.fromJS(resultData200);
            return Promise.resolve<IdentitySecurityLogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentitySecurityLogDto>(null as any);
    }

    /**
     * @return Success
     */
    settingsGET4(  cancelToken?: CancelToken | undefined): Promise<IdentitySettingsDto> {
        let url_ = this.baseUrl + "/api/identity/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsGET4(_response);
        });
    }

    protected processSettingsGET4(response: AxiosResponse): Promise<IdentitySettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentitySettingsDto.fromJS(resultData200);
            return Promise.resolve<IdentitySettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentitySettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    settingsPUT3(body: IdentitySettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsPUT3(_response);
        });
    }

    protected processSettingsPUT3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    ldapGET(  cancelToken?: CancelToken | undefined): Promise<IdentityLdapSettingsDto> {
        let url_ = this.baseUrl + "/api/identity/settings/ldap";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLdapGET(_response);
        });
    }

    protected processLdapGET(response: AxiosResponse): Promise<IdentityLdapSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityLdapSettingsDto.fromJS(resultData200);
            return Promise.resolve<IdentityLdapSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityLdapSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ldapPUT(body: IdentityLdapSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/settings/ldap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLdapPUT(_response);
        });
    }

    protected processLdapPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    oauthGET(  cancelToken?: CancelToken | undefined): Promise<IdentityOAuthSettingsDto> {
        let url_ = this.baseUrl + "/api/identity/settings/oauth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOauthGET(_response);
        });
    }

    protected processOauthGET(response: AxiosResponse): Promise<IdentityOAuthSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityOAuthSettingsDto.fromJS(resultData200);
            return Promise.resolve<IdentityOAuthSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityOAuthSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    oauthPUT(body: IdentityOAuthSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/settings/oauth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOauthPUT(_response);
        });
    }

    protected processOauthPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendOnEnter(body: SendOnEnterSettingDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/chat/settings/send-on-enter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendOnEnter(_response);
        });
    }

    protected processSendOnEnter(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tagsPOST(body: TagCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<TagDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTagsPOST(_response);
        });
    }

    protected processTagsPOST(response: AxiosResponse): Promise<TagDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TagDto2.fromJS(resultData200);
            return Promise.resolve<TagDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDto2>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    tagsGET(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/tags?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTagsGET(_response);
        });
    }

    protected processTagsGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    tagsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTagsDELETE(_response);
        });
    }

    protected processTagsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tagsGET2(id: string , cancelToken?: CancelToken | undefined): Promise<TagDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTagsGET2(_response);
        });
    }

    protected processTagsGET2(response: AxiosResponse): Promise<TagDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TagDto2.fromJS(resultData200);
            return Promise.resolve<TagDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDto2>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tagsPUT(id: string, body: TagUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<TagDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTagsPUT(_response);
        });
    }

    protected processTagsPUT(response: AxiosResponse): Promise<TagDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TagDto2.fromJS(resultData200);
            return Promise.resolve<TagDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDto2>(null as any);
    }

    /**
     * @return Success
     */
    tagDefinitions(  cancelToken?: CancelToken | undefined): Promise<TagDefinitionDto[]> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/tags/tag-definitions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTagDefinitions(_response);
        });
    }

    protected processTagDefinitions(response: AxiosResponse): Promise<TagDefinitionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TagDefinitionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TagDefinitionDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDefinitionDto[]>(null as any);
    }

    /**
     * @return Success
     */
    tagsAll(entityType: string, entityId: string , cancelToken?: CancelToken | undefined): Promise<TagDto2[]> {
        let url_ = this.baseUrl + "/api/cms-kit-public/tags/{entityType}/{entityId}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTagsAll(_response);
        });
    }

    protected processTagsAll(response: AxiosResponse): Promise<TagDto2[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TagDto2.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TagDto2[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDto2[]>(null as any);
    }

    /**
     * @param resultCount (optional) 
     * @param minimumPostCount (optional) 
     * @return Success
     */
    popular(blogId: string, resultCount: number | undefined, minimumPostCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<TagDto[]> {
        let url_ = this.baseUrl + "/api/blogging/tags/popular/{blogId}?";
        if (blogId === undefined || blogId === null)
            throw new Error("The parameter 'blogId' must be defined.");
        url_ = url_.replace("{blogId}", encodeURIComponent("" + blogId));
        if (resultCount === null)
            throw new Error("The parameter 'resultCount' cannot be null.");
        else if (resultCount !== undefined)
            url_ += "ResultCount=" + encodeURIComponent("" + resultCount) + "&";
        if (minimumPostCount === null)
            throw new Error("The parameter 'minimumPostCount' cannot be null.");
        else if (minimumPostCount !== undefined)
            url_ += "MinimumPostCount=" + encodeURIComponent("" + minimumPostCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPopular(_response);
        });
    }

    protected processPopular(response: AxiosResponse): Promise<TagDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TagDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TagDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagDto[]>(null as any);
    }

    /**
     * @return Success
     */
    tenantsGET(id: string , cancelToken?: CancelToken | undefined): Promise<SaasTenantDto> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsGET(_response);
        });
    }

    protected processTenantsGET(response: AxiosResponse): Promise<SaasTenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tenantsPUT(id: string, body: SaasTenantUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<SaasTenantDto> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsPUT(_response);
        });
    }

    protected processTenantsPUT(response: AxiosResponse): Promise<SaasTenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantDto>(null as any);
    }

    /**
     * @return Success
     */
    tenantsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsDELETE(_response);
        });
    }

    protected processTenantsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param getEditionNames (optional) 
     * @param editionId (optional) 
     * @param expirationDateMin (optional) 
     * @param expirationDateMax (optional) 
     * @param activationState (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    tenantsGET2(filter: string | undefined, getEditionNames: boolean | undefined, editionId: string | undefined, expirationDateMin: Date | undefined, expirationDateMax: Date | undefined, activationState: TenantActivationState | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/saas/tenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (getEditionNames === null)
            throw new Error("The parameter 'getEditionNames' cannot be null.");
        else if (getEditionNames !== undefined)
            url_ += "GetEditionNames=" + encodeURIComponent("" + getEditionNames) + "&";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (expirationDateMin === null)
            throw new Error("The parameter 'expirationDateMin' cannot be null.");
        else if (expirationDateMin !== undefined)
            url_ += "ExpirationDateMin=" + encodeURIComponent(expirationDateMin ? "" + expirationDateMin.toISOString() : "") + "&";
        if (expirationDateMax === null)
            throw new Error("The parameter 'expirationDateMax' cannot be null.");
        else if (expirationDateMax !== undefined)
            url_ += "ExpirationDateMax=" + encodeURIComponent(expirationDateMax ? "" + expirationDateMax.toISOString() : "") + "&";
        if (activationState === null)
            throw new Error("The parameter 'activationState' cannot be null.");
        else if (activationState !== undefined)
            url_ += "ActivationState=" + encodeURIComponent("" + activationState) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsGET2(_response);
        });
    }

    protected processTenantsGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tenantsPOST(body: SaasTenantCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<SaasTenantDto> {
        let url_ = this.baseUrl + "/api/saas/tenants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsPOST(_response);
        });
    }

    protected processTenantsPOST(response: AxiosResponse): Promise<SaasTenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantDto>(null as any);
    }

    /**
     * @return Success
     */
    databases(  cancelToken?: CancelToken | undefined): Promise<SaasTenantDatabasesDto> {
        let url_ = this.baseUrl + "/api/saas/tenants/databases";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDatabases(_response);
        });
    }

    protected processDatabases(response: AxiosResponse): Promise<SaasTenantDatabasesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantDatabasesDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantDatabasesDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantDatabasesDto>(null as any);
    }

    /**
     * @return Success
     */
    connectionStringsGET(id: string , cancelToken?: CancelToken | undefined): Promise<SaasTenantConnectionStringsDto> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}/connection-strings";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnectionStringsGET(_response);
        });
    }

    protected processConnectionStringsGET(response: AxiosResponse): Promise<SaasTenantConnectionStringsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantConnectionStringsDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantConnectionStringsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantConnectionStringsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    connectionStringsPUT(id: string, body: SaasTenantConnectionStringsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}/connection-strings";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnectionStringsPUT(_response);
        });
    }

    protected processConnectionStringsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    applyDatabaseMigrations(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}/apply-database-migrations";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplyDatabaseMigrations(_response);
        });
    }

    protected processApplyDatabaseMigrations(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    editionsAll(  cancelToken?: CancelToken | undefined): Promise<EditionLookupDto[]> {
        let url_ = this.baseUrl + "/api/saas/tenants/lookup/editions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsAll(_response);
        });
    }

    protected processEditionsAll(response: AxiosResponse): Promise<EditionLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EditionLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<EditionLookupDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EditionLookupDto[]>(null as any);
    }

    /**
     * @param connectionString (optional) 
     * @return Success
     */
    checkConnectionString(connectionString: string | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/saas/tenants/check-connection-string?";
        if (connectionString === null)
            throw new Error("The parameter 'connectionString' cannot be null.");
        else if (connectionString !== undefined)
            url_ += "connectionString=" + encodeURIComponent("" + connectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckConnectionString(_response);
        });
    }

    protected processCheckConnectionString(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPassword(id: string, body: SaasTenantSetPasswordDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}/set-password";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetPassword(_response);
        });
    }

    protected processSetPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param cultureName (optional) 
     * @return Success
     */
    templateContentsGET(templateName: string, cultureName: string | undefined , cancelToken?: CancelToken | undefined): Promise<TextTemplateContentDto> {
        let url_ = this.baseUrl + "/api/text-template-management/template-contents?";
        if (templateName === undefined || templateName === null)
            throw new Error("The parameter 'templateName' must be defined and cannot be null.");
        else
            url_ += "TemplateName=" + encodeURIComponent("" + templateName) + "&";
        if (cultureName === null)
            throw new Error("The parameter 'cultureName' cannot be null.");
        else if (cultureName !== undefined)
            url_ += "CultureName=" + encodeURIComponent("" + cultureName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateContentsGET(_response);
        });
    }

    protected processTemplateContentsGET(response: AxiosResponse): Promise<TextTemplateContentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TextTemplateContentDto.fromJS(resultData200);
            return Promise.resolve<TextTemplateContentDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TextTemplateContentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    templateContentsPUT(body: UpdateTemplateContentInput | undefined , cancelToken?: CancelToken | undefined): Promise<TextTemplateContentDto> {
        let url_ = this.baseUrl + "/api/text-template-management/template-contents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateContentsPUT(_response);
        });
    }

    protected processTemplateContentsPUT(response: AxiosResponse): Promise<TextTemplateContentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TextTemplateContentDto.fromJS(resultData200);
            return Promise.resolve<TextTemplateContentDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TextTemplateContentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    restoreToDefault(body: RestoreTemplateContentInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/text-template-management/template-contents/restore-to-default";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestoreToDefault(_response);
        });
    }

    protected processRestoreToDefault(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    templateDefinitions(filterText: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/text-template-management/template-definitions?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateDefinitions(_response);
        });
    }

    protected processTemplateDefinitions(response: AxiosResponse): Promise<PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    templateDefinitions2(name: string , cancelToken?: CancelToken | undefined): Promise<TemplateDefinitionDto> {
        let url_ = this.baseUrl + "/api/text-template-management/template-definitions/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateDefinitions2(_response);
        });
    }

    protected processTemplateDefinitions2(response: AxiosResponse): Promise<TemplateDefinitionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateDefinitionDto.fromJS(resultData200);
            return Promise.resolve<TemplateDefinitionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateDefinitionDto>(null as any);
    }

    /**
     * @param shortenedUrlFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    urlShortingGET(shortenedUrlFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/url-shorting?";
        if (shortenedUrlFilter === null)
            throw new Error("The parameter 'shortenedUrlFilter' cannot be null.");
        else if (shortenedUrlFilter !== undefined)
            url_ += "ShortenedUrlFilter=" + encodeURIComponent("" + shortenedUrlFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlShortingGET(_response);
        });
    }

    protected processUrlShortingGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    urlShortingPOST(body: CreateShortenedUrlDto | undefined , cancelToken?: CancelToken | undefined): Promise<ShortenedUrlDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/url-shorting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlShortingPOST(_response);
        });
    }

    protected processUrlShortingPOST(response: AxiosResponse): Promise<ShortenedUrlDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShortenedUrlDto.fromJS(resultData200);
            return Promise.resolve<ShortenedUrlDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShortenedUrlDto>(null as any);
    }

    /**
     * @return Success
     */
    urlShortingGET2(id: string , cancelToken?: CancelToken | undefined): Promise<ShortenedUrlDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/url-shorting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlShortingGET2(_response);
        });
    }

    protected processUrlShortingGET2(response: AxiosResponse): Promise<ShortenedUrlDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShortenedUrlDto.fromJS(resultData200);
            return Promise.resolve<ShortenedUrlDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShortenedUrlDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    urlShortingPUT(id: string, body: UpdateShortenedUrlDto | undefined , cancelToken?: CancelToken | undefined): Promise<ShortenedUrlDto> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/url-shorting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlShortingPUT(_response);
        });
    }

    protected processUrlShortingPUT(response: AxiosResponse): Promise<ShortenedUrlDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShortenedUrlDto.fromJS(resultData200);
            return Promise.resolve<ShortenedUrlDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShortenedUrlDto>(null as any);
    }

    /**
     * @return Success
     */
    urlShortingDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms-kit-admin/url-shorting/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlShortingDELETE(_response);
        });
    }

    protected processUrlShortingDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param source (optional) 
     * @return Success
     */
    urlShortingGET3(source: string | undefined , cancelToken?: CancelToken | undefined): Promise<ShortenedUrlDto2> {
        let url_ = this.baseUrl + "/api/cms-kit-public/url-shorting?";
        if (source === null)
            throw new Error("The parameter 'source' cannot be null.");
        else if (source !== undefined)
            url_ += "source=" + encodeURIComponent("" + source) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUrlShortingGET3(_response);
        });
    }

    protected processUrlShortingGET3(response: AxiosResponse): Promise<ShortenedUrlDto2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShortenedUrlDto2.fromJS(resultData200);
            return Promise.resolve<ShortenedUrlDto2>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShortenedUrlDto2>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    link(body: LinkUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/link-user/link";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLink(_response);
        });
    }

    protected processLink(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlink(body: UnLinkUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/link-user/unlink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnlink(_response);
        });
    }

    protected processUnlink(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isLinked(body: IsLinkedInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/link-user/is-linked";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsLinked(_response);
        });
    }

    protected processIsLinked(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    generateLinkToken(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/account/link-user/generate-link-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerateLinkToken(_response);
        });
    }

    protected processGenerateLinkToken(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyLinkToken(body: VerifyLinkTokenInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/link-user/verify-link-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyLinkToken(_response);
        });
    }

    protected processVerifyLinkToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    generateLinkLoginToken(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/account/link-user/generate-link-login-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerateLinkLoginToken(_response);
        });
    }

    protected processGenerateLinkLoginToken(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyLinkLoginToken(body: VerifyLinkLoginTokenInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/link-user/verify-link-login-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyLinkLoginToken(_response);
        });
    }

    protected processVerifyLinkLoginToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    linkUser(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/account/link-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLinkUser(_response);
        });
    }

    protected processLinkUser(response: AxiosResponse): Promise<ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    usersGET(id: string , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersGET(_response);
        });
    }

    protected processUsersGET(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: string, body: IdentityUserUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    usersDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersDELETE(_response);
        });
    }

    protected processUsersDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @param userName (optional) 
     * @param phoneNumber (optional) 
     * @param emailAddress (optional) 
     * @param isLockedOut (optional) 
     * @param notActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    usersGET2(filter: string | undefined, roleId: string | undefined, organizationUnitId: string | undefined, userName: string | undefined, phoneNumber: string | undefined, emailAddress: string | undefined, isLockedOut: boolean | undefined, notActive: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "EmailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (isLockedOut === null)
            throw new Error("The parameter 'isLockedOut' cannot be null.");
        else if (isLockedOut !== undefined)
            url_ += "IsLockedOut=" + encodeURIComponent("" + isLockedOut) + "&";
        if (notActive === null)
            throw new Error("The parameter 'notActive' cannot be null.");
        else if (notActive !== undefined)
            url_ += "NotActive=" + encodeURIComponent("" + notActive) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersGET2(_response);
        });
    }

    protected processUsersGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body: IdentityUserCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersPOST(_response);
        });
    }

    protected processUsersPOST(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    rolesGET4(id: string , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET4(_response);
        });
    }

    protected processRolesGET4(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT3(id: string, body: IdentityUserUpdateRolesDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPUT3(_response);
        });
    }

    protected processRolesPUT3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    assignableRoles(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/assignable-roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAssignableRoles(_response);
        });
    }

    protected processAssignableRoles(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    availableOrganizationUnits(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/available-organization-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAvailableOrganizationUnits(_response);
        });
    }

    protected processAvailableOrganizationUnits(response: AxiosResponse): Promise<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    allClaimTypes2(  cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/all-claim-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAllClaimTypes2(_response);
        });
    }

    protected processAllClaimTypes2(response: AxiosResponse): Promise<ClaimTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ClaimTypeDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    claimsAll2(id: string , cancelToken?: CancelToken | undefined): Promise<IdentityUserClaimDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimsAll2(_response);
        });
    }

    protected processClaimsAll2(response: AxiosResponse): Promise<IdentityUserClaimDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityUserClaimDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<IdentityUserClaimDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserClaimDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claims2(id: string, body: IdentityUserClaimDto[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaims2(_response);
        });
    }

    protected processClaims2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    organizationUnitsAll(id: string , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/organization-units";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsAll(_response);
        });
    }

    protected processOrganizationUnitsAll(response: AxiosResponse): Promise<OrganizationUnitDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrganizationUnitDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDto[]>(null as any);
    }

    /**
     * @return Success
     */
    lock(id: string, lockoutEnd: Date , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/lock/{lockoutEnd}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lockoutEnd === undefined || lockoutEnd === null)
            throw new Error("The parameter 'lockoutEnd' must be defined.");
        url_ = url_.replace("{lockoutEnd}", encodeURIComponent(lockoutEnd ? "" + lockoutEnd.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLock(_response);
        });
    }

    protected processLock(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    unlock(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/unlock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnlock(_response);
        });
    }

    protected processUnlock(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    byUsername(username: string , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-username/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByUsername(_response);
        });
    }

    protected processByUsername(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    byEmail(email: string , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByEmail(_response);
        });
    }

    protected processByEmail(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorEnabled2(id: string , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/two-factor-enabled";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorEnabled2(_response);
        });
    }

    protected processTwoFactorEnabled2(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorPUT2(id: string, enabled: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/two-factor/{enabled}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined.");
        url_ = url_.replace("{enabled}", encodeURIComponent("" + enabled));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorPUT2(_response);
        });
    }

    protected processTwoFactorPUT2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePasswordPUT(id: string, body: IdentityUserUpdatePasswordInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/change-password";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePasswordPUT(_response);
        });
    }

    protected processChangePasswordPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    rolesAll(  cancelToken?: CancelToken | undefined): Promise<IdentityRoleLookupDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesAll(_response);
        });
    }

    protected processRolesAll(response: AxiosResponse): Promise<IdentityRoleLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityRoleLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<IdentityRoleLookupDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    organizationUnitsAll2(  cancelToken?: CancelToken | undefined): Promise<OrganizationUnitLookupDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/organization-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsAll2(_response);
        });
    }

    protected processOrganizationUnitsAll2(response: AxiosResponse): Promise<OrganizationUnitLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUnitLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrganizationUnitLookupDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    externalLoginProviders(  cancelToken?: CancelToken | undefined): Promise<ExternalLoginProviderDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/external-login-Providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalLoginProviders(_response);
        });
    }

    protected processExternalLoginProviders(response: AxiosResponse): Promise<ExternalLoginProviderDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ExternalLoginProviderDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalLoginProviderDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importExternalUser(body: ImportExternalUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/import-external-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportExternalUser(_response);
        });
    }

    protected processImportExternalUser(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    lookup(id: string , cancelToken?: CancelToken | undefined): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLookup(_response);
        });
    }

    protected processLookup(response: AxiosResponse): Promise<UserData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserData.fromJS(resultData200);
            return Promise.resolve<UserData>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserData>(null as any);
    }

    /**
     * @return Success
     */
    byUsername2(userName: string , cancelToken?: CancelToken | undefined): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/by-username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByUsername2(_response);
        });
    }

    protected processByUsername2(response: AxiosResponse): Promise<UserData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserData.fromJS(resultData200);
            return Promise.resolve<UserData>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserData>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    search(sorting: string | undefined, filter: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/search?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    count(filter: string | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/count?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCount(_response);
        });
    }

    protected processCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export enum HttpStatusCode {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export class AccountExternalProviderSettingsDto implements IAccountExternalProviderSettingsDto {
    settings?: ExternalProviderSettings[] | undefined;

    constructor(data?: IAccountExternalProviderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ExternalProviderSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountExternalProviderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountExternalProviderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAccountExternalProviderSettingsDto {
    settings?: ExternalProviderSettings[] | undefined;
}

export class AccountRecaptchaSettingsDto implements IAccountRecaptchaSettingsDto {
    useCaptchaOnLogin?: boolean;
    useCaptchaOnRegistration?: boolean;
    verifyBaseUrl?: string | undefined;
    siteKey?: string | undefined;
    siteSecret?: string | undefined;
    version?: number;
    score?: number;

    constructor(data?: IAccountRecaptchaSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.verifyBaseUrl = _data["verifyBaseUrl"];
            this.siteKey = _data["siteKey"];
            this.siteSecret = _data["siteSecret"];
            this.version = _data["version"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): AccountRecaptchaSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountRecaptchaSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["verifyBaseUrl"] = this.verifyBaseUrl;
        data["siteKey"] = this.siteKey;
        data["siteSecret"] = this.siteSecret;
        data["version"] = this.version;
        data["score"] = this.score;
        return data;
    }
}

export interface IAccountRecaptchaSettingsDto {
    useCaptchaOnLogin?: boolean;
    useCaptchaOnRegistration?: boolean;
    verifyBaseUrl?: string | undefined;
    siteKey?: string | undefined;
    siteSecret?: string | undefined;
    version?: number;
    score?: number;
}

export class AccountSettingsDto implements IAccountSettingsDto {
    isSelfRegistrationEnabled?: boolean;
    enableLocalLogin?: boolean;

    constructor(data?: IAccountSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSelfRegistrationEnabled = _data["isSelfRegistrationEnabled"];
            this.enableLocalLogin = _data["enableLocalLogin"];
        }
    }

    static fromJS(data: any): AccountSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSelfRegistrationEnabled"] = this.isSelfRegistrationEnabled;
        data["enableLocalLogin"] = this.enableLocalLogin;
        return data;
    }
}

export interface IAccountSettingsDto {
    isSelfRegistrationEnabled?: boolean;
    enableLocalLogin?: boolean;
}

export class AccountTwoFactorSettingsDto implements IAccountTwoFactorSettingsDto {
    twoFactorBehaviour?: IdentityProTwoFactorBehaviour;
    isRememberBrowserEnabled?: boolean;
    usersCanChange?: boolean;

    constructor(data?: IAccountTwoFactorSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twoFactorBehaviour = _data["twoFactorBehaviour"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.usersCanChange = _data["usersCanChange"];
        }
    }

    static fromJS(data: any): AccountTwoFactorSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTwoFactorSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twoFactorBehaviour"] = this.twoFactorBehaviour;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["usersCanChange"] = this.usersCanChange;
        return data;
    }
}

export interface IAccountTwoFactorSettingsDto {
    twoFactorBehaviour?: IdentityProTwoFactorBehaviour;
    isRememberBrowserEnabled?: boolean;
    usersCanChange?: boolean;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword?: string | undefined;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword?: string | undefined;
    newPassword: string;
}

export class ConfirmEmailInput implements IConfirmEmailInput {
    userId!: string;
    token!: string;

    constructor(data?: IConfirmEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data;
    }
}

export interface IConfirmEmailInput {
    userId: string;
    token: string;
}

export class ConfirmPhoneNumberInput implements IConfirmPhoneNumberInput {
    userId!: string;
    token!: string;

    constructor(data?: IConfirmPhoneNumberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmPhoneNumberInput {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPhoneNumberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data;
    }
}

export interface IConfirmPhoneNumberInput {
    userId: string;
    token: string;
}

export class ExternalProviderDto implements IExternalProviderDto {
    providers?: ExternalProviderItemDto[] | undefined;

    constructor(data?: IExternalProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providers"])) {
                this.providers = [] as any;
                for (let item of _data["providers"])
                    this.providers!.push(ExternalProviderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providers)) {
            data["providers"] = [];
            for (let item of this.providers)
                data["providers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderDto {
    providers?: ExternalProviderItemDto[] | undefined;
}

export class ExternalProviderItemDto implements IExternalProviderItemDto {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;

    constructor(data?: IExternalProviderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderItemDto {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
}

export class ExternalProviderItemWithSecretDto implements IExternalProviderItemWithSecretDto {
    success?: boolean;
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;

    constructor(data?: IExternalProviderItemWithSecretDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.name = _data["name"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
            if (Array.isArray(_data["secretProperties"])) {
                this.secretProperties = [] as any;
                for (let item of _data["secretProperties"])
                    this.secretProperties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderItemWithSecretDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderItemWithSecretDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.secretProperties)) {
            data["secretProperties"] = [];
            for (let item of this.secretProperties)
                data["secretProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderItemWithSecretDto {
    success?: boolean;
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;
}

export class ExternalProviderSettings implements IExternalProviderSettings {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;

    constructor(data?: IExternalProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
            if (Array.isArray(_data["secretProperties"])) {
                this.secretProperties = [] as any;
                for (let item of _data["secretProperties"])
                    this.secretProperties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.secretProperties)) {
            data["secretProperties"] = [];
            for (let item of this.secretProperties)
                data["secretProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderSettings {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;
}

export class ExternalProviderSettingsProperty implements IExternalProviderSettingsProperty {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IExternalProviderSettingsProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExternalProviderSettingsProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderSettingsProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IExternalProviderSettingsProperty {
    name?: string | undefined;
    value?: string | undefined;
}

export class IdentityUserConfirmationStateDto implements IIdentityUserConfirmationStateDto {
    emailConfirmed?: boolean;
    phoneNumberConfirmed?: boolean;

    constructor(data?: IIdentityUserConfirmationStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
        }
    }

    static fromJS(data: any): IdentityUserConfirmationStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserConfirmationStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        return data;
    }
}

export interface IIdentityUserConfirmationStateDto {
    emailConfirmed?: boolean;
    phoneNumberConfirmed?: boolean;
}

export class IsLinkedInput implements IIsLinkedInput {
    userId?: string;
    tenantId?: string | undefined;

    constructor(data?: IIsLinkedInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsLinkedInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsLinkedInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IIsLinkedInput {
    userId?: string;
    tenantId?: string | undefined;
}

export class LinkUserDto implements ILinkUserDto {
    targetUserId?: string;
    targetUserName?: string | undefined;
    targetTenantId?: string | undefined;
    targetTenantName?: string | undefined;
    directlyLinked?: boolean;

    constructor(data?: ILinkUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.targetUserName = _data["targetUserName"];
            this.targetTenantId = _data["targetTenantId"];
            this.targetTenantName = _data["targetTenantName"];
            this.directlyLinked = _data["directlyLinked"];
        }
    }

    static fromJS(data: any): LinkUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["targetUserName"] = this.targetUserName;
        data["targetTenantId"] = this.targetTenantId;
        data["targetTenantName"] = this.targetTenantName;
        data["directlyLinked"] = this.directlyLinked;
        return data;
    }
}

export interface ILinkUserDto {
    targetUserId?: string;
    targetUserName?: string | undefined;
    targetTenantId?: string | undefined;
    targetTenantName?: string | undefined;
    directlyLinked?: boolean;
}

export class LinkUserInput implements ILinkUserInput {
    userId?: string;
    tenantId?: string | undefined;
    token!: string;

    constructor(data?: ILinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): LinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["token"] = this.token;
        return data;
    }
}

export interface ILinkUserInput {
    userId?: string;
    tenantId?: string | undefined;
    token: string;
}

export class ProfileDto implements IProfileDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    name?: string | undefined;
    surname?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    isExternal?: boolean;
    hasPassword?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.isExternal = _data["isExternal"];
            this.hasPassword = _data["hasPassword"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["isExternal"] = this.isExternal;
        data["hasPassword"] = this.hasPassword;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IProfileDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    name?: string | undefined;
    surname?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    isExternal?: boolean;
    hasPassword?: boolean;
    concurrencyStamp?: string | undefined;
}

export class ProfilePictureSourceDto implements IProfilePictureSourceDto {
    type?: ProfilePictureType;
    source?: string | undefined;
    fileContent?: string | undefined;

    constructor(data?: IProfilePictureSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.source = _data["source"];
            this.fileContent = _data["fileContent"];
        }
    }

    static fromJS(data: any): ProfilePictureSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePictureSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["source"] = this.source;
        data["fileContent"] = this.fileContent;
        return data;
    }
}

export interface IProfilePictureSourceDto {
    type?: ProfilePictureType;
    source?: string | undefined;
    fileContent?: string | undefined;
}

export enum ProfilePictureType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class AbpLoginResult implements IAbpLoginResult {
    result?: LoginResultType;
    readonly description?: string | undefined;

    constructor(data?: IAbpLoginResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            (<any>this).description = _data["description"];
        }
    }

    static fromJS(data: any): AbpLoginResult {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLoginResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["description"] = this.description;
        return data;
    }
}

export interface IAbpLoginResult {
    result?: LoginResultType;
    description?: string | undefined;
}

export class LinkUserLoginInfo implements ILinkUserLoginInfo {
    linkUserId!: string;
    linkTenantId?: string | undefined;

    constructor(data?: ILinkUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkUserId = _data["linkUserId"];
            this.linkTenantId = _data["linkTenantId"];
        }
    }

    static fromJS(data: any): LinkUserLoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LinkUserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkUserId"] = this.linkUserId;
        data["linkTenantId"] = this.linkTenantId;
        return data;
    }
}

export interface ILinkUserLoginInfo {
    linkUserId: string;
    linkTenantId?: string | undefined;
}

export enum LoginResultType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class UserLoginInfo implements IUserLoginInfo {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberMe?: boolean;
    tenanId?: string | undefined;

    constructor(data?: IUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
            this.tenanId = _data["tenanId"];
        }
    }

    static fromJS(data: any): UserLoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        data["tenanId"] = this.tenanId;
        return data;
    }
}

export interface IUserLoginInfo {
    userNameOrEmailAddress: string;
    password: string;
    rememberMe?: boolean;
    tenanId?: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName!: string;
    emailAddress!: string;
    password!: string;
    appName!: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;
    captchaResponse?: string | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.appName = _data["appName"];
            this.returnUrl = _data["returnUrl"];
            this.returnUrlHash = _data["returnUrlHash"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["appName"] = this.appName;
        data["returnUrl"] = this.returnUrl;
        data["returnUrlHash"] = this.returnUrlHash;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IRegisterDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName: string;
    emailAddress: string;
    password: string;
    appName: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;
    captchaResponse?: string | undefined;
}

export class ResetPasswordDto implements IResetPasswordDto {
    userId?: string;
    resetToken!: string;
    password!: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetToken = _data["resetToken"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetToken"] = this.resetToken;
        data["password"] = this.password;
        return data;
    }
}

export interface IResetPasswordDto {
    userId?: string;
    resetToken: string;
    password: string;
}

export class SendEmailConfirmationTokenDto implements ISendEmailConfirmationTokenDto {
    appName!: string;
    userId!: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;

    constructor(data?: ISendEmailConfirmationTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appName = _data["appName"];
            this.userId = _data["userId"];
            this.returnUrl = _data["returnUrl"];
            this.returnUrlHash = _data["returnUrlHash"];
        }
    }

    static fromJS(data: any): SendEmailConfirmationTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailConfirmationTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName;
        data["userId"] = this.userId;
        data["returnUrl"] = this.returnUrl;
        data["returnUrlHash"] = this.returnUrlHash;
        return data;
    }
}

export interface ISendEmailConfirmationTokenDto {
    appName: string;
    userId: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;
}

export class SendPasswordResetCodeDto implements ISendPasswordResetCodeDto {
    email!: string;
    appName!: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;

    constructor(data?: ISendPasswordResetCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.appName = _data["appName"];
            this.returnUrl = _data["returnUrl"];
            this.returnUrlHash = _data["returnUrlHash"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["appName"] = this.appName;
        data["returnUrl"] = this.returnUrl;
        data["returnUrlHash"] = this.returnUrlHash;
        return data;
    }
}

export interface ISendPasswordResetCodeDto {
    email: string;
    appName: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;
}

export class SendPhoneNumberConfirmationTokenDto implements ISendPhoneNumberConfirmationTokenDto {
    userId!: string;
    phoneNumber?: string | undefined;

    constructor(data?: ISendPhoneNumberConfirmationTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendPhoneNumberConfirmationTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendPhoneNumberConfirmationTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ISendPhoneNumberConfirmationTokenDto {
    userId: string;
    phoneNumber?: string | undefined;
}

export class SendTwoFactorCodeInput implements ISendTwoFactorCodeInput {
    userId!: string;
    provider!: string;
    token!: string;

    constructor(data?: ISendTwoFactorCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.provider = _data["provider"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): SendTwoFactorCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        data["token"] = this.token;
        return data;
    }
}

export interface ISendTwoFactorCodeInput {
    userId: string;
    provider: string;
    token: string;
}

export class UnLinkUserInput implements IUnLinkUserInput {
    userId?: string;
    tenantId?: string | undefined;

    constructor(data?: IUnLinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnLinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnLinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IUnLinkUserInput {
    userId?: string;
    tenantId?: string | undefined;
}

export class UpdateExternalProviderDto implements IUpdateExternalProviderDto {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;

    constructor(data?: IUpdateExternalProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
            if (Array.isArray(_data["secretProperties"])) {
                this.secretProperties = [] as any;
                for (let item of _data["secretProperties"])
                    this.secretProperties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateExternalProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExternalProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.secretProperties)) {
            data["secretProperties"] = [];
            for (let item of this.secretProperties)
                data["secretProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateExternalProviderDto {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;
}

export class UpdateProfileDto implements IUpdateProfileDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName!: string;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    phoneNumber?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phoneNumber = _data["phoneNumber"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateProfileDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName: string;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    phoneNumber?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class VerifyEmailConfirmationTokenInput implements IVerifyEmailConfirmationTokenInput {
    userId!: string;
    token!: string;

    constructor(data?: IVerifyEmailConfirmationTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyEmailConfirmationTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyEmailConfirmationTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data;
    }
}

export interface IVerifyEmailConfirmationTokenInput {
    userId: string;
    token: string;
}

export class VerifyLinkLoginTokenInput implements IVerifyLinkLoginTokenInput {
    userId!: string;
    tenantId?: string | undefined;
    token!: string;

    constructor(data?: IVerifyLinkLoginTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyLinkLoginTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyLinkLoginTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["token"] = this.token;
        return data;
    }
}

export interface IVerifyLinkLoginTokenInput {
    userId: string;
    tenantId?: string | undefined;
    token: string;
}

export class VerifyLinkTokenInput implements IVerifyLinkTokenInput {
    userId!: string;
    tenantId?: string | undefined;
    token!: string;

    constructor(data?: IVerifyLinkTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyLinkTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyLinkTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["token"] = this.token;
        return data;
    }
}

export interface IVerifyLinkTokenInput {
    userId: string;
    tenantId?: string | undefined;
    token: string;
}

export class VerifyPasswordResetTokenInput implements IVerifyPasswordResetTokenInput {
    userId?: string;
    resetToken!: string;

    constructor(data?: IVerifyPasswordResetTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetToken = _data["resetToken"];
        }
    }

    static fromJS(data: any): VerifyPasswordResetTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyPasswordResetTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetToken"] = this.resetToken;
        return data;
    }
}

export interface IVerifyPasswordResetTokenInput {
    userId?: string;
    resetToken: string;
}

export class ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LinkUserDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LinkUserDto[] | undefined;
}

export class ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | undefined;
}

export class ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: OrganizationUnitWithDetailsDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitWithDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: OrganizationUnitWithDetailsDto[] | undefined;
}

export class ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageDto[] | undefined;
}

export class ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: UserData[] | undefined;

    constructor(data?: IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: UserData[] | undefined;
}

export class ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: BlogDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfBlogDtoAndSharedAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: BlogDto[] | undefined;
}

export class ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PostWithDetailsDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PostWithDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfPostWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PostWithDetailsDto[] | undefined;
}

export class ListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PollWidgetDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PollWidgetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfPollWidgetDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PollWidgetDto[] | undefined;
}

export class ListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: MenuItemDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MenuItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfMenuItemDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: MenuItemDto[] | undefined;
}

export class ListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: CommentWithDetailsDto2[] | undefined;

    constructor(data?: IListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CommentWithDetailsDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfCommentWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: CommentWithDetailsDto2[] | undefined;
}

export class ListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ReactionWithSelectionDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReactionWithSelectionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfReactionWithSelectionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ReactionWithSelectionDto[] | undefined;
}

export class ListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: DirectoryDescriptorInfoDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DirectoryDescriptorInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfDirectoryDescriptorInfoDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: DirectoryDescriptorInfoDto[] | undefined;
}

export class ListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FileDescriptorDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FileDescriptorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfFileDescriptorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FileDescriptorDto[] | undefined;
}

export class PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: AuditLogDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: AuditLogDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: EntityChangeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: EntityChangeDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: GdprRequestDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GdprRequestDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: GdprRequestDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ClaimTypeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClaimTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ClaimTypeDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentitySecurityLogDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentitySecurityLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentitySecurityLogDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityUserDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityUserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityUserDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: OrganizationUnitWithDetailsDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitWithDetailsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: OrganizationUnitWithDetailsDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageTextDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageTextDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ApplicationDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ApplicationDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ScopeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ScopeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ScopeDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: TemplateDefinitionDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateDefinitionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: TemplateDefinitionDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: BlogDto2[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlogDto2.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfBlogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: BlogDto2[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: BlogPostListDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlogPostListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfBlogPostListDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: BlogPostListDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: CommentWithAuthorDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CommentWithAuthorDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfCommentWithAuthorDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: CommentWithAuthorDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PageLookupDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PageLookupDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfPageLookupDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PageLookupDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: NewsletterRecordDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NewsletterRecordDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfNewsletterRecordDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: NewsletterRecordDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PageDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfPageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PageDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PollDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PollDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfPollDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PollDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ShortenedUrlDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShortenedUrlDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfShortenedUrlDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ShortenedUrlDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: BlogPostCommonDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlogPostCommonDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfBlogPostCommonDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: BlogPostCommonDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: TagDto2[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto2.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfTagDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: TagDto2[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: CmsUserDto3[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CmsUserDto3.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfCmsUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: CmsUserDto3[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: DirectoryContentDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DirectoryContentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfDirectoryContentDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: DirectoryContentDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FormDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FormDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfFormDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FormDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FormResponseDetailedDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FormResponseDetailedDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfFormResponseDetailedDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FormResponseDetailedDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FormResponseDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FormResponseDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfFormResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FormResponseDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FormWithResponseDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FormWithResponseDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfFormWithResponseDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: FormWithResponseDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: GatewayPlanDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GatewayPlanDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfGatewayPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: GatewayPlanDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PlanDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PlanDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfPlanDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PlanDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PaymentRequestWithDetailsDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PaymentRequestWithDetailsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfPaymentRequestWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: PaymentRequestWithDetailsDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: EditionDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: EditionDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: SaasTenantDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SaasTenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: SaasTenantDto[] | undefined;
    totalCount?: number;
}

export class ApplicationAuthConfigurationDto implements IApplicationAuthConfigurationDto {
    grantedPolicies?: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationAuthConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["grantedPolicies"]) {
                this.grantedPolicies = {} as any;
                for (let key in _data["grantedPolicies"]) {
                    if (_data["grantedPolicies"].hasOwnProperty(key))
                        (<any>this.grantedPolicies)![key] = _data["grantedPolicies"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationAuthConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAuthConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.grantedPolicies) {
            data["grantedPolicies"] = {};
            for (let key in this.grantedPolicies) {
                if (this.grantedPolicies.hasOwnProperty(key))
                    (<any>data["grantedPolicies"])[key] = (<any>this.grantedPolicies)[key];
            }
        }
        return data;
    }
}

export interface IApplicationAuthConfigurationDto {
    grantedPolicies?: { [key: string]: boolean; } | undefined;
}

export class ApplicationConfigurationDto implements IApplicationConfigurationDto {
    localization?: ApplicationLocalizationConfigurationDto;
    auth?: ApplicationAuthConfigurationDto;
    setting?: ApplicationSettingConfigurationDto;
    currentUser?: CurrentUserDto;
    features?: ApplicationFeatureConfigurationDto;
    globalFeatures?: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy?: MultiTenancyInfoDto;
    currentTenant?: CurrentTenantDto;
    timing?: TimingDto;
    clock?: ClockDto;
    objectExtensions?: ObjectExtensionsDto;
    extraProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IApplicationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localization = _data["localization"] ? ApplicationLocalizationConfigurationDto.fromJS(_data["localization"]) : <any>undefined;
            this.auth = _data["auth"] ? ApplicationAuthConfigurationDto.fromJS(_data["auth"]) : <any>undefined;
            this.setting = _data["setting"] ? ApplicationSettingConfigurationDto.fromJS(_data["setting"]) : <any>undefined;
            this.currentUser = _data["currentUser"] ? CurrentUserDto.fromJS(_data["currentUser"]) : <any>undefined;
            this.features = _data["features"] ? ApplicationFeatureConfigurationDto.fromJS(_data["features"]) : <any>undefined;
            this.globalFeatures = _data["globalFeatures"] ? ApplicationGlobalFeatureConfigurationDto.fromJS(_data["globalFeatures"]) : <any>undefined;
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyInfoDto.fromJS(_data["multiTenancy"]) : <any>undefined;
            this.currentTenant = _data["currentTenant"] ? CurrentTenantDto.fromJS(_data["currentTenant"]) : <any>undefined;
            this.timing = _data["timing"] ? TimingDto.fromJS(_data["timing"]) : <any>undefined;
            this.clock = _data["clock"] ? ClockDto.fromJS(_data["clock"]) : <any>undefined;
            this.objectExtensions = _data["objectExtensions"] ? ObjectExtensionsDto.fromJS(_data["objectExtensions"]) : <any>undefined;
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["globalFeatures"] = this.globalFeatures ? this.globalFeatures.toJSON() : <any>undefined;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["currentTenant"] = this.currentTenant ? this.currentTenant.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["objectExtensions"] = this.objectExtensions ? this.objectExtensions.toJSON() : <any>undefined;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IApplicationConfigurationDto {
    localization?: ApplicationLocalizationConfigurationDto;
    auth?: ApplicationAuthConfigurationDto;
    setting?: ApplicationSettingConfigurationDto;
    currentUser?: CurrentUserDto;
    features?: ApplicationFeatureConfigurationDto;
    globalFeatures?: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy?: MultiTenancyInfoDto;
    currentTenant?: CurrentTenantDto;
    timing?: TimingDto;
    clock?: ClockDto;
    objectExtensions?: ObjectExtensionsDto;
    extraProperties?: { [key: string]: any; } | undefined;
}

export class ApplicationFeatureConfigurationDto implements IApplicationFeatureConfigurationDto {
    values?: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IApplicationFeatureConfigurationDto {
    values?: { [key: string]: string; } | undefined;
}

export class ApplicationGlobalFeatureConfigurationDto implements IApplicationGlobalFeatureConfigurationDto {
    enabledFeatures?: string[] | undefined;

    constructor(data?: IApplicationGlobalFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledFeatures"])) {
                this.enabledFeatures = [] as any;
                for (let item of _data["enabledFeatures"])
                    this.enabledFeatures!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationGlobalFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationGlobalFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledFeatures)) {
            data["enabledFeatures"] = [];
            for (let item of this.enabledFeatures)
                data["enabledFeatures"].push(item);
        }
        return data;
    }
}

export interface IApplicationGlobalFeatureConfigurationDto {
    enabledFeatures?: string[] | undefined;
}

export class ApplicationLocalizationConfigurationDto implements IApplicationLocalizationConfigurationDto {
    values?: { [key: string]: { [key: string]: string; }; } | undefined;
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
    languages?: LanguageInfo[] | undefined;
    currentCulture?: CurrentCultureDto;
    defaultResourceName?: string | undefined;
    languagesMap?: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap?: { [key: string]: NameValue[]; } | undefined;

    constructor(data?: IApplicationLocalizationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
            if (_data["resources"]) {
                this.resources = {} as any;
                for (let key in _data["resources"]) {
                    if (_data["resources"].hasOwnProperty(key))
                        (<any>this.resources)![key] = _data["resources"][key] ? ApplicationLocalizationResourceDto.fromJS(_data["resources"][key]) : new ApplicationLocalizationResourceDto();
                }
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
            this.currentCulture = _data["currentCulture"] ? CurrentCultureDto.fromJS(_data["currentCulture"]) : <any>undefined;
            this.defaultResourceName = _data["defaultResourceName"];
            if (_data["languagesMap"]) {
                this.languagesMap = {} as any;
                for (let key in _data["languagesMap"]) {
                    if (_data["languagesMap"].hasOwnProperty(key))
                        (<any>this.languagesMap)![key] = _data["languagesMap"][key] ? _data["languagesMap"][key].map((i: any) => NameValue.fromJS(i)) : <any>undefined;
                }
            }
            if (_data["languageFilesMap"]) {
                this.languageFilesMap = {} as any;
                for (let key in _data["languageFilesMap"]) {
                    if (_data["languageFilesMap"].hasOwnProperty(key))
                        (<any>this.languageFilesMap)![key] = _data["languageFilesMap"][key] ? _data["languageFilesMap"][key].map((i: any) => NameValue.fromJS(i)) : <any>undefined;
                }
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        if (this.resources) {
            data["resources"] = {};
            for (let key in this.resources) {
                if (this.resources.hasOwnProperty(key))
                    (<any>data["resources"])[key] = this.resources[key] ? this.resources[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        data["defaultResourceName"] = this.defaultResourceName;
        if (this.languagesMap) {
            data["languagesMap"] = {};
            for (let key in this.languagesMap) {
                if (this.languagesMap.hasOwnProperty(key))
                    (<any>data["languagesMap"])[key] = (<any>this.languagesMap)[key];
            }
        }
        if (this.languageFilesMap) {
            data["languageFilesMap"] = {};
            for (let key in this.languageFilesMap) {
                if (this.languageFilesMap.hasOwnProperty(key))
                    (<any>data["languageFilesMap"])[key] = (<any>this.languageFilesMap)[key];
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationConfigurationDto {
    values?: { [key: string]: { [key: string]: string; }; } | undefined;
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
    languages?: LanguageInfo[] | undefined;
    currentCulture?: CurrentCultureDto;
    defaultResourceName?: string | undefined;
    languagesMap?: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap?: { [key: string]: NameValue[]; } | undefined;
}

export class ApplicationLocalizationDto implements IApplicationLocalizationDto {
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;

    constructor(data?: IApplicationLocalizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["resources"]) {
                this.resources = {} as any;
                for (let key in _data["resources"]) {
                    if (_data["resources"].hasOwnProperty(key))
                        (<any>this.resources)![key] = _data["resources"][key] ? ApplicationLocalizationResourceDto.fromJS(_data["resources"][key]) : new ApplicationLocalizationResourceDto();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.resources) {
            data["resources"] = {};
            for (let key in this.resources) {
                if (this.resources.hasOwnProperty(key))
                    (<any>data["resources"])[key] = this.resources[key] ? this.resources[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationDto {
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
}

export class ApplicationLocalizationResourceDto implements IApplicationLocalizationResourceDto {
    texts?: { [key: string]: string; } | undefined;
    baseResources?: string[] | undefined;

    constructor(data?: IApplicationLocalizationResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["texts"]) {
                this.texts = {} as any;
                for (let key in _data["texts"]) {
                    if (_data["texts"].hasOwnProperty(key))
                        (<any>this.texts)![key] = _data["texts"][key];
                }
            }
            if (Array.isArray(_data["baseResources"])) {
                this.baseResources = [] as any;
                for (let item of _data["baseResources"])
                    this.baseResources!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.texts) {
            data["texts"] = {};
            for (let key in this.texts) {
                if (this.texts.hasOwnProperty(key))
                    (<any>data["texts"])[key] = (<any>this.texts)[key];
            }
        }
        if (Array.isArray(this.baseResources)) {
            data["baseResources"] = [];
            for (let item of this.baseResources)
                data["baseResources"].push(item);
        }
        return data;
    }
}

export interface IApplicationLocalizationResourceDto {
    texts?: { [key: string]: string; } | undefined;
    baseResources?: string[] | undefined;
}

export class ApplicationSettingConfigurationDto implements IApplicationSettingConfigurationDto {
    values?: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationSettingConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationSettingConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IApplicationSettingConfigurationDto {
    values?: { [key: string]: string; } | undefined;
}

export class ClockDto implements IClockDto {
    kind?: string | undefined;

    constructor(data?: IClockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
        }
    }

    static fromJS(data: any): ClockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        return data;
    }
}

export interface IClockDto {
    kind?: string | undefined;
}

export class CurrentCultureDto implements ICurrentCultureDto {
    displayName?: string | undefined;
    englishName?: string | undefined;
    threeLetterIsoLanguageName?: string | undefined;
    twoLetterIsoLanguageName?: string | undefined;
    isRightToLeft?: boolean;
    cultureName?: string | undefined;
    name?: string | undefined;
    nativeName?: string | undefined;
    dateTimeFormat?: DateTimeFormatDto;

    constructor(data?: ICurrentCultureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.englishName = _data["englishName"];
            this.threeLetterIsoLanguageName = _data["threeLetterIsoLanguageName"];
            this.twoLetterIsoLanguageName = _data["twoLetterIsoLanguageName"];
            this.isRightToLeft = _data["isRightToLeft"];
            this.cultureName = _data["cultureName"];
            this.name = _data["name"];
            this.nativeName = _data["nativeName"];
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatDto.fromJS(_data["dateTimeFormat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CurrentCultureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentCultureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["englishName"] = this.englishName;
        data["threeLetterIsoLanguageName"] = this.threeLetterIsoLanguageName;
        data["twoLetterIsoLanguageName"] = this.twoLetterIsoLanguageName;
        data["isRightToLeft"] = this.isRightToLeft;
        data["cultureName"] = this.cultureName;
        data["name"] = this.name;
        data["nativeName"] = this.nativeName;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICurrentCultureDto {
    displayName?: string | undefined;
    englishName?: string | undefined;
    threeLetterIsoLanguageName?: string | undefined;
    twoLetterIsoLanguageName?: string | undefined;
    isRightToLeft?: boolean;
    cultureName?: string | undefined;
    name?: string | undefined;
    nativeName?: string | undefined;
    dateTimeFormat?: DateTimeFormatDto;
}

export class CurrentUserDto implements ICurrentUserDto {
    isAuthenticated?: boolean;
    id?: string | undefined;
    tenantId?: string | undefined;
    impersonatorUserId?: string | undefined;
    impersonatorTenantId?: string | undefined;
    impersonatorUserName?: string | undefined;
    impersonatorTenantName?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surName?: string | undefined;
    email?: string | undefined;
    emailVerified?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberVerified?: boolean;
    roles?: string[] | undefined;

    constructor(data?: ICurrentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAuthenticated = _data["isAuthenticated"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserName = _data["impersonatorUserName"];
            this.impersonatorTenantName = _data["impersonatorTenantName"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surName = _data["surName"];
            this.email = _data["email"];
            this.emailVerified = _data["emailVerified"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberVerified = _data["phoneNumberVerified"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CurrentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAuthenticated"] = this.isAuthenticated;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserName"] = this.impersonatorUserName;
        data["impersonatorTenantName"] = this.impersonatorTenantName;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surName"] = this.surName;
        data["email"] = this.email;
        data["emailVerified"] = this.emailVerified;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberVerified"] = this.phoneNumberVerified;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICurrentUserDto {
    isAuthenticated?: boolean;
    id?: string | undefined;
    tenantId?: string | undefined;
    impersonatorUserId?: string | undefined;
    impersonatorTenantId?: string | undefined;
    impersonatorUserName?: string | undefined;
    impersonatorTenantName?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surName?: string | undefined;
    email?: string | undefined;
    emailVerified?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberVerified?: boolean;
    roles?: string[] | undefined;
}

export class DateTimeFormatDto implements IDateTimeFormatDto {
    calendarAlgorithmType?: string | undefined;
    dateTimeFormatLong?: string | undefined;
    shortDatePattern?: string | undefined;
    fullDateTimePattern?: string | undefined;
    dateSeparator?: string | undefined;
    shortTimePattern?: string | undefined;
    longTimePattern?: string | undefined;

    constructor(data?: IDateTimeFormatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calendarAlgorithmType = _data["calendarAlgorithmType"];
            this.dateTimeFormatLong = _data["dateTimeFormatLong"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.fullDateTimePattern = _data["fullDateTimePattern"];
            this.dateSeparator = _data["dateSeparator"];
            this.shortTimePattern = _data["shortTimePattern"];
            this.longTimePattern = _data["longTimePattern"];
        }
    }

    static fromJS(data: any): DateTimeFormatDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarAlgorithmType"] = this.calendarAlgorithmType;
        data["dateTimeFormatLong"] = this.dateTimeFormatLong;
        data["shortDatePattern"] = this.shortDatePattern;
        data["fullDateTimePattern"] = this.fullDateTimePattern;
        data["dateSeparator"] = this.dateSeparator;
        data["shortTimePattern"] = this.shortTimePattern;
        data["longTimePattern"] = this.longTimePattern;
        return data;
    }
}

export interface IDateTimeFormatDto {
    calendarAlgorithmType?: string | undefined;
    dateTimeFormatLong?: string | undefined;
    shortDatePattern?: string | undefined;
    fullDateTimePattern?: string | undefined;
    dateSeparator?: string | undefined;
    shortTimePattern?: string | undefined;
    longTimePattern?: string | undefined;
}

export class IanaTimeZone implements IIanaTimeZone {
    timeZoneName?: string | undefined;

    constructor(data?: IIanaTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneName = _data["timeZoneName"];
        }
    }

    static fromJS(data: any): IanaTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new IanaTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneName"] = this.timeZoneName;
        return data;
    }
}

export interface IIanaTimeZone {
    timeZoneName?: string | undefined;
}

export class EntityExtensionDto implements IEntityExtensionDto {
    properties?: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration?: { [key: string]: any; } | undefined;

    constructor(data?: IEntityExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? ExtensionPropertyDto.fromJS(_data["properties"][key]) : new ExtensionPropertyDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): EntityExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IEntityExtensionDto {
    properties?: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration?: { [key: string]: any; } | undefined;
}

export class ExtensionEnumDto implements IExtensionEnumDto {
    fields?: ExtensionEnumFieldDto[] | undefined;
    localizationResource?: string | undefined;

    constructor(data?: IExtensionEnumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ExtensionEnumFieldDto.fromJS(item));
            }
            this.localizationResource = _data["localizationResource"];
        }
    }

    static fromJS(data: any): ExtensionEnumDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["localizationResource"] = this.localizationResource;
        return data;
    }
}

export interface IExtensionEnumDto {
    fields?: ExtensionEnumFieldDto[] | undefined;
    localizationResource?: string | undefined;
}

export class ExtensionEnumFieldDto implements IExtensionEnumFieldDto {
    name?: string | undefined;
    value?: any | undefined;

    constructor(data?: IExtensionEnumFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExtensionEnumFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IExtensionEnumFieldDto {
    name?: string | undefined;
    value?: any | undefined;
}

export class ExtensionPropertyApiCreateDto implements IExtensionPropertyApiCreateDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiCreateDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyApiDto implements IExtensionPropertyApiDto {
    onGet?: ExtensionPropertyApiGetDto;
    onCreate?: ExtensionPropertyApiCreateDto;
    onUpdate?: ExtensionPropertyApiUpdateDto;

    constructor(data?: IExtensionPropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onGet = _data["onGet"] ? ExtensionPropertyApiGetDto.fromJS(_data["onGet"]) : <any>undefined;
            this.onCreate = _data["onCreate"] ? ExtensionPropertyApiCreateDto.fromJS(_data["onCreate"]) : <any>undefined;
            this.onUpdate = _data["onUpdate"] ? ExtensionPropertyApiUpdateDto.fromJS(_data["onUpdate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onGet"] = this.onGet ? this.onGet.toJSON() : <any>undefined;
        data["onCreate"] = this.onCreate ? this.onCreate.toJSON() : <any>undefined;
        data["onUpdate"] = this.onUpdate ? this.onUpdate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyApiDto {
    onGet?: ExtensionPropertyApiGetDto;
    onCreate?: ExtensionPropertyApiCreateDto;
    onUpdate?: ExtensionPropertyApiUpdateDto;
}

export class ExtensionPropertyApiGetDto implements IExtensionPropertyApiGetDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiGetDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyApiUpdateDto implements IExtensionPropertyApiUpdateDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiUpdateDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyAttributeDto implements IExtensionPropertyAttributeDto {
    typeSimple?: string | undefined;
    config?: { [key: string]: any; } | undefined;

    constructor(data?: IExtensionPropertyAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeSimple = _data["typeSimple"];
            if (_data["config"]) {
                this.config = {} as any;
                for (let key in _data["config"]) {
                    if (_data["config"].hasOwnProperty(key))
                        (<any>this.config)![key] = _data["config"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExtensionPropertyAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeSimple"] = this.typeSimple;
        if (this.config) {
            data["config"] = {};
            for (let key in this.config) {
                if (this.config.hasOwnProperty(key))
                    (<any>data["config"])[key] = (<any>this.config)[key];
            }
        }
        return data;
    }
}

export interface IExtensionPropertyAttributeDto {
    typeSimple?: string | undefined;
    config?: { [key: string]: any; } | undefined;
}

export class ExtensionPropertyDto implements IExtensionPropertyDto {
    type?: string | undefined;
    typeSimple?: string | undefined;
    displayName?: LocalizableStringDto;
    api?: ExtensionPropertyApiDto;
    ui?: ExtensionPropertyUiDto;
    attributes?: ExtensionPropertyAttributeDto[] | undefined;
    configuration?: { [key: string]: any; } | undefined;
    defaultValue?: any | undefined;

    constructor(data?: IExtensionPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.displayName = _data["displayName"] ? LocalizableStringDto.fromJS(_data["displayName"]) : <any>undefined;
            this.api = _data["api"] ? ExtensionPropertyApiDto.fromJS(_data["api"]) : <any>undefined;
            this.ui = _data["ui"] ? ExtensionPropertyUiDto.fromJS(_data["ui"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ExtensionPropertyAttributeDto.fromJS(item));
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): ExtensionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["api"] = this.api ? this.api.toJSON() : <any>undefined;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IExtensionPropertyDto {
    type?: string | undefined;
    typeSimple?: string | undefined;
    displayName?: LocalizableStringDto;
    api?: ExtensionPropertyApiDto;
    ui?: ExtensionPropertyUiDto;
    attributes?: ExtensionPropertyAttributeDto[] | undefined;
    configuration?: { [key: string]: any; } | undefined;
    defaultValue?: any | undefined;
}

export class ExtensionPropertyUiDto implements IExtensionPropertyUiDto {
    onTable?: ExtensionPropertyUiTableDto;
    onCreateForm?: ExtensionPropertyUiFormDto;
    onEditForm?: ExtensionPropertyUiFormDto;
    lookup?: ExtensionPropertyUiLookupDto;

    constructor(data?: IExtensionPropertyUiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onTable = _data["onTable"] ? ExtensionPropertyUiTableDto.fromJS(_data["onTable"]) : <any>undefined;
            this.onCreateForm = _data["onCreateForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onCreateForm"]) : <any>undefined;
            this.onEditForm = _data["onEditForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onEditForm"]) : <any>undefined;
            this.lookup = _data["lookup"] ? ExtensionPropertyUiLookupDto.fromJS(_data["lookup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTable"] = this.onTable ? this.onTable.toJSON() : <any>undefined;
        data["onCreateForm"] = this.onCreateForm ? this.onCreateForm.toJSON() : <any>undefined;
        data["onEditForm"] = this.onEditForm ? this.onEditForm.toJSON() : <any>undefined;
        data["lookup"] = this.lookup ? this.lookup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyUiDto {
    onTable?: ExtensionPropertyUiTableDto;
    onCreateForm?: ExtensionPropertyUiFormDto;
    onEditForm?: ExtensionPropertyUiFormDto;
    lookup?: ExtensionPropertyUiLookupDto;
}

export class ExtensionPropertyUiFormDto implements IExtensionPropertyUiFormDto {
    isVisible?: boolean;

    constructor(data?: IExtensionPropertyUiFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiFormDto {
    isVisible?: boolean;
}

export class ExtensionPropertyUiLookupDto implements IExtensionPropertyUiLookupDto {
    url?: string | undefined;
    resultListPropertyName?: string | undefined;
    displayPropertyName?: string | undefined;
    valuePropertyName?: string | undefined;
    filterParamName?: string | undefined;

    constructor(data?: IExtensionPropertyUiLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.resultListPropertyName = _data["resultListPropertyName"];
            this.displayPropertyName = _data["displayPropertyName"];
            this.valuePropertyName = _data["valuePropertyName"];
            this.filterParamName = _data["filterParamName"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["resultListPropertyName"] = this.resultListPropertyName;
        data["displayPropertyName"] = this.displayPropertyName;
        data["valuePropertyName"] = this.valuePropertyName;
        data["filterParamName"] = this.filterParamName;
        return data;
    }
}

export interface IExtensionPropertyUiLookupDto {
    url?: string | undefined;
    resultListPropertyName?: string | undefined;
    displayPropertyName?: string | undefined;
    valuePropertyName?: string | undefined;
    filterParamName?: string | undefined;
}

export class ExtensionPropertyUiTableDto implements IExtensionPropertyUiTableDto {
    isVisible?: boolean;

    constructor(data?: IExtensionPropertyUiTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiTableDto {
    isVisible?: boolean;
}

export class LocalizableStringDto implements ILocalizableStringDto {
    name?: string | undefined;
    resource?: string | undefined;

    constructor(data?: ILocalizableStringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.resource = _data["resource"];
        }
    }

    static fromJS(data: any): LocalizableStringDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableStringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["resource"] = this.resource;
        return data;
    }
}

export interface ILocalizableStringDto {
    name?: string | undefined;
    resource?: string | undefined;
}

export class ModuleExtensionDto implements IModuleExtensionDto {
    entities?: { [key: string]: EntityExtensionDto; } | undefined;
    configuration?: { [key: string]: any; } | undefined;

    constructor(data?: IModuleExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["entities"]) {
                this.entities = {} as any;
                for (let key in _data["entities"]) {
                    if (_data["entities"].hasOwnProperty(key))
                        (<any>this.entities)![key] = _data["entities"][key] ? EntityExtensionDto.fromJS(_data["entities"][key]) : new EntityExtensionDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ModuleExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.entities) {
            data["entities"] = {};
            for (let key in this.entities) {
                if (this.entities.hasOwnProperty(key))
                    (<any>data["entities"])[key] = this.entities[key] ? this.entities[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IModuleExtensionDto {
    entities?: { [key: string]: EntityExtensionDto; } | undefined;
    configuration?: { [key: string]: any; } | undefined;
}

export class ObjectExtensionsDto implements IObjectExtensionsDto {
    modules?: { [key: string]: ModuleExtensionDto; } | undefined;
    enums?: { [key: string]: ExtensionEnumDto; } | undefined;

    constructor(data?: IObjectExtensionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleExtensionDto.fromJS(_data["modules"][key]) : new ModuleExtensionDto();
                }
            }
            if (_data["enums"]) {
                this.enums = {} as any;
                for (let key in _data["enums"]) {
                    if (_data["enums"].hasOwnProperty(key))
                        (<any>this.enums)![key] = _data["enums"][key] ? ExtensionEnumDto.fromJS(_data["enums"][key]) : new ExtensionEnumDto();
                }
            }
        }
    }

    static fromJS(data: any): ObjectExtensionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectExtensionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.enums) {
            data["enums"] = {};
            for (let key in this.enums) {
                if (this.enums.hasOwnProperty(key))
                    (<any>data["enums"])[key] = this.enums[key] ? this.enums[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IObjectExtensionsDto {
    modules?: { [key: string]: ModuleExtensionDto; } | undefined;
    enums?: { [key: string]: ExtensionEnumDto; } | undefined;
}

export class TimeZone implements ITimeZone {
    iana?: IanaTimeZone;
    windows?: WindowsTimeZone;

    constructor(data?: ITimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iana = _data["iana"] ? IanaTimeZone.fromJS(_data["iana"]) : <any>undefined;
            this.windows = _data["windows"] ? WindowsTimeZone.fromJS(_data["windows"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new TimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimeZone {
    iana?: IanaTimeZone;
    windows?: WindowsTimeZone;
}

export class TimingDto implements ITimingDto {
    timeZone?: TimeZone;

    constructor(data?: ITimingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZone = _data["timeZone"] ? TimeZone.fromJS(_data["timeZone"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimingDto {
    timeZone?: TimeZone;
}

export class WindowsTimeZone implements IWindowsTimeZone {
    timeZoneId?: string | undefined;

    constructor(data?: IWindowsTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): WindowsTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new WindowsTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface IWindowsTimeZone {
    timeZoneId?: string | undefined;
}

export class CurrentTenantDto implements ICurrentTenantDto {
    id?: string | undefined;
    name?: string | undefined;
    isAvailable?: boolean;

    constructor(data?: ICurrentTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): CurrentTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface ICurrentTenantDto {
    id?: string | undefined;
    name?: string | undefined;
    isAvailable?: boolean;
}

export class FindTenantResultDto implements IFindTenantResultDto {
    success?: boolean;
    tenantId?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IFindTenantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FindTenantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindTenantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFindTenantResultDto {
    success?: boolean;
    tenantId?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class MultiTenancyInfoDto implements IMultiTenancyInfoDto {
    isEnabled?: boolean;

    constructor(data?: IMultiTenancyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): MultiTenancyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IMultiTenancyInfoDto {
    isEnabled?: boolean;
}

export class AuditLogActionDto implements IAuditLogActionDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    tenantId?: string | undefined;
    auditLogId?: string;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    parameters?: string | undefined;
    executionTime?: Date;
    executionDuration?: number;

    constructor(data?: IAuditLogActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.auditLogId = _data["auditLogId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? new Date(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
        }
    }

    static fromJS(data: any): AuditLogActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["auditLogId"] = this.auditLogId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        return data;
    }
}

export interface IAuditLogActionDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    tenantId?: string | undefined;
    auditLogId?: string;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    parameters?: string | undefined;
    executionTime?: Date;
    executionDuration?: number;
}

export class AuditLogDto implements IAuditLogDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    userId?: string | undefined;
    userName?: string | undefined;
    tenantId?: string | undefined;
    tenantName?: string | undefined;
    impersonatorUserId?: string | undefined;
    impersonatorUserName?: string | undefined;
    impersonatorTenantId?: string | undefined;
    impersonatorTenantName?: string | undefined;
    executionTime?: Date;
    executionDuration?: number;
    clientIpAddress?: string | undefined;
    clientName?: string | undefined;
    browserInfo?: string | undefined;
    httpMethod?: string | undefined;
    url?: string | undefined;
    exceptions?: string | undefined;
    comments?: string | undefined;
    httpStatusCode?: number | undefined;
    applicationName?: string | undefined;
    correlationId?: string | undefined;
    entityChanges?: EntityChangeDto[] | undefined;
    actions?: AuditLogActionDto[] | undefined;

    constructor(data?: IAuditLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorUserName = _data["impersonatorUserName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorTenantName = _data["impersonatorTenantName"];
            this.executionTime = _data["executionTime"] ? new Date(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            this.exceptions = _data["exceptions"];
            this.comments = _data["comments"];
            this.httpStatusCode = _data["httpStatusCode"];
            this.applicationName = _data["applicationName"];
            this.correlationId = _data["correlationId"];
            if (Array.isArray(_data["entityChanges"])) {
                this.entityChanges = [] as any;
                for (let item of _data["entityChanges"])
                    this.entityChanges!.push(EntityChangeDto.fromJS(item));
            }
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(AuditLogActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorUserName"] = this.impersonatorUserName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorTenantName"] = this.impersonatorTenantName;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        data["exceptions"] = this.exceptions;
        data["comments"] = this.comments;
        data["httpStatusCode"] = this.httpStatusCode;
        data["applicationName"] = this.applicationName;
        data["correlationId"] = this.correlationId;
        if (Array.isArray(this.entityChanges)) {
            data["entityChanges"] = [];
            for (let item of this.entityChanges)
                data["entityChanges"].push(item.toJSON());
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAuditLogDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    userId?: string | undefined;
    userName?: string | undefined;
    tenantId?: string | undefined;
    tenantName?: string | undefined;
    impersonatorUserId?: string | undefined;
    impersonatorUserName?: string | undefined;
    impersonatorTenantId?: string | undefined;
    impersonatorTenantName?: string | undefined;
    executionTime?: Date;
    executionDuration?: number;
    clientIpAddress?: string | undefined;
    clientName?: string | undefined;
    browserInfo?: string | undefined;
    httpMethod?: string | undefined;
    url?: string | undefined;
    exceptions?: string | undefined;
    comments?: string | undefined;
    httpStatusCode?: number | undefined;
    applicationName?: string | undefined;
    correlationId?: string | undefined;
    entityChanges?: EntityChangeDto[] | undefined;
    actions?: AuditLogActionDto[] | undefined;
}

export class EntityChangeDto implements IEntityChangeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    auditLogId?: string;
    tenantId?: string | undefined;
    changeTime?: Date;
    changeType?: EntityChangeType;
    entityId?: string | undefined;
    entityTypeFullName?: string | undefined;
    propertyChanges?: EntityPropertyChangeDto[] | undefined;

    constructor(data?: IEntityChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.auditLogId = _data["auditLogId"];
            this.tenantId = _data["tenantId"];
            this.changeTime = _data["changeTime"] ? new Date(_data["changeTime"].toString()) : <any>undefined;
            this.changeType = _data["changeType"];
            this.entityId = _data["entityId"];
            this.entityTypeFullName = _data["entityTypeFullName"];
            if (Array.isArray(_data["propertyChanges"])) {
                this.propertyChanges = [] as any;
                for (let item of _data["propertyChanges"])
                    this.propertyChanges!.push(EntityPropertyChangeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["auditLogId"] = this.auditLogId;
        data["tenantId"] = this.tenantId;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["changeType"] = this.changeType;
        data["entityId"] = this.entityId;
        data["entityTypeFullName"] = this.entityTypeFullName;
        if (Array.isArray(this.propertyChanges)) {
            data["propertyChanges"] = [];
            for (let item of this.propertyChanges)
                data["propertyChanges"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntityChangeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    auditLogId?: string;
    tenantId?: string | undefined;
    changeTime?: Date;
    changeType?: EntityChangeType;
    entityId?: string | undefined;
    entityTypeFullName?: string | undefined;
    propertyChanges?: EntityPropertyChangeDto[] | undefined;
}

export class EntityChangeWithUsernameDto implements IEntityChangeWithUsernameDto {
    entityChange?: EntityChangeDto;
    userName?: string | undefined;

    constructor(data?: IEntityChangeWithUsernameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityChange = _data["entityChange"] ? EntityChangeDto.fromJS(_data["entityChange"]) : <any>undefined;
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): EntityChangeWithUsernameDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeWithUsernameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChange"] = this.entityChange ? this.entityChange.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IEntityChangeWithUsernameDto {
    entityChange?: EntityChangeDto;
    userName?: string | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    id?: string;
    tenantId?: string | undefined;
    entityChangeId?: string;
    newValue?: string | undefined;
    originalValue?: string | undefined;
    propertyName?: string | undefined;
    propertyTypeFullName?: string | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        return data;
    }
}

export interface IEntityPropertyChangeDto {
    id?: string;
    tenantId?: string | undefined;
    entityChangeId?: string;
    newValue?: string | undefined;
    originalValue?: string | undefined;
    propertyName?: string | undefined;
    propertyTypeFullName?: string | undefined;
}

export class GetAverageExecutionDurationPerDayOutput implements IGetAverageExecutionDurationPerDayOutput {
    data?: { [key: string]: number; } | undefined;

    constructor(data?: IGetAverageExecutionDurationPerDayOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetAverageExecutionDurationPerDayOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAverageExecutionDurationPerDayOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface IGetAverageExecutionDurationPerDayOutput {
    data?: { [key: string]: number; } | undefined;
}

export class GetErrorRateOutput implements IGetErrorRateOutput {
    data?: { [key: string]: number; } | undefined;

    constructor(data?: IGetErrorRateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetErrorRateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetErrorRateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface IGetErrorRateOutput {
    data?: { [key: string]: number; } | undefined;
}

export enum EntityChangeType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class FeatureDto implements IFeatureDto {
    name?: string | undefined;
    displayName?: string | undefined;
    value?: string | undefined;
    provider?: FeatureProviderDto;
    description?: string | undefined;
    valueType?: IStringValueType;
    depth?: number;
    parentName?: string | undefined;

    constructor(data?: IFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.value = _data["value"];
            this.provider = _data["provider"] ? FeatureProviderDto.fromJS(_data["provider"]) : <any>undefined;
            this.description = _data["description"];
            this.valueType = _data["valueType"] ? IStringValueType.fromJS(_data["valueType"]) : <any>undefined;
            this.depth = _data["depth"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): FeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["value"] = this.value;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["valueType"] = this.valueType ? this.valueType.toJSON() : <any>undefined;
        data["depth"] = this.depth;
        data["parentName"] = this.parentName;
        return data;
    }
}

export interface IFeatureDto {
    name?: string | undefined;
    displayName?: string | undefined;
    value?: string | undefined;
    provider?: FeatureProviderDto;
    description?: string | undefined;
    valueType?: IStringValueType;
    depth?: number;
    parentName?: string | undefined;
}

export class FeatureGroupDto implements IFeatureGroupDto {
    name?: string | undefined;
    displayName?: string | undefined;
    features?: FeatureDto[] | undefined;

    constructor(data?: IFeatureGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeatureGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFeatureGroupDto {
    name?: string | undefined;
    displayName?: string | undefined;
    features?: FeatureDto[] | undefined;
}

export class FeatureProviderDto implements IFeatureProviderDto {
    name?: string | undefined;
    key?: string | undefined;

    constructor(data?: IFeatureProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): FeatureProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["key"] = this.key;
        return data;
    }
}

export interface IFeatureProviderDto {
    name?: string | undefined;
    key?: string | undefined;
}

export class GetFeatureListResultDto implements IGetFeatureListResultDto {
    groups?: FeatureGroupDto[] | undefined;

    constructor(data?: IGetFeatureListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(FeatureGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFeatureListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeatureListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetFeatureListResultDto {
    groups?: FeatureGroupDto[] | undefined;
}

export class UpdateFeatureDto implements IUpdateFeatureDto {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IUpdateFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateFeatureDto {
    name?: string | undefined;
    value?: string | undefined;
}

export class UpdateFeaturesDto implements IUpdateFeaturesDto {
    features?: UpdateFeatureDto[] | undefined;

    constructor(data?: IUpdateFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(UpdateFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateFeaturesDto {
    features?: UpdateFeatureDto[] | undefined;
}

export class DownloadTokenResultDto implements IDownloadTokenResultDto {
    token?: string | undefined;

    constructor(data?: IDownloadTokenResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): DownloadTokenResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadTokenResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IDownloadTokenResultDto {
    token?: string | undefined;
}

export class GdprRequestDto implements IGdprRequestDto {
    id?: string;
    creationTime?: Date;
    readyTime?: Date;

    constructor(data?: IGdprRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.readyTime = _data["readyTime"] ? new Date(_data["readyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GdprRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GdprRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["readyTime"] = this.readyTime ? this.readyTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGdprRequestDto {
    id?: string;
    creationTime?: Date;
    readyTime?: Date;
}

export class ActionApiDescriptionModel implements IActionApiDescriptionModel {
    uniqueName?: string | undefined;
    name?: string | undefined;
    httpMethod?: string | undefined;
    url?: string | undefined;
    supportedVersions?: string[] | undefined;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | undefined;
    parameters?: ParameterApiDescriptionModel[] | undefined;
    returnValue?: ReturnValueApiDescriptionModel;
    allowAnonymous?: boolean | undefined;
    implementFrom?: string | undefined;

    constructor(data?: IActionApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueName = _data["uniqueName"];
            this.name = _data["name"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            if (Array.isArray(_data["supportedVersions"])) {
                this.supportedVersions = [] as any;
                for (let item of _data["supportedVersions"])
                    this.supportedVersions!.push(item);
            }
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(ParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>undefined;
            this.allowAnonymous = _data["allowAnonymous"];
            this.implementFrom = _data["implementFrom"];
        }
    }

    static fromJS(data: any): ActionApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName;
        data["name"] = this.name;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        if (Array.isArray(this.supportedVersions)) {
            data["supportedVersions"] = [];
            for (let item of this.supportedVersions)
                data["supportedVersions"].push(item);
        }
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        data["allowAnonymous"] = this.allowAnonymous;
        data["implementFrom"] = this.implementFrom;
        return data;
    }
}

export interface IActionApiDescriptionModel {
    uniqueName?: string | undefined;
    name?: string | undefined;
    httpMethod?: string | undefined;
    url?: string | undefined;
    supportedVersions?: string[] | undefined;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | undefined;
    parameters?: ParameterApiDescriptionModel[] | undefined;
    returnValue?: ReturnValueApiDescriptionModel;
    allowAnonymous?: boolean | undefined;
    implementFrom?: string | undefined;
}

export class ApplicationApiDescriptionModel implements IApplicationApiDescriptionModel {
    modules?: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types?: { [key: string]: TypeApiDescriptionModel; } | undefined;

    constructor(data?: IApplicationApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleApiDescriptionModel.fromJS(_data["modules"][key]) : new ModuleApiDescriptionModel();
                }
            }
            if (_data["types"]) {
                this.types = {} as any;
                for (let key in _data["types"]) {
                    if (_data["types"].hasOwnProperty(key))
                        (<any>this.types)![key] = _data["types"][key] ? TypeApiDescriptionModel.fromJS(_data["types"][key]) : new TypeApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    (<any>data["types"])[key] = this.types[key] ? this.types[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationApiDescriptionModel {
    modules?: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types?: { [key: string]: TypeApiDescriptionModel; } | undefined;
}

export class ControllerApiDescriptionModel implements IControllerApiDescriptionModel {
    controllerName?: string | undefined;
    controllerGroupName?: string | undefined;
    isRemoteService?: boolean;
    isIntegrationService?: boolean;
    apiVersion?: string | undefined;
    type?: string | undefined;
    interfaces?: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions?: { [key: string]: ActionApiDescriptionModel; } | undefined;

    constructor(data?: IControllerApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllerName = _data["controllerName"];
            this.controllerGroupName = _data["controllerGroupName"];
            this.isRemoteService = _data["isRemoteService"];
            this.isIntegrationService = _data["isIntegrationService"];
            this.apiVersion = _data["apiVersion"];
            this.type = _data["type"];
            if (Array.isArray(_data["interfaces"])) {
                this.interfaces = [] as any;
                for (let item of _data["interfaces"])
                    this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item));
            }
            if (_data["actions"]) {
                this.actions = {} as any;
                for (let key in _data["actions"]) {
                    if (_data["actions"].hasOwnProperty(key))
                        (<any>this.actions)![key] = _data["actions"][key] ? ActionApiDescriptionModel.fromJS(_data["actions"][key]) : new ActionApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ControllerApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerName"] = this.controllerName;
        data["controllerGroupName"] = this.controllerGroupName;
        data["isRemoteService"] = this.isRemoteService;
        data["isIntegrationService"] = this.isIntegrationService;
        data["apiVersion"] = this.apiVersion;
        data["type"] = this.type;
        if (Array.isArray(this.interfaces)) {
            data["interfaces"] = [];
            for (let item of this.interfaces)
                data["interfaces"].push(item.toJSON());
        }
        if (this.actions) {
            data["actions"] = {};
            for (let key in this.actions) {
                if (this.actions.hasOwnProperty(key))
                    (<any>data["actions"])[key] = this.actions[key] ? this.actions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IControllerApiDescriptionModel {
    controllerName?: string | undefined;
    controllerGroupName?: string | undefined;
    isRemoteService?: boolean;
    isIntegrationService?: boolean;
    apiVersion?: string | undefined;
    type?: string | undefined;
    interfaces?: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions?: { [key: string]: ActionApiDescriptionModel; } | undefined;
}

export class ControllerInterfaceApiDescriptionModel implements IControllerInterfaceApiDescriptionModel {
    type?: string | undefined;
    name?: string | undefined;
    methods?: InterfaceMethodApiDescriptionModel[] | undefined;

    constructor(data?: IControllerInterfaceApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            if (Array.isArray(_data["methods"])) {
                this.methods = [] as any;
                for (let item of _data["methods"])
                    this.methods!.push(InterfaceMethodApiDescriptionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ControllerInterfaceApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerInterfaceApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        if (Array.isArray(this.methods)) {
            data["methods"] = [];
            for (let item of this.methods)
                data["methods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IControllerInterfaceApiDescriptionModel {
    type?: string | undefined;
    name?: string | undefined;
    methods?: InterfaceMethodApiDescriptionModel[] | undefined;
}

export class InterfaceMethodApiDescriptionModel implements IInterfaceMethodApiDescriptionModel {
    name?: string | undefined;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | undefined;
    returnValue?: ReturnValueApiDescriptionModel;

    constructor(data?: IInterfaceMethodApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InterfaceMethodApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new InterfaceMethodApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInterfaceMethodApiDescriptionModel {
    name?: string | undefined;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | undefined;
    returnValue?: ReturnValueApiDescriptionModel;
}

export class MethodParameterApiDescriptionModel implements IMethodParameterApiDescriptionModel {
    name?: string | undefined;
    typeAsString?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isOptional?: boolean;
    defaultValue?: any | undefined;

    constructor(data?: IMethodParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeAsString = _data["typeAsString"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): MethodParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new MethodParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeAsString"] = this.typeAsString;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IMethodParameterApiDescriptionModel {
    name?: string | undefined;
    typeAsString?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isOptional?: boolean;
    defaultValue?: any | undefined;
}

export class ModuleApiDescriptionModel implements IModuleApiDescriptionModel {
    rootPath?: string | undefined;
    remoteServiceName?: string | undefined;
    controllers?: { [key: string]: ControllerApiDescriptionModel; } | undefined;

    constructor(data?: IModuleApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"];
            this.remoteServiceName = _data["remoteServiceName"];
            if (_data["controllers"]) {
                this.controllers = {} as any;
                for (let key in _data["controllers"]) {
                    if (_data["controllers"].hasOwnProperty(key))
                        (<any>this.controllers)![key] = _data["controllers"][key] ? ControllerApiDescriptionModel.fromJS(_data["controllers"][key]) : new ControllerApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ModuleApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath;
        data["remoteServiceName"] = this.remoteServiceName;
        if (this.controllers) {
            data["controllers"] = {};
            for (let key in this.controllers) {
                if (this.controllers.hasOwnProperty(key))
                    (<any>data["controllers"])[key] = this.controllers[key] ? this.controllers[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IModuleApiDescriptionModel {
    rootPath?: string | undefined;
    remoteServiceName?: string | undefined;
    controllers?: { [key: string]: ControllerApiDescriptionModel; } | undefined;
}

export class ParameterApiDescriptionModel implements IParameterApiDescriptionModel {
    nameOnMethod?: string | undefined;
    name?: string | undefined;
    jsonName?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isOptional?: boolean;
    defaultValue?: any | undefined;
    constraintTypes?: string[] | undefined;
    bindingSourceId?: string | undefined;
    descriptorName?: string | undefined;

    constructor(data?: IParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameOnMethod = _data["nameOnMethod"];
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
            if (Array.isArray(_data["constraintTypes"])) {
                this.constraintTypes = [] as any;
                for (let item of _data["constraintTypes"])
                    this.constraintTypes!.push(item);
            }
            this.bindingSourceId = _data["bindingSourceId"];
            this.descriptorName = _data["descriptorName"];
        }
    }

    static fromJS(data: any): ParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOnMethod"] = this.nameOnMethod;
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        if (Array.isArray(this.constraintTypes)) {
            data["constraintTypes"] = [];
            for (let item of this.constraintTypes)
                data["constraintTypes"].push(item);
        }
        data["bindingSourceId"] = this.bindingSourceId;
        data["descriptorName"] = this.descriptorName;
        return data;
    }
}

export interface IParameterApiDescriptionModel {
    nameOnMethod?: string | undefined;
    name?: string | undefined;
    jsonName?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isOptional?: boolean;
    defaultValue?: any | undefined;
    constraintTypes?: string[] | undefined;
    bindingSourceId?: string | undefined;
    descriptorName?: string | undefined;
}

export class PropertyApiDescriptionModel implements IPropertyApiDescriptionModel {
    name?: string | undefined;
    jsonName?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isRequired?: boolean;
    minLength?: number | undefined;
    maxLength?: number | undefined;
    minimum?: string | undefined;
    maximum?: string | undefined;
    regex?: string | undefined;

    constructor(data?: IPropertyApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isRequired = _data["isRequired"];
            this.minLength = _data["minLength"];
            this.maxLength = _data["maxLength"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
            this.regex = _data["regex"];
        }
    }

    static fromJS(data: any): PropertyApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isRequired"] = this.isRequired;
        data["minLength"] = this.minLength;
        data["maxLength"] = this.maxLength;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["regex"] = this.regex;
        return data;
    }
}

export interface IPropertyApiDescriptionModel {
    name?: string | undefined;
    jsonName?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isRequired?: boolean;
    minLength?: number | undefined;
    maxLength?: number | undefined;
    minimum?: string | undefined;
    maximum?: string | undefined;
    regex?: string | undefined;
}

export class ReturnValueApiDescriptionModel implements IReturnValueApiDescriptionModel {
    type?: string | undefined;
    typeSimple?: string | undefined;

    constructor(data?: IReturnValueApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
        }
    }

    static fromJS(data: any): ReturnValueApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnValueApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        return data;
    }
}

export interface IReturnValueApiDescriptionModel {
    type?: string | undefined;
    typeSimple?: string | undefined;
}

export class TypeApiDescriptionModel implements ITypeApiDescriptionModel {
    baseType?: string | undefined;
    isEnum?: boolean;
    enumNames?: string[] | undefined;
    enumValues?: any[] | undefined;
    genericArguments?: string[] | undefined;
    properties?: PropertyApiDescriptionModel[] | undefined;

    constructor(data?: ITypeApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseType = _data["baseType"];
            this.isEnum = _data["isEnum"];
            if (Array.isArray(_data["enumNames"])) {
                this.enumNames = [] as any;
                for (let item of _data["enumNames"])
                    this.enumNames!.push(item);
            }
            if (Array.isArray(_data["enumValues"])) {
                this.enumValues = [] as any;
                for (let item of _data["enumValues"])
                    this.enumValues!.push(item);
            }
            if (Array.isArray(_data["genericArguments"])) {
                this.genericArguments = [] as any;
                for (let item of _data["genericArguments"])
                    this.genericArguments!.push(item);
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(PropertyApiDescriptionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new TypeApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseType"] = this.baseType;
        data["isEnum"] = this.isEnum;
        if (Array.isArray(this.enumNames)) {
            data["enumNames"] = [];
            for (let item of this.enumNames)
                data["enumNames"].push(item);
        }
        if (Array.isArray(this.enumValues)) {
            data["enumValues"] = [];
            for (let item of this.enumValues)
                data["enumValues"].push(item);
        }
        if (Array.isArray(this.genericArguments)) {
            data["genericArguments"] = [];
            for (let item of this.genericArguments)
                data["genericArguments"].push(item);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeApiDescriptionModel {
    baseType?: string | undefined;
    isEnum?: boolean;
    enumNames?: string[] | undefined;
    enumValues?: any[] | undefined;
    genericArguments?: string[] | undefined;
    properties?: PropertyApiDescriptionModel[] | undefined;
}

export class RemoteServiceErrorInfo implements IRemoteServiceErrorInfo {
    code?: string | undefined;
    message?: string | undefined;
    details?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    validationErrors?: RemoteServiceValidationErrorInfo[] | undefined;

    constructor(data?: IRemoteServiceErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(RemoteServiceValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RemoteServiceErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRemoteServiceErrorInfo {
    code?: string | undefined;
    message?: string | undefined;
    details?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    validationErrors?: RemoteServiceValidationErrorInfo[] | undefined;
}

export class RemoteServiceErrorResponse implements IRemoteServiceErrorResponse {
    error?: RemoteServiceErrorInfo;

    constructor(data?: IRemoteServiceErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? RemoteServiceErrorInfo.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RemoteServiceErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRemoteServiceErrorResponse {
    error?: RemoteServiceErrorInfo;
}

export class RemoteServiceValidationErrorInfo implements IRemoteServiceValidationErrorInfo {
    message?: string | undefined;
    members?: string[] | undefined;

    constructor(data?: IRemoteServiceValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoteServiceValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data;
    }
}

export interface IRemoteServiceValidationErrorInfo {
    message?: string | undefined;
    members?: string[] | undefined;
}

export class ClaimTypeDto implements IClaimTypeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    required?: boolean;
    isStatic?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
    valueTypeAsString?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IClaimTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.required = _data["required"];
            this.isStatic = _data["isStatic"];
            this.regex = _data["regex"];
            this.regexDescription = _data["regexDescription"];
            this.description = _data["description"];
            this.valueType = _data["valueType"];
            this.valueTypeAsString = _data["valueTypeAsString"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ClaimTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["required"] = this.required;
        data["isStatic"] = this.isStatic;
        data["regex"] = this.regex;
        data["regexDescription"] = this.regexDescription;
        data["description"] = this.description;
        data["valueType"] = this.valueType;
        data["valueTypeAsString"] = this.valueTypeAsString;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IClaimTypeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    required?: boolean;
    isStatic?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
    valueTypeAsString?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class CreateClaimTypeDto implements ICreateClaimTypeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    required?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;

    constructor(data?: ICreateClaimTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.required = _data["required"];
            this.regex = _data["regex"];
            this.regexDescription = _data["regexDescription"];
            this.description = _data["description"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): CreateClaimTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClaimTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["required"] = this.required;
        data["regex"] = this.regex;
        data["regexDescription"] = this.regexDescription;
        data["description"] = this.description;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface ICreateClaimTypeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    required?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
}

export class ExternalLoginProviderDto implements IExternalLoginProviderDto {
    name?: string | undefined;
    canObtainUserInfoWithoutPassword?: boolean;

    constructor(data?: IExternalLoginProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.canObtainUserInfoWithoutPassword = _data["canObtainUserInfoWithoutPassword"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["canObtainUserInfoWithoutPassword"] = this.canObtainUserInfoWithoutPassword;
        return data;
    }
}

export interface IExternalLoginProviderDto {
    name?: string | undefined;
    canObtainUserInfoWithoutPassword?: boolean;
}

export enum IdentityProTwoFactorBehaviour {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum IdentityClaimValueType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IdentityLdapSettingsDto implements IIdentityLdapSettingsDto {
    enableLdapLogin?: boolean;
    ldapServerHost?: string | undefined;
    ldapServerPort?: string | undefined;
    ldapBaseDc?: string | undefined;
    ldapDomain?: string | undefined;
    ldapUserName?: string | undefined;
    ldapPassword?: string | undefined;

    constructor(data?: IIdentityLdapSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableLdapLogin = _data["enableLdapLogin"];
            this.ldapServerHost = _data["ldapServerHost"];
            this.ldapServerPort = _data["ldapServerPort"];
            this.ldapBaseDc = _data["ldapBaseDc"];
            this.ldapDomain = _data["ldapDomain"];
            this.ldapUserName = _data["ldapUserName"];
            this.ldapPassword = _data["ldapPassword"];
        }
    }

    static fromJS(data: any): IdentityLdapSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityLdapSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableLdapLogin"] = this.enableLdapLogin;
        data["ldapServerHost"] = this.ldapServerHost;
        data["ldapServerPort"] = this.ldapServerPort;
        data["ldapBaseDc"] = this.ldapBaseDc;
        data["ldapDomain"] = this.ldapDomain;
        data["ldapUserName"] = this.ldapUserName;
        data["ldapPassword"] = this.ldapPassword;
        return data;
    }
}

export interface IIdentityLdapSettingsDto {
    enableLdapLogin?: boolean;
    ldapServerHost?: string | undefined;
    ldapServerPort?: string | undefined;
    ldapBaseDc?: string | undefined;
    ldapDomain?: string | undefined;
    ldapUserName?: string | undefined;
    ldapPassword?: string | undefined;
}

export class IdentityLockoutSettingsDto implements IIdentityLockoutSettingsDto {
    allowedForNewUsers?: boolean;
    lockoutDuration?: number;
    maxFailedAccessAttempts?: number;

    constructor(data?: IIdentityLockoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowedForNewUsers = _data["allowedForNewUsers"];
            this.lockoutDuration = _data["lockoutDuration"];
            this.maxFailedAccessAttempts = _data["maxFailedAccessAttempts"];
        }
    }

    static fromJS(data: any): IdentityLockoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityLockoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowedForNewUsers"] = this.allowedForNewUsers;
        data["lockoutDuration"] = this.lockoutDuration;
        data["maxFailedAccessAttempts"] = this.maxFailedAccessAttempts;
        return data;
    }
}

export interface IIdentityLockoutSettingsDto {
    allowedForNewUsers?: boolean;
    lockoutDuration?: number;
    maxFailedAccessAttempts?: number;
}

export class IdentityOAuthSettingsDto implements IIdentityOAuthSettingsDto {
    enableOAuthLogin?: boolean;
    clientId!: string;
    clientSecret?: string | undefined;
    authority!: string;
    scope?: string | undefined;
    requireHttpsMetadata?: boolean;
    validateEndpoints?: boolean;
    validateIssuerName?: boolean;

    constructor(data?: IIdentityOAuthSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableOAuthLogin = _data["enableOAuthLogin"];
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.authority = _data["authority"];
            this.scope = _data["scope"];
            this.requireHttpsMetadata = _data["requireHttpsMetadata"];
            this.validateEndpoints = _data["validateEndpoints"];
            this.validateIssuerName = _data["validateIssuerName"];
        }
    }

    static fromJS(data: any): IdentityOAuthSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityOAuthSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableOAuthLogin"] = this.enableOAuthLogin;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["scope"] = this.scope;
        data["requireHttpsMetadata"] = this.requireHttpsMetadata;
        data["validateEndpoints"] = this.validateEndpoints;
        data["validateIssuerName"] = this.validateIssuerName;
        return data;
    }
}

export interface IIdentityOAuthSettingsDto {
    enableOAuthLogin?: boolean;
    clientId: string;
    clientSecret?: string | undefined;
    authority: string;
    scope?: string | undefined;
    requireHttpsMetadata?: boolean;
    validateEndpoints?: boolean;
    validateIssuerName?: boolean;
}

export class IdentityPasswordSettingsDto implements IIdentityPasswordSettingsDto {
    requiredLength?: number;
    requiredUniqueChars?: number;
    requireNonAlphanumeric?: boolean;
    requireLowercase?: boolean;
    requireUppercase?: boolean;
    requireDigit?: boolean;

    constructor(data?: IIdentityPasswordSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requiredLength = _data["requiredLength"];
            this.requiredUniqueChars = _data["requiredUniqueChars"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireUppercase = _data["requireUppercase"];
            this.requireDigit = _data["requireDigit"];
        }
    }

    static fromJS(data: any): IdentityPasswordSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityPasswordSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requiredLength"] = this.requiredLength;
        data["requiredUniqueChars"] = this.requiredUniqueChars;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireLowercase"] = this.requireLowercase;
        data["requireUppercase"] = this.requireUppercase;
        data["requireDigit"] = this.requireDigit;
        return data;
    }
}

export interface IIdentityPasswordSettingsDto {
    requiredLength?: number;
    requiredUniqueChars?: number;
    requireNonAlphanumeric?: boolean;
    requireLowercase?: boolean;
    requireUppercase?: boolean;
    requireDigit?: boolean;
}

export class IdentityRoleClaimDto implements IIdentityRoleClaimDto {
    roleId?: string;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityRoleClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): IdentityRoleClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IIdentityRoleClaimDto {
    roleId?: string;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class IdentityRoleCreateDto implements IIdentityRoleCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    isDefault?: boolean;
    isPublic?: boolean;

    constructor(data?: IIdentityRoleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): IdentityRoleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        return data;
    }
}

export interface IIdentityRoleCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    isDefault?: boolean;
    isPublic?: boolean;
}

export class IdentityRoleDto implements IIdentityRoleDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    isDefault?: boolean;
    isStatic?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IIdentityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isStatic = _data["isStatic"];
            this.isPublic = _data["isPublic"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    isDefault?: boolean;
    isStatic?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | undefined;
}

export class IdentityRoleLookupDto implements IIdentityRoleLookupDto {
    id?: string;
    name?: string | undefined;

    constructor(data?: IIdentityRoleLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdentityRoleLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IIdentityRoleLookupDto {
    id?: string;
    name?: string | undefined;
}

export class IdentityRoleUpdateDto implements IIdentityRoleUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    isDefault?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IIdentityRoleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    isDefault?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | undefined;
}

export class IdentitySecurityLogDto implements IIdentitySecurityLogDto {
    id?: string;
    tenantId?: string | undefined;
    applicationName?: string | undefined;
    identity?: string | undefined;
    action?: string | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    tenantName?: string | undefined;
    clientId?: string | undefined;
    correlationId?: string | undefined;
    clientIpAddress?: string | undefined;
    browserInfo?: string | undefined;
    creationTime?: Date;
    extraProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IIdentitySecurityLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.applicationName = _data["applicationName"];
            this.identity = _data["identity"];
            this.action = _data["action"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.tenantName = _data["tenantName"];
            this.clientId = _data["clientId"];
            this.correlationId = _data["correlationId"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.browserInfo = _data["browserInfo"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): IdentitySecurityLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentitySecurityLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["applicationName"] = this.applicationName;
        data["identity"] = this.identity;
        data["action"] = this.action;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["tenantName"] = this.tenantName;
        data["clientId"] = this.clientId;
        data["correlationId"] = this.correlationId;
        data["clientIpAddress"] = this.clientIpAddress;
        data["browserInfo"] = this.browserInfo;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IIdentitySecurityLogDto {
    id?: string;
    tenantId?: string | undefined;
    applicationName?: string | undefined;
    identity?: string | undefined;
    action?: string | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    tenantName?: string | undefined;
    clientId?: string | undefined;
    correlationId?: string | undefined;
    clientIpAddress?: string | undefined;
    browserInfo?: string | undefined;
    creationTime?: Date;
    extraProperties?: { [key: string]: any; } | undefined;
}

export class IdentitySettingsDto implements IIdentitySettingsDto {
    password?: IdentityPasswordSettingsDto;
    lockout?: IdentityLockoutSettingsDto;
    signIn?: IdentitySignInSettingsDto;
    user?: IdentityUserSettingsDto;

    constructor(data?: IIdentitySettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"] ? IdentityPasswordSettingsDto.fromJS(_data["password"]) : <any>undefined;
            this.lockout = _data["lockout"] ? IdentityLockoutSettingsDto.fromJS(_data["lockout"]) : <any>undefined;
            this.signIn = _data["signIn"] ? IdentitySignInSettingsDto.fromJS(_data["signIn"]) : <any>undefined;
            this.user = _data["user"] ? IdentityUserSettingsDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IdentitySettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentitySettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password ? this.password.toJSON() : <any>undefined;
        data["lockout"] = this.lockout ? this.lockout.toJSON() : <any>undefined;
        data["signIn"] = this.signIn ? this.signIn.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIdentitySettingsDto {
    password?: IdentityPasswordSettingsDto;
    lockout?: IdentityLockoutSettingsDto;
    signIn?: IdentitySignInSettingsDto;
    user?: IdentityUserSettingsDto;
}

export class IdentitySignInSettingsDto implements IIdentitySignInSettingsDto {
    requireConfirmedEmail?: boolean;
    enablePhoneNumberConfirmation?: boolean;
    requireConfirmedPhoneNumber?: boolean;

    constructor(data?: IIdentitySignInSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requireConfirmedEmail = _data["requireConfirmedEmail"];
            this.enablePhoneNumberConfirmation = _data["enablePhoneNumberConfirmation"];
            this.requireConfirmedPhoneNumber = _data["requireConfirmedPhoneNumber"];
        }
    }

    static fromJS(data: any): IdentitySignInSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentitySignInSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireConfirmedEmail"] = this.requireConfirmedEmail;
        data["enablePhoneNumberConfirmation"] = this.enablePhoneNumberConfirmation;
        data["requireConfirmedPhoneNumber"] = this.requireConfirmedPhoneNumber;
        return data;
    }
}

export interface IIdentitySignInSettingsDto {
    requireConfirmedEmail?: boolean;
    enablePhoneNumberConfirmation?: boolean;
    requireConfirmedPhoneNumber?: boolean;
}

export class IdentityUserClaimDto implements IIdentityUserClaimDto {
    userId?: string;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityUserClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): IdentityUserClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IIdentityUserClaimDto {
    userId?: string;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class IdentityUserCreateDto implements IIdentityUserCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName!: string;
    name?: string | undefined;
    surname?: string | undefined;
    email!: string;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | undefined;
    organizationUnitIds?: string[] | undefined;
    password!: string;
    sendConfirmationEmail?: boolean;

    constructor(data?: IIdentityUserCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            if (Array.isArray(_data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of _data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
            this.password = _data["password"];
            this.sendConfirmationEmail = _data["sendConfirmationEmail"];
        }
    }

    static fromJS(data: any): IdentityUserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        data["password"] = this.password;
        data["sendConfirmationEmail"] = this.sendConfirmationEmail;
        return data;
    }
}

export interface IIdentityUserCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName: string;
    name?: string | undefined;
    surname?: string | undefined;
    email: string;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | undefined;
    organizationUnitIds?: string[] | undefined;
    password: string;
    sendConfirmationEmail?: boolean;
}

export class IdentityUserDto implements IIdentityUserDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    tenantId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    supportTwoFactor?: boolean;
    twoFactorEnabled?: boolean;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    isLockedOut?: boolean;
    lockoutEnd?: Date | undefined;
    concurrencyStamp?: string | undefined;
    roleNames?: string[] | undefined;
    accessFailedCount?: number;

    constructor(data?: IIdentityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.supportTwoFactor = _data["supportTwoFactor"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.isLockedOut = _data["isLockedOut"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["supportTwoFactor"] = this.supportTwoFactor;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["isLockedOut"] = this.isLockedOut;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    tenantId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    supportTwoFactor?: boolean;
    twoFactorEnabled?: boolean;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    isLockedOut?: boolean;
    lockoutEnd?: Date | undefined;
    concurrencyStamp?: string | undefined;
    roleNames?: string[] | undefined;
    accessFailedCount?: number;
}

export class IdentityUserSettingsDto implements IIdentityUserSettingsDto {
    isUserNameUpdateEnabled?: boolean;
    isEmailUpdateEnabled?: boolean;

    constructor(data?: IIdentityUserSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserNameUpdateEnabled = _data["isUserNameUpdateEnabled"];
            this.isEmailUpdateEnabled = _data["isEmailUpdateEnabled"];
        }
    }

    static fromJS(data: any): IdentityUserSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserNameUpdateEnabled"] = this.isUserNameUpdateEnabled;
        data["isEmailUpdateEnabled"] = this.isEmailUpdateEnabled;
        return data;
    }
}

export interface IIdentityUserSettingsDto {
    isUserNameUpdateEnabled?: boolean;
    isEmailUpdateEnabled?: boolean;
}

export class IdentityUserUpdateDto implements IIdentityUserUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName!: string;
    name?: string | undefined;
    surname?: string | undefined;
    email!: string;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | undefined;
    organizationUnitIds?: string[] | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IIdentityUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            if (Array.isArray(_data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of _data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityUserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityUserUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName: string;
    name?: string | undefined;
    surname?: string | undefined;
    email: string;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | undefined;
    organizationUnitIds?: string[] | undefined;
    concurrencyStamp?: string | undefined;
}

export class IdentityUserUpdatePasswordInput implements IIdentityUserUpdatePasswordInput {
    newPassword!: string;

    constructor(data?: IIdentityUserUpdatePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): IdentityUserUpdatePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdatePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IIdentityUserUpdatePasswordInput {
    newPassword: string;
}

export class IdentityUserUpdateRolesDto implements IIdentityUserUpdateRolesDto {
    roleNames!: string[];

    constructor(data?: IIdentityUserUpdateRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityUserUpdateRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }
}

export interface IIdentityUserUpdateRolesDto {
    roleNames: string[];
}

export class ImportExternalUserInput implements IImportExternalUserInput {
    provider!: string;
    userNameOrEmailAddress!: string;
    password?: string | undefined;

    constructor(data?: IImportExternalUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ImportExternalUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportExternalUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface IImportExternalUserInput {
    provider: string;
    userNameOrEmailAddress: string;
    password?: string | undefined;
}

export class OrganizationUnitCreateDto implements IOrganizationUnitCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName!: string;
    parentId?: string | undefined;

    constructor(data?: IOrganizationUnitCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): OrganizationUnitCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IOrganizationUnitCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName: string;
    parentId?: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    roles?: OrganizationUnitRoleDto[] | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(OrganizationUnitRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationUnitDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    roles?: OrganizationUnitRoleDto[] | undefined;
}

export class OrganizationUnitLookupDto implements IOrganizationUnitLookupDto {
    id?: string;
    displayName?: string | undefined;

    constructor(data?: IOrganizationUnitLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): OrganizationUnitLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IOrganizationUnitLookupDto {
    id?: string;
    displayName?: string | undefined;
}

export class OrganizationUnitMoveInput implements IOrganizationUnitMoveInput {
    newParentId?: string | undefined;

    constructor(data?: IOrganizationUnitMoveInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): OrganizationUnitMoveInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitMoveInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newParentId"] = this.newParentId;
        return data;
    }
}

export interface IOrganizationUnitMoveInput {
    newParentId?: string | undefined;
}

export class OrganizationUnitRoleDto implements IOrganizationUnitRoleDto {
    creationTime?: Date;
    creatorId?: string | undefined;
    organizationUnitId?: string;
    roleId?: string;

    constructor(data?: IOrganizationUnitRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IOrganizationUnitRoleDto {
    creationTime?: Date;
    creatorId?: string | undefined;
    organizationUnitId?: string;
    roleId?: string;
}

export class OrganizationUnitRoleInput implements IOrganizationUnitRoleInput {
    roleIds?: string[] | undefined;

    constructor(data?: IOrganizationUnitRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): OrganizationUnitRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        return data;
    }
}

export interface IOrganizationUnitRoleInput {
    roleIds?: string[] | undefined;
}

export class OrganizationUnitUpdateDto implements IOrganizationUnitUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: IOrganizationUnitUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): OrganizationUnitUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IOrganizationUnitUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName: string;
    concurrencyStamp?: string | undefined;
}

export class OrganizationUnitUserInput implements IOrganizationUnitUserInput {
    userIds?: string[] | undefined;

    constructor(data?: IOrganizationUnitUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): OrganizationUnitUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface IOrganizationUnitUserInput {
    userIds?: string[] | undefined;
}

export class OrganizationUnitWithDetailsDto implements IOrganizationUnitWithDetailsDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    roles?: IdentityRoleDto[] | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IOrganizationUnitWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(IdentityRoleDto.fromJS(item));
            }
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): OrganizationUnitWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IOrganizationUnitWithDetailsDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    roles?: IdentityRoleDto[] | undefined;
    concurrencyStamp?: string | undefined;
}

export class UpdateClaimTypeDto implements IUpdateClaimTypeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    required?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateClaimTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.required = _data["required"];
            this.regex = _data["regex"];
            this.regexDescription = _data["regexDescription"];
            this.description = _data["description"];
            this.valueType = _data["valueType"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateClaimTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClaimTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["required"] = this.required;
        data["regex"] = this.regex;
        data["regexDescription"] = this.regexDescription;
        data["description"] = this.description;
        data["valueType"] = this.valueType;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateClaimTypeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    required?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
    concurrencyStamp?: string | undefined;
}

export class CreateLanguageDto implements ICreateLanguageDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName?: string | undefined;
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;

    constructor(data?: ICreateLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): CreateLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface ICreateLanguageDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName?: string | undefined;
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
}

export class CultureInfoDto implements ICultureInfoDto {
    displayName?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICultureInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CultureInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CultureInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICultureInfoDto {
    displayName?: string | undefined;
    name?: string | undefined;
}

export class LanguageDto implements ILanguageDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    displayName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
    isDefaultLanguage?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: ILanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
            this.isDefaultLanguage = _data["isDefaultLanguage"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): LanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        data["isDefaultLanguage"] = this.isDefaultLanguage;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ILanguageDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    displayName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
    isDefaultLanguage?: boolean;
    concurrencyStamp?: string | undefined;
}

export class LanguageResourceDto implements ILanguageResourceDto {
    name?: string | undefined;

    constructor(data?: ILanguageResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LanguageResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ILanguageResourceDto {
    name?: string | undefined;
}

export class LanguageTextDto implements ILanguageTextDto {
    resourceName?: string | undefined;
    cultureName?: string | undefined;
    baseCultureName?: string | undefined;
    baseValue?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: ILanguageTextDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceName = _data["resourceName"];
            this.cultureName = _data["cultureName"];
            this.baseCultureName = _data["baseCultureName"];
            this.baseValue = _data["baseValue"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LanguageTextDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceName"] = this.resourceName;
        data["cultureName"] = this.cultureName;
        data["baseCultureName"] = this.baseCultureName;
        data["baseValue"] = this.baseValue;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ILanguageTextDto {
    resourceName?: string | undefined;
    cultureName?: string | undefined;
    baseCultureName?: string | undefined;
    baseValue?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
}

export class UpdateLanguageDto implements IUpdateLanguageDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateLanguageDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
    concurrencyStamp?: string | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    displayName?: string | undefined;
    readonly twoLetterISOLanguageName?: string | undefined;
    flagIcon?: string | undefined;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            (<any>this).twoLetterISOLanguageName = _data["twoLetterISOLanguageName"];
            this.flagIcon = _data["flagIcon"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName;
        data["flagIcon"] = this.flagIcon;
        return data;
    }
}

export interface ILanguageInfo {
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    displayName?: string | undefined;
    twoLetterISOLanguageName?: string | undefined;
    flagIcon?: string | undefined;
}

export class NameValue implements INameValue {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name?: string | undefined;
    value?: string | undefined;
}

export class ApplicationDto implements IApplicationDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    clientId?: string | undefined;
    displayName?: string | undefined;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;

    constructor(data?: IApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.clientSecret = _data["clientSecret"];
            this.consentType = _data["consentType"];
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            this.allowPasswordFlow = _data["allowPasswordFlow"];
            this.allowClientCredentialsFlow = _data["allowClientCredentialsFlow"];
            this.allowAuthorizationCodeFlow = _data["allowAuthorizationCodeFlow"];
            this.allowRefreshTokenFlow = _data["allowRefreshTokenFlow"];
            this.allowHybridFlow = _data["allowHybridFlow"];
            this.allowImplicitFlow = _data["allowImplicitFlow"];
            this.allowLogoutEndpoint = _data["allowLogoutEndpoint"];
            this.allowDeviceEndpoint = _data["allowDeviceEndpoint"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
        }
    }

    static fromJS(data: any): ApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["clientSecret"] = this.clientSecret;
        data["consentType"] = this.consentType;
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        data["allowPasswordFlow"] = this.allowPasswordFlow;
        data["allowClientCredentialsFlow"] = this.allowClientCredentialsFlow;
        data["allowAuthorizationCodeFlow"] = this.allowAuthorizationCodeFlow;
        data["allowRefreshTokenFlow"] = this.allowRefreshTokenFlow;
        data["allowHybridFlow"] = this.allowHybridFlow;
        data["allowImplicitFlow"] = this.allowImplicitFlow;
        data["allowLogoutEndpoint"] = this.allowLogoutEndpoint;
        data["allowDeviceEndpoint"] = this.allowDeviceEndpoint;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        return data;
    }
}

export interface IApplicationDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    clientId?: string | undefined;
    displayName?: string | undefined;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
}

export class CreateApplicationInput implements ICreateApplicationInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    clientId!: string;
    displayName!: string;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;

    constructor(data?: ICreateApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.clientId = _data["clientId"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.clientSecret = _data["clientSecret"];
            this.consentType = _data["consentType"];
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            this.allowPasswordFlow = _data["allowPasswordFlow"];
            this.allowClientCredentialsFlow = _data["allowClientCredentialsFlow"];
            this.allowAuthorizationCodeFlow = _data["allowAuthorizationCodeFlow"];
            this.allowRefreshTokenFlow = _data["allowRefreshTokenFlow"];
            this.allowHybridFlow = _data["allowHybridFlow"];
            this.allowImplicitFlow = _data["allowImplicitFlow"];
            this.allowLogoutEndpoint = _data["allowLogoutEndpoint"];
            this.allowDeviceEndpoint = _data["allowDeviceEndpoint"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
        }
    }

    static fromJS(data: any): CreateApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["clientId"] = this.clientId;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["clientSecret"] = this.clientSecret;
        data["consentType"] = this.consentType;
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        data["allowPasswordFlow"] = this.allowPasswordFlow;
        data["allowClientCredentialsFlow"] = this.allowClientCredentialsFlow;
        data["allowAuthorizationCodeFlow"] = this.allowAuthorizationCodeFlow;
        data["allowRefreshTokenFlow"] = this.allowRefreshTokenFlow;
        data["allowHybridFlow"] = this.allowHybridFlow;
        data["allowImplicitFlow"] = this.allowImplicitFlow;
        data["allowLogoutEndpoint"] = this.allowLogoutEndpoint;
        data["allowDeviceEndpoint"] = this.allowDeviceEndpoint;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        return data;
    }
}

export interface ICreateApplicationInput {
    extraProperties?: { [key: string]: any; } | undefined;
    clientId: string;
    displayName: string;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
}

export class UpdateApplicationInput implements IUpdateApplicationInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    clientId!: string;
    displayName!: string;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;

    constructor(data?: IUpdateApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.clientId = _data["clientId"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.clientSecret = _data["clientSecret"];
            this.consentType = _data["consentType"];
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            this.allowPasswordFlow = _data["allowPasswordFlow"];
            this.allowClientCredentialsFlow = _data["allowClientCredentialsFlow"];
            this.allowAuthorizationCodeFlow = _data["allowAuthorizationCodeFlow"];
            this.allowRefreshTokenFlow = _data["allowRefreshTokenFlow"];
            this.allowHybridFlow = _data["allowHybridFlow"];
            this.allowImplicitFlow = _data["allowImplicitFlow"];
            this.allowLogoutEndpoint = _data["allowLogoutEndpoint"];
            this.allowDeviceEndpoint = _data["allowDeviceEndpoint"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
        }
    }

    static fromJS(data: any): UpdateApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["clientId"] = this.clientId;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["clientSecret"] = this.clientSecret;
        data["consentType"] = this.consentType;
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        data["allowPasswordFlow"] = this.allowPasswordFlow;
        data["allowClientCredentialsFlow"] = this.allowClientCredentialsFlow;
        data["allowAuthorizationCodeFlow"] = this.allowAuthorizationCodeFlow;
        data["allowRefreshTokenFlow"] = this.allowRefreshTokenFlow;
        data["allowHybridFlow"] = this.allowHybridFlow;
        data["allowImplicitFlow"] = this.allowImplicitFlow;
        data["allowLogoutEndpoint"] = this.allowLogoutEndpoint;
        data["allowDeviceEndpoint"] = this.allowDeviceEndpoint;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        return data;
    }
}

export interface IUpdateApplicationInput {
    extraProperties?: { [key: string]: any; } | undefined;
    clientId: string;
    displayName: string;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
}

export class CreateScopeInput implements ICreateScopeInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    displayName?: string | undefined;
    description?: string | undefined;
    resources?: string[] | undefined;

    constructor(data?: ICreateScopeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateScopeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScopeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item);
        }
        return data;
    }
}

export interface ICreateScopeInput {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    displayName?: string | undefined;
    description?: string | undefined;
    resources?: string[] | undefined;
}

export class ScopeDto implements IScopeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    buildIn?: boolean;
    resources?: string[] | undefined;

    constructor(data?: IScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.buildIn = _data["buildIn"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(item);
            }
        }
    }

    static fromJS(data: any): ScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["buildIn"] = this.buildIn;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item);
        }
        return data;
    }
}

export interface IScopeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    buildIn?: boolean;
    resources?: string[] | undefined;
}

export class UpdateScopeInput implements IUpdateScopeInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    displayName?: string | undefined;
    description?: string | undefined;
    resources?: string[] | undefined;

    constructor(data?: IUpdateScopeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateScopeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScopeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item);
        }
        return data;
    }
}

export interface IUpdateScopeInput {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    displayName?: string | undefined;
    description?: string | undefined;
    resources?: string[] | undefined;
}

export class GetPermissionListResultDto implements IGetPermissionListResultDto {
    entityDisplayName?: string | undefined;
    groups?: PermissionGroupDto[] | undefined;

    constructor(data?: IGetPermissionListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDisplayName = _data["entityDisplayName"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(PermissionGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPermissionListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDisplayName"] = this.entityDisplayName;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPermissionListResultDto {
    entityDisplayName?: string | undefined;
    groups?: PermissionGroupDto[] | undefined;
}

export class PermissionGrantInfoDto implements IPermissionGrantInfoDto {
    name?: string | undefined;
    displayName?: string | undefined;
    parentName?: string | undefined;
    isGranted?: boolean;
    allowedProviders?: string[] | undefined;
    grantedProviders?: ProviderInfoDto[] | undefined;

    constructor(data?: IPermissionGrantInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.parentName = _data["parentName"];
            this.isGranted = _data["isGranted"];
            if (Array.isArray(_data["allowedProviders"])) {
                this.allowedProviders = [] as any;
                for (let item of _data["allowedProviders"])
                    this.allowedProviders!.push(item);
            }
            if (Array.isArray(_data["grantedProviders"])) {
                this.grantedProviders = [] as any;
                for (let item of _data["grantedProviders"])
                    this.grantedProviders!.push(ProviderInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGrantInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrantInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["parentName"] = this.parentName;
        data["isGranted"] = this.isGranted;
        if (Array.isArray(this.allowedProviders)) {
            data["allowedProviders"] = [];
            for (let item of this.allowedProviders)
                data["allowedProviders"].push(item);
        }
        if (Array.isArray(this.grantedProviders)) {
            data["grantedProviders"] = [];
            for (let item of this.grantedProviders)
                data["grantedProviders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGrantInfoDto {
    name?: string | undefined;
    displayName?: string | undefined;
    parentName?: string | undefined;
    isGranted?: boolean;
    allowedProviders?: string[] | undefined;
    grantedProviders?: ProviderInfoDto[] | undefined;
}

export class PermissionGroupDto implements IPermissionGroupDto {
    name?: string | undefined;
    displayName?: string | undefined;
    displayNameKey?: string | undefined;
    displayNameResource?: string | undefined;
    permissions?: PermissionGrantInfoDto[] | undefined;

    constructor(data?: IPermissionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.displayNameKey = _data["displayNameKey"];
            this.displayNameResource = _data["displayNameResource"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionGrantInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["displayNameKey"] = this.displayNameKey;
        data["displayNameResource"] = this.displayNameResource;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGroupDto {
    name?: string | undefined;
    displayName?: string | undefined;
    displayNameKey?: string | undefined;
    displayNameResource?: string | undefined;
    permissions?: PermissionGrantInfoDto[] | undefined;
}

export class ProviderInfoDto implements IProviderInfoDto {
    providerName?: string | undefined;
    providerKey?: string | undefined;

    constructor(data?: IProviderInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): ProviderInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        return data;
    }
}

export interface IProviderInfoDto {
    providerName?: string | undefined;
    providerKey?: string | undefined;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
    name?: string | undefined;
    isGranted?: boolean;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        return data;
    }
}

export interface IUpdatePermissionDto {
    name?: string | undefined;
    isGranted?: boolean;
}

export class UpdatePermissionsDto implements IUpdatePermissionsDto {
    permissions?: UpdatePermissionDto[] | undefined;

    constructor(data?: IUpdatePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UpdatePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdatePermissionsDto {
    permissions?: UpdatePermissionDto[] | undefined;
}

export class EmailSettingsDto implements IEmailSettingsDto {
    smtpHost?: string | undefined;
    smtpPort?: number;
    smtpUserName?: string | undefined;
    smtpPassword?: string | undefined;
    smtpDomain?: string | undefined;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress?: string | undefined;
    defaultFromDisplayName?: string | undefined;

    constructor(data?: IEmailSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): EmailSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data;
    }
}

export interface IEmailSettingsDto {
    smtpHost?: string | undefined;
    smtpPort?: number;
    smtpUserName?: string | undefined;
    smtpPassword?: string | undefined;
    smtpDomain?: string | undefined;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress?: string | undefined;
    defaultFromDisplayName?: string | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    senderEmailAddress!: string;
    targetEmailAddress!: string;
    subject!: string;
    body?: string | undefined;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderEmailAddress = _data["senderEmailAddress"];
            this.targetEmailAddress = _data["targetEmailAddress"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderEmailAddress"] = this.senderEmailAddress;
        data["targetEmailAddress"] = this.targetEmailAddress;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data;
    }
}

export interface ISendTestEmailInput {
    senderEmailAddress: string;
    targetEmailAddress: string;
    subject: string;
    body?: string | undefined;
}

export class UpdateEmailSettingsDto implements IUpdateEmailSettingsDto {
    smtpHost?: string | undefined;
    smtpPort?: number;
    smtpUserName?: string | undefined;
    smtpPassword?: string | undefined;
    smtpDomain?: string | undefined;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress!: string;
    defaultFromDisplayName!: string;

    constructor(data?: IUpdateEmailSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): UpdateEmailSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data;
    }
}

export interface IUpdateEmailSettingsDto {
    smtpHost?: string | undefined;
    smtpPort?: number;
    smtpUserName?: string | undefined;
    smtpPassword?: string | undefined;
    smtpDomain?: string | undefined;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress: string;
    defaultFromDisplayName: string;
}

export class RestoreTemplateContentInput implements IRestoreTemplateContentInput {
    templateName!: string;
    cultureName?: string | undefined;

    constructor(data?: IRestoreTemplateContentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            this.cultureName = _data["cultureName"];
        }
    }

    static fromJS(data: any): RestoreTemplateContentInput {
        data = typeof data === 'object' ? data : {};
        let result = new RestoreTemplateContentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["cultureName"] = this.cultureName;
        return data;
    }
}

export interface IRestoreTemplateContentInput {
    templateName: string;
    cultureName?: string | undefined;
}

export class TemplateDefinitionDto implements ITemplateDefinitionDto {
    name?: string | undefined;
    displayName?: string | undefined;
    isLayout?: boolean;
    layout?: string | undefined;
    isInlineLocalized?: boolean;
    defaultCultureName?: string | undefined;

    constructor(data?: ITemplateDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isLayout = _data["isLayout"];
            this.layout = _data["layout"];
            this.isInlineLocalized = _data["isInlineLocalized"];
            this.defaultCultureName = _data["defaultCultureName"];
        }
    }

    static fromJS(data: any): TemplateDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isLayout"] = this.isLayout;
        data["layout"] = this.layout;
        data["isInlineLocalized"] = this.isInlineLocalized;
        data["defaultCultureName"] = this.defaultCultureName;
        return data;
    }
}

export interface ITemplateDefinitionDto {
    name?: string | undefined;
    displayName?: string | undefined;
    isLayout?: boolean;
    layout?: string | undefined;
    isInlineLocalized?: boolean;
    defaultCultureName?: string | undefined;
}

export class TextTemplateContentDto implements ITextTemplateContentDto {
    name?: string | undefined;
    cultureName?: string | undefined;
    content?: string | undefined;

    constructor(data?: ITextTemplateContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.cultureName = _data["cultureName"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): TextTemplateContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextTemplateContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["cultureName"] = this.cultureName;
        data["content"] = this.content;
        return data;
    }
}

export interface ITextTemplateContentDto {
    name?: string | undefined;
    cultureName?: string | undefined;
    content?: string | undefined;
}

export class UpdateTemplateContentInput implements IUpdateTemplateContentInput {
    templateName!: string;
    cultureName?: string | undefined;
    content?: string | undefined;

    constructor(data?: IUpdateTemplateContentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            this.cultureName = _data["cultureName"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): UpdateTemplateContentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTemplateContentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["cultureName"] = this.cultureName;
        data["content"] = this.content;
        return data;
    }
}

export interface IUpdateTemplateContentInput {
    templateName: string;
    cultureName?: string | undefined;
    content?: string | undefined;
}

export class UserData implements IUserData {
    id?: string;
    tenantId?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    isActive?: boolean;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.isActive = _data["isActive"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
        }
    }

    static fromJS(data: any): UserData {
        data = typeof data === 'object' ? data : {};
        let result = new UserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["isActive"] = this.isActive;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        return data;
    }
}

export interface IUserData {
    id?: string;
    tenantId?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    isActive?: boolean;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
}

export class IStringValueType implements IIStringValueType {
    readonly name?: string | undefined;
    readonly properties?: { [key: string]: any; } | undefined;
    validator?: IValueValidator;

    constructor(data?: IIStringValueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IStringValueType {
        data = typeof data === 'object' ? data : {};
        let result = new IStringValueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIStringValueType {
    name?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
    validator?: IValueValidator;
}

export class IValueValidator implements IIValueValidator {
    readonly name?: string | undefined;
    readonly properties?: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
}

export class CreateBlogDto implements ICreateBlogDto {
    name!: string;
    shortName!: string;
    description?: string | undefined;

    constructor(data?: ICreateBlogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateBlogDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBlogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateBlogDto {
    name: string;
    shortName: string;
    description?: string | undefined;
}

export class UpdateBlogDto implements IUpdateBlogDto {
    name!: string;
    shortName!: string;
    description?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateBlogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.description = _data["description"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateBlogDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBlogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["description"] = this.description;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateBlogDto {
    name: string;
    shortName: string;
    description?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class BlogDto implements IBlogDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    name?: string | undefined;
    shortName?: string | undefined;
    description?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IBlogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.description = _data["description"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): BlogDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["description"] = this.description;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IBlogDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    name?: string | undefined;
    shortName?: string | undefined;
    description?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class CommentWithDetailsDto implements ICommentWithDetailsDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    repliedCommentId?: string | undefined;
    text?: string | undefined;
    writer?: BlogUserDto;
    concurrencyStamp?: string | undefined;

    constructor(data?: ICommentWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.repliedCommentId = _data["repliedCommentId"];
            this.text = _data["text"];
            this.writer = _data["writer"] ? BlogUserDto.fromJS(_data["writer"]) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): CommentWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["repliedCommentId"] = this.repliedCommentId;
        data["text"] = this.text;
        data["writer"] = this.writer ? this.writer.toJSON() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ICommentWithDetailsDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    repliedCommentId?: string | undefined;
    text?: string | undefined;
    writer?: BlogUserDto;
    concurrencyStamp?: string | undefined;
}

export class CommentWithRepliesDto implements ICommentWithRepliesDto {
    comment?: CommentWithDetailsDto;
    replies?: CommentWithDetailsDto[] | undefined;

    constructor(data?: ICommentWithRepliesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"] ? CommentWithDetailsDto.fromJS(_data["comment"]) : <any>undefined;
            if (Array.isArray(_data["replies"])) {
                this.replies = [] as any;
                for (let item of _data["replies"])
                    this.replies!.push(CommentWithDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommentWithRepliesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentWithRepliesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        if (Array.isArray(this.replies)) {
            data["replies"] = [];
            for (let item of this.replies)
                data["replies"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICommentWithRepliesDto {
    comment?: CommentWithDetailsDto;
    replies?: CommentWithDetailsDto[] | undefined;
}

export class CreateCommentDto implements ICreateCommentDto {
    repliedCommentId?: string | undefined;
    postId?: string;
    text!: string;

    constructor(data?: ICreateCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repliedCommentId = _data["repliedCommentId"];
            this.postId = _data["postId"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): CreateCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repliedCommentId"] = this.repliedCommentId;
        data["postId"] = this.postId;
        data["text"] = this.text;
        return data;
    }
}

export interface ICreateCommentDto {
    repliedCommentId?: string | undefined;
    postId?: string;
    text: string;
}

export class UpdateCommentDto implements IUpdateCommentDto {
    text!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateCommentDto {
    text: string;
    concurrencyStamp?: string | undefined;
}

export class FileUploadOutputDto implements IFileUploadOutputDto {
    name?: string | undefined;
    webUrl?: string | undefined;

    constructor(data?: IFileUploadOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.webUrl = _data["webUrl"];
        }
    }

    static fromJS(data: any): FileUploadOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["webUrl"] = this.webUrl;
        return data;
    }
}

export interface IFileUploadOutputDto {
    name?: string | undefined;
    webUrl?: string | undefined;
}

export class RawFileDto implements IRawFileDto {
    bytes?: string | undefined;
    readonly isFileEmpty?: boolean;

    constructor(data?: IRawFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bytes = _data["bytes"];
            (<any>this).isFileEmpty = _data["isFileEmpty"];
        }
    }

    static fromJS(data: any): RawFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new RawFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bytes"] = this.bytes;
        data["isFileEmpty"] = this.isFileEmpty;
        return data;
    }
}

export interface IRawFileDto {
    bytes?: string | undefined;
    isFileEmpty?: boolean;
}

export class BlogUserDto implements IBlogUserDto {
    id?: string;
    tenantId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    extraProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IBlogUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): BlogUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IBlogUserDto {
    id?: string;
    tenantId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    extraProperties?: { [key: string]: any; } | undefined;
}

export class CreatePostDto implements ICreatePostDto {
    blogId?: string;
    title!: string;
    coverImage!: string;
    url!: string;
    content!: string;
    tags?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreatePostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blogId = _data["blogId"];
            this.title = _data["title"];
            this.coverImage = _data["coverImage"];
            this.url = _data["url"];
            this.content = _data["content"];
            this.tags = _data["tags"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreatePostDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blogId"] = this.blogId;
        data["title"] = this.title;
        data["coverImage"] = this.coverImage;
        data["url"] = this.url;
        data["content"] = this.content;
        data["tags"] = this.tags;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreatePostDto {
    blogId?: string;
    title: string;
    coverImage: string;
    url: string;
    content: string;
    tags?: string | undefined;
    description?: string | undefined;
}

export class PostWithDetailsDto implements IPostWithDetailsDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    blogId?: string;
    title?: string | undefined;
    coverImage?: string | undefined;
    url?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    readCount?: number;
    commentCount?: number;
    writer?: BlogUserDto;
    tags?: TagDto[] | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IPostWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.blogId = _data["blogId"];
            this.title = _data["title"];
            this.coverImage = _data["coverImage"];
            this.url = _data["url"];
            this.content = _data["content"];
            this.description = _data["description"];
            this.readCount = _data["readCount"];
            this.commentCount = _data["commentCount"];
            this.writer = _data["writer"] ? BlogUserDto.fromJS(_data["writer"]) : <any>undefined;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagDto.fromJS(item));
            }
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): PostWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["blogId"] = this.blogId;
        data["title"] = this.title;
        data["coverImage"] = this.coverImage;
        data["url"] = this.url;
        data["content"] = this.content;
        data["description"] = this.description;
        data["readCount"] = this.readCount;
        data["commentCount"] = this.commentCount;
        data["writer"] = this.writer ? this.writer.toJSON() : <any>undefined;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IPostWithDetailsDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    blogId?: string;
    title?: string | undefined;
    coverImage?: string | undefined;
    url?: string | undefined;
    content?: string | undefined;
    description?: string | undefined;
    readCount?: number;
    commentCount?: number;
    writer?: BlogUserDto;
    tags?: TagDto[] | undefined;
    concurrencyStamp?: string | undefined;
}

export class UpdatePostDto implements IUpdatePostDto {
    blogId?: string;
    title!: string;
    coverImage!: string;
    url!: string;
    content!: string;
    description?: string | undefined;
    tags?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdatePostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blogId = _data["blogId"];
            this.title = _data["title"];
            this.coverImage = _data["coverImage"];
            this.url = _data["url"];
            this.content = _data["content"];
            this.description = _data["description"];
            this.tags = _data["tags"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdatePostDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blogId"] = this.blogId;
        data["title"] = this.title;
        data["coverImage"] = this.coverImage;
        data["url"] = this.url;
        data["content"] = this.content;
        data["description"] = this.description;
        data["tags"] = this.tags;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdatePostDto {
    blogId?: string;
    title: string;
    coverImage: string;
    url: string;
    content: string;
    description?: string | undefined;
    tags?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class TagDto implements ITagDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    name?: string | undefined;
    description?: string | undefined;
    usageCount?: number;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.usageCount = _data["usageCount"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["usageCount"] = this.usageCount;
        return data;
    }
}

export interface ITagDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    name?: string | undefined;
    description?: string | undefined;
    usageCount?: number;
}

export class ChatConversationDto implements IChatConversationDto {
    messages?: ChatMessageDto[] | undefined;
    targetUserInfo?: ChatTargetUserInfo;

    constructor(data?: IChatConversationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(ChatMessageDto.fromJS(item));
            }
            this.targetUserInfo = _data["targetUserInfo"] ? ChatTargetUserInfo.fromJS(_data["targetUserInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatConversationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatConversationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["targetUserInfo"] = this.targetUserInfo ? this.targetUserInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChatConversationDto {
    messages?: ChatMessageDto[] | undefined;
    targetUserInfo?: ChatTargetUserInfo;
}

export class MarkConversationAsReadInput implements IMarkConversationAsReadInput {
    targetUserId?: string;

    constructor(data?: IMarkConversationAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): MarkConversationAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkConversationAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        return data;
    }
}

export interface IMarkConversationAsReadInput {
    targetUserId?: string;
}

export class ChatMessageDto implements IChatMessageDto {
    message?: string | undefined;
    messageDate?: Date;
    isRead?: boolean;
    readDate?: Date;
    side?: ChatMessageSide;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.messageDate = _data["messageDate"] ? new Date(_data["messageDate"].toString()) : <any>undefined;
            this.isRead = _data["isRead"];
            this.readDate = _data["readDate"] ? new Date(_data["readDate"].toString()) : <any>undefined;
            this.side = _data["side"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["messageDate"] = this.messageDate ? this.messageDate.toISOString() : <any>undefined;
        data["isRead"] = this.isRead;
        data["readDate"] = this.readDate ? this.readDate.toISOString() : <any>undefined;
        data["side"] = this.side;
        return data;
    }
}

export interface IChatMessageDto {
    message?: string | undefined;
    messageDate?: Date;
    isRead?: boolean;
    readDate?: Date;
    side?: ChatMessageSide;
}

export enum ChatMessageSide {
    _1 = 1,
    _2 = 2,
}

export class SendMessageInput implements ISendMessageInput {
    targetUserId?: string;
    message!: string;

    constructor(data?: ISendMessageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SendMessageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendMessageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["message"] = this.message;
        return data;
    }
}

export interface ISendMessageInput {
    targetUserId?: string;
    message: string;
}

export class SendOnEnterSettingDto implements ISendOnEnterSettingDto {
    sendOnEnter?: boolean;

    constructor(data?: ISendOnEnterSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sendOnEnter = _data["sendOnEnter"];
        }
    }

    static fromJS(data: any): SendOnEnterSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendOnEnterSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sendOnEnter"] = this.sendOnEnter;
        return data;
    }
}

export interface ISendOnEnterSettingDto {
    sendOnEnter?: boolean;
}

export class ChatContactDto implements IChatContactDto {
    userId?: string;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
    lastMessageSide?: ChatMessageSide;
    lastMessage?: string | undefined;
    lastMessageDate?: Date | undefined;
    unreadMessageCount?: number;

    constructor(data?: IChatContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.username = _data["username"];
            this.lastMessageSide = _data["lastMessageSide"];
            this.lastMessage = _data["lastMessage"];
            this.lastMessageDate = _data["lastMessageDate"] ? new Date(_data["lastMessageDate"].toString()) : <any>undefined;
            this.unreadMessageCount = _data["unreadMessageCount"];
        }
    }

    static fromJS(data: any): ChatContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["username"] = this.username;
        data["lastMessageSide"] = this.lastMessageSide;
        data["lastMessage"] = this.lastMessage;
        data["lastMessageDate"] = this.lastMessageDate ? this.lastMessageDate.toISOString() : <any>undefined;
        data["unreadMessageCount"] = this.unreadMessageCount;
        return data;
    }
}

export interface IChatContactDto {
    userId?: string;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
    lastMessageSide?: ChatMessageSide;
    lastMessage?: string | undefined;
    lastMessageDate?: Date | undefined;
    unreadMessageCount?: number;
}

export class ChatTargetUserInfo implements IChatTargetUserInfo {
    userId?: string;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;

    constructor(data?: IChatTargetUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): ChatTargetUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ChatTargetUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["username"] = this.username;
        return data;
    }
}

export interface IChatTargetUserInfo {
    userId?: string;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
}

export class BlogDto2 implements IBlogDto2 {
    id?: string;
    name?: string | undefined;
    slug?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IBlogDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): BlogDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new BlogDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IBlogDto2 {
    id?: string;
    name?: string | undefined;
    slug?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class BlogFeatureInputDto implements IBlogFeatureInputDto {
    featureName!: string;
    isEnabled?: boolean;

    constructor(data?: IBlogFeatureInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.featureName = _data["featureName"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): BlogFeatureInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogFeatureInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["featureName"] = this.featureName;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IBlogFeatureInputDto {
    featureName: string;
    isEnabled?: boolean;
}

export class BlogPostDto implements IBlogPostDto {
    id?: string;
    blogId?: string;
    title?: string | undefined;
    slug?: string | undefined;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
    creationTime?: Date;
    lastModificationTime?: Date | undefined;
    concurrencyStamp?: string | undefined;
    status?: BlogPostStatus;

    constructor(data?: IBlogPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.blogId = _data["blogId"];
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.shortDescription = _data["shortDescription"];
            this.content = _data["content"];
            this.coverImageMediaId = _data["coverImageMediaId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): BlogPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["blogId"] = this.blogId;
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["shortDescription"] = this.shortDescription;
        data["content"] = this.content;
        data["coverImageMediaId"] = this.coverImageMediaId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["status"] = this.status;
        return data;
    }
}

export interface IBlogPostDto {
    id?: string;
    blogId?: string;
    title?: string | undefined;
    slug?: string | undefined;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
    creationTime?: Date;
    lastModificationTime?: Date | undefined;
    concurrencyStamp?: string | undefined;
    status?: BlogPostStatus;
}

export class BlogPostListDto implements IBlogPostListDto {
    id?: string;
    blogId?: string;
    blogName?: string | undefined;
    title?: string | undefined;
    slug?: string | undefined;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
    creationTime?: Date;
    lastModificationTime?: Date | undefined;
    status?: BlogPostStatus;

    constructor(data?: IBlogPostListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.blogId = _data["blogId"];
            this.blogName = _data["blogName"];
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.shortDescription = _data["shortDescription"];
            this.content = _data["content"];
            this.coverImageMediaId = _data["coverImageMediaId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): BlogPostListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogPostListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["blogId"] = this.blogId;
        data["blogName"] = this.blogName;
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["shortDescription"] = this.shortDescription;
        data["content"] = this.content;
        data["coverImageMediaId"] = this.coverImageMediaId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export interface IBlogPostListDto {
    id?: string;
    blogId?: string;
    blogName?: string | undefined;
    title?: string | undefined;
    slug?: string | undefined;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
    creationTime?: Date;
    lastModificationTime?: Date | undefined;
    status?: BlogPostStatus;
}

export class CreateBlogDto2 implements ICreateBlogDto2 {
    name!: string;
    slug!: string;

    constructor(data?: ICreateBlogDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): CreateBlogDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBlogDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        return data;
    }
}

export interface ICreateBlogDto2 {
    name: string;
    slug: string;
}

export class CreateBlogPostDto implements ICreateBlogPostDto {
    blogId!: string;
    title!: string;
    slug!: string;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;

    constructor(data?: ICreateBlogPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blogId = _data["blogId"];
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.shortDescription = _data["shortDescription"];
            this.content = _data["content"];
            this.coverImageMediaId = _data["coverImageMediaId"];
        }
    }

    static fromJS(data: any): CreateBlogPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBlogPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blogId"] = this.blogId;
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["shortDescription"] = this.shortDescription;
        data["content"] = this.content;
        data["coverImageMediaId"] = this.coverImageMediaId;
        return data;
    }
}

export interface ICreateBlogPostDto {
    blogId: string;
    title: string;
    slug: string;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
}

export class UpdateBlogDto2 implements IUpdateBlogDto2 {
    name!: string;
    slug!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateBlogDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateBlogDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBlogDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateBlogDto2 {
    name: string;
    slug: string;
    concurrencyStamp?: string | undefined;
}

export class UpdateBlogPostDto implements IUpdateBlogPostDto {
    title!: string;
    slug!: string;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateBlogPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.shortDescription = _data["shortDescription"];
            this.content = _data["content"];
            this.coverImageMediaId = _data["coverImageMediaId"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateBlogPostDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBlogPostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["shortDescription"] = this.shortDescription;
        data["content"] = this.content;
        data["coverImageMediaId"] = this.coverImageMediaId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateBlogPostDto {
    title: string;
    slug: string;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class CmsUserDto implements ICmsUserDto {
    id?: string;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;

    constructor(data?: ICmsUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
        }
    }

    static fromJS(data: any): CmsUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CmsUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        return data;
    }
}

export interface ICmsUserDto {
    id?: string;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
}

export class CommentWithAuthorDto implements ICommentWithAuthorDto {
    id?: string;
    entityType?: string | undefined;
    entityId?: string | undefined;
    text?: string | undefined;
    repliedCommentId?: string | undefined;
    creatorId?: string;
    creationTime?: Date;
    author?: CmsUserDto;

    constructor(data?: ICommentWithAuthorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.text = _data["text"];
            this.repliedCommentId = _data["repliedCommentId"];
            this.creatorId = _data["creatorId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.author = _data["author"] ? CmsUserDto.fromJS(_data["author"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentWithAuthorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentWithAuthorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["text"] = this.text;
        data["repliedCommentId"] = this.repliedCommentId;
        data["creatorId"] = this.creatorId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentWithAuthorDto {
    id?: string;
    entityType?: string | undefined;
    entityId?: string | undefined;
    text?: string | undefined;
    repliedCommentId?: string | undefined;
    creatorId?: string;
    creationTime?: Date;
    author?: CmsUserDto;
}

export class CmsKitContactSettingDto implements ICmsKitContactSettingDto {
    receiverEmailAddress?: string | undefined;

    constructor(data?: ICmsKitContactSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiverEmailAddress = _data["receiverEmailAddress"];
        }
    }

    static fromJS(data: any): CmsKitContactSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CmsKitContactSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiverEmailAddress"] = this.receiverEmailAddress;
        return data;
    }
}

export interface ICmsKitContactSettingDto {
    receiverEmailAddress?: string | undefined;
}

export class UpdateCmsKitContactSettingDto implements IUpdateCmsKitContactSettingDto {
    receiverEmailAddress!: string;

    constructor(data?: IUpdateCmsKitContactSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiverEmailAddress = _data["receiverEmailAddress"];
        }
    }

    static fromJS(data: any): UpdateCmsKitContactSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCmsKitContactSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiverEmailAddress"] = this.receiverEmailAddress;
        return data;
    }
}

export interface IUpdateCmsKitContactSettingDto {
    receiverEmailAddress: string;
}

export class GlobalResourcesDto implements IGlobalResourcesDto {
    styleContent?: string | undefined;
    scriptContent?: string | undefined;

    constructor(data?: IGlobalResourcesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.styleContent = _data["styleContent"];
            this.scriptContent = _data["scriptContent"];
        }
    }

    static fromJS(data: any): GlobalResourcesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalResourcesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["styleContent"] = this.styleContent;
        data["scriptContent"] = this.scriptContent;
        return data;
    }
}

export interface IGlobalResourcesDto {
    styleContent?: string | undefined;
    scriptContent?: string | undefined;
}

export class GlobalResourcesUpdateDto implements IGlobalResourcesUpdateDto {
    style?: string | undefined;
    script?: string | undefined;

    constructor(data?: IGlobalResourcesUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.style = _data["style"];
            this.script = _data["script"];
        }
    }

    static fromJS(data: any): GlobalResourcesUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalResourcesUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["style"] = this.style;
        data["script"] = this.script;
        return data;
    }
}

export interface IGlobalResourcesUpdateDto {
    style?: string | undefined;
    script?: string | undefined;
}

export class MediaDescriptorDto implements IMediaDescriptorDto {
    id?: string;
    name?: string | undefined;
    mimeType?: string | undefined;
    size?: number;

    constructor(data?: IMediaDescriptorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): MediaDescriptorDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaDescriptorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        return data;
    }
}

export interface IMediaDescriptorDto {
    id?: string;
    name?: string | undefined;
    mimeType?: string | undefined;
    size?: number;
}

export class MenuItemCreateInput implements IMenuItemCreateInput {
    parentId?: string | undefined;
    displayName!: string;
    isActive?: boolean;
    url?: string | undefined;
    icon?: string | undefined;
    order?: number;
    target?: string | undefined;
    elementId?: string | undefined;
    cssClass?: string | undefined;
    pageId?: string | undefined;

    constructor(data?: IMenuItemCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.url = _data["url"];
            this.icon = _data["icon"];
            this.order = _data["order"];
            this.target = _data["target"];
            this.elementId = _data["elementId"];
            this.cssClass = _data["cssClass"];
            this.pageId = _data["pageId"];
        }
    }

    static fromJS(data: any): MenuItemCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["order"] = this.order;
        data["target"] = this.target;
        data["elementId"] = this.elementId;
        data["cssClass"] = this.cssClass;
        data["pageId"] = this.pageId;
        return data;
    }
}

export interface IMenuItemCreateInput {
    parentId?: string | undefined;
    displayName: string;
    isActive?: boolean;
    url?: string | undefined;
    icon?: string | undefined;
    order?: number;
    target?: string | undefined;
    elementId?: string | undefined;
    cssClass?: string | undefined;
    pageId?: string | undefined;
}

export class MenuItemMoveInput implements IMenuItemMoveInput {
    newParentId?: string | undefined;
    position?: number;

    constructor(data?: IMenuItemMoveInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newParentId = _data["newParentId"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): MenuItemMoveInput {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemMoveInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newParentId"] = this.newParentId;
        data["position"] = this.position;
        return data;
    }
}

export interface IMenuItemMoveInput {
    newParentId?: string | undefined;
    position?: number;
}

export class MenuItemUpdateInput implements IMenuItemUpdateInput {
    displayName!: string;
    isActive?: boolean;
    url?: string | undefined;
    icon?: string | undefined;
    target?: string | undefined;
    elementId?: string | undefined;
    cssClass?: string | undefined;
    pageId?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IMenuItemUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.url = _data["url"];
            this.icon = _data["icon"];
            this.target = _data["target"];
            this.elementId = _data["elementId"];
            this.cssClass = _data["cssClass"];
            this.pageId = _data["pageId"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): MenuItemUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["target"] = this.target;
        data["elementId"] = this.elementId;
        data["cssClass"] = this.cssClass;
        data["pageId"] = this.pageId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IMenuItemUpdateInput {
    displayName: string;
    isActive?: boolean;
    url?: string | undefined;
    icon?: string | undefined;
    target?: string | undefined;
    elementId?: string | undefined;
    cssClass?: string | undefined;
    pageId?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class PageLookupDto implements IPageLookupDto {
    id?: string;
    title?: string | undefined;
    slug?: string | undefined;

    constructor(data?: IPageLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.slug = _data["slug"];
        }
    }

    static fromJS(data: any): PageLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["slug"] = this.slug;
        return data;
    }
}

export interface IPageLookupDto {
    id?: string;
    title?: string | undefined;
    slug?: string | undefined;
}

export class NewsletterPreferenceDto implements INewsletterPreferenceDto {
    preference?: string | undefined;
    source?: string | undefined;
    sourceUrl?: string | undefined;

    constructor(data?: INewsletterPreferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preference = _data["preference"];
            this.source = _data["source"];
            this.sourceUrl = _data["sourceUrl"];
        }
    }

    static fromJS(data: any): NewsletterPreferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsletterPreferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preference"] = this.preference;
        data["source"] = this.source;
        data["sourceUrl"] = this.sourceUrl;
        return data;
    }
}

export interface INewsletterPreferenceDto {
    preference?: string | undefined;
    source?: string | undefined;
    sourceUrl?: string | undefined;
}

export class NewsletterRecordCsvDto implements INewsletterRecordCsvDto {
    emailAddress?: string | undefined;
    securityCode?: string | undefined;

    constructor(data?: INewsletterRecordCsvDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.securityCode = _data["securityCode"];
        }
    }

    static fromJS(data: any): NewsletterRecordCsvDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsletterRecordCsvDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["securityCode"] = this.securityCode;
        return data;
    }
}

export interface INewsletterRecordCsvDto {
    emailAddress?: string | undefined;
    securityCode?: string | undefined;
}

export class NewsletterRecordDto implements INewsletterRecordDto {
    id?: string;
    emailAddress?: string | undefined;
    creationTime?: Date;

    constructor(data?: INewsletterRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NewsletterRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsletterRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface INewsletterRecordDto {
    id?: string;
    emailAddress?: string | undefined;
    creationTime?: Date;
}

export class NewsletterRecordWithDetailsDto implements INewsletterRecordWithDetailsDto {
    id?: string;
    emailAddress?: string | undefined;
    preferences?: NewsletterPreferenceDto[] | undefined;
    creationTime?: Date;

    constructor(data?: INewsletterRecordWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailAddress = _data["emailAddress"];
            if (Array.isArray(_data["preferences"])) {
                this.preferences = [] as any;
                for (let item of _data["preferences"])
                    this.preferences!.push(NewsletterPreferenceDto.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NewsletterRecordWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsletterRecordWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailAddress"] = this.emailAddress;
        if (Array.isArray(this.preferences)) {
            data["preferences"] = [];
            for (let item of this.preferences)
                data["preferences"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface INewsletterRecordWithDetailsDto {
    id?: string;
    emailAddress?: string | undefined;
    preferences?: NewsletterPreferenceDto[] | undefined;
    creationTime?: Date;
}

export class CreatePageInputDto implements ICreatePageInputDto {
    title!: string;
    slug!: string;
    content?: string | undefined;
    script?: string | undefined;
    style?: string | undefined;

    constructor(data?: ICreatePageInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.content = _data["content"];
            this.script = _data["script"];
            this.style = _data["style"];
        }
    }

    static fromJS(data: any): CreatePageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["content"] = this.content;
        data["script"] = this.script;
        data["style"] = this.style;
        return data;
    }
}

export interface ICreatePageInputDto {
    title: string;
    slug: string;
    content?: string | undefined;
    script?: string | undefined;
    style?: string | undefined;
}

export class PageDto implements IPageDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    title?: string | undefined;
    slug?: string | undefined;
    content?: string | undefined;
    script?: string | undefined;
    style?: string | undefined;
    isHomePage?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.content = _data["content"];
            this.script = _data["script"];
            this.style = _data["style"];
            this.isHomePage = _data["isHomePage"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): PageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["content"] = this.content;
        data["script"] = this.script;
        data["style"] = this.style;
        data["isHomePage"] = this.isHomePage;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IPageDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    title?: string | undefined;
    slug?: string | undefined;
    content?: string | undefined;
    script?: string | undefined;
    style?: string | undefined;
    isHomePage?: boolean;
    concurrencyStamp?: string | undefined;
}

export class UpdatePageInputDto implements IUpdatePageInputDto {
    title!: string;
    slug!: string;
    content?: string | undefined;
    script?: string | undefined;
    style?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdatePageInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.content = _data["content"];
            this.script = _data["script"];
            this.style = _data["style"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdatePageInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePageInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["content"] = this.content;
        data["script"] = this.script;
        data["style"] = this.style;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdatePageInputDto {
    title: string;
    slug: string;
    content?: string | undefined;
    script?: string | undefined;
    style?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class CreatePollDto implements ICreatePollDto {
    question!: string;
    code!: string;
    widget?: string | undefined;
    name?: string | undefined;
    allowMultipleVote?: boolean;
    showVoteCount?: boolean;
    showResultWithoutGivingVote?: boolean;
    showHoursLeft?: boolean;
    startDate?: Date;
    endDate?: Date | undefined;
    resultShowingEndDate?: Date | undefined;
    pollOptions?: PollOptionDto[] | undefined;

    constructor(data?: ICreatePollDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.question = _data["question"];
            this.code = _data["code"];
            this.widget = _data["widget"];
            this.name = _data["name"];
            this.allowMultipleVote = _data["allowMultipleVote"];
            this.showVoteCount = _data["showVoteCount"];
            this.showResultWithoutGivingVote = _data["showResultWithoutGivingVote"];
            this.showHoursLeft = _data["showHoursLeft"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.resultShowingEndDate = _data["resultShowingEndDate"] ? new Date(_data["resultShowingEndDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["pollOptions"])) {
                this.pollOptions = [] as any;
                for (let item of _data["pollOptions"])
                    this.pollOptions!.push(PollOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePollDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePollDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question;
        data["code"] = this.code;
        data["widget"] = this.widget;
        data["name"] = this.name;
        data["allowMultipleVote"] = this.allowMultipleVote;
        data["showVoteCount"] = this.showVoteCount;
        data["showResultWithoutGivingVote"] = this.showResultWithoutGivingVote;
        data["showHoursLeft"] = this.showHoursLeft;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["resultShowingEndDate"] = this.resultShowingEndDate ? this.resultShowingEndDate.toISOString() : <any>undefined;
        if (Array.isArray(this.pollOptions)) {
            data["pollOptions"] = [];
            for (let item of this.pollOptions)
                data["pollOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePollDto {
    question: string;
    code: string;
    widget?: string | undefined;
    name?: string | undefined;
    allowMultipleVote?: boolean;
    showVoteCount?: boolean;
    showResultWithoutGivingVote?: boolean;
    showHoursLeft?: boolean;
    startDate?: Date;
    endDate?: Date | undefined;
    resultShowingEndDate?: Date | undefined;
    pollOptions?: PollOptionDto[] | undefined;
}

export class GetResultDto implements IGetResultDto {
    question?: string | undefined;
    pollVoteCount?: number;
    pollResultDetails?: PollResultDto[] | undefined;

    constructor(data?: IGetResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.question = _data["question"];
            this.pollVoteCount = _data["pollVoteCount"];
            if (Array.isArray(_data["pollResultDetails"])) {
                this.pollResultDetails = [] as any;
                for (let item of _data["pollResultDetails"])
                    this.pollResultDetails!.push(PollResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question;
        data["pollVoteCount"] = this.pollVoteCount;
        if (Array.isArray(this.pollResultDetails)) {
            data["pollResultDetails"] = [];
            for (let item of this.pollResultDetails)
                data["pollResultDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetResultDto {
    question?: string | undefined;
    pollVoteCount?: number;
    pollResultDetails?: PollResultDto[] | undefined;
}

export class PollDto implements IPollDto {
    id?: string;
    question?: string | undefined;
    code?: string | undefined;
    widget?: string | undefined;
    name?: string | undefined;
    allowMultipleVote?: boolean;
    voteCount?: number;
    startDate?: Date;
    endDate?: Date | undefined;
    creationTime?: Date;

    constructor(data?: IPollDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.question = _data["question"];
            this.code = _data["code"];
            this.widget = _data["widget"];
            this.name = _data["name"];
            this.allowMultipleVote = _data["allowMultipleVote"];
            this.voteCount = _data["voteCount"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PollDto {
        data = typeof data === 'object' ? data : {};
        let result = new PollDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["question"] = this.question;
        data["code"] = this.code;
        data["widget"] = this.widget;
        data["name"] = this.name;
        data["allowMultipleVote"] = this.allowMultipleVote;
        data["voteCount"] = this.voteCount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPollDto {
    id?: string;
    question?: string | undefined;
    code?: string | undefined;
    widget?: string | undefined;
    name?: string | undefined;
    allowMultipleVote?: boolean;
    voteCount?: number;
    startDate?: Date;
    endDate?: Date | undefined;
    creationTime?: Date;
}

export class PollOptionDto implements IPollOptionDto {
    id?: string;
    text?: string | undefined;
    order?: number;
    voteCount?: number;

    constructor(data?: IPollOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.order = _data["order"];
            this.voteCount = _data["voteCount"];
        }
    }

    static fromJS(data: any): PollOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PollOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["order"] = this.order;
        data["voteCount"] = this.voteCount;
        return data;
    }
}

export interface IPollOptionDto {
    id?: string;
    text?: string | undefined;
    order?: number;
    voteCount?: number;
}

export class PollResultDto implements IPollResultDto {
    text?: string | undefined;
    voteCount?: number;

    constructor(data?: IPollResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.voteCount = _data["voteCount"];
        }
    }

    static fromJS(data: any): PollResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PollResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["voteCount"] = this.voteCount;
        return data;
    }
}

export interface IPollResultDto {
    text?: string | undefined;
    voteCount?: number;
}

export class PollWidgetDto implements IPollWidgetDto {
    name?: string | undefined;

    constructor(data?: IPollWidgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PollWidgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new PollWidgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IPollWidgetDto {
    name?: string | undefined;
}

export class PollWithDetailsDto implements IPollWithDetailsDto {
    id?: string;
    question?: string | undefined;
    code?: string | undefined;
    widget?: string | undefined;
    name?: string | undefined;
    startDate?: Date;
    allowMultipleVote?: boolean;
    voteCount?: number;
    showVoteCount?: boolean;
    showResultWithoutGivingVote?: boolean;
    showHoursLeft?: boolean;
    endDate?: Date | undefined;
    resultShowingEndDate?: Date | undefined;
    tenantId?: string | undefined;
    creationTime?: Date;
    pollOptions?: PollOptionDto[] | undefined;

    constructor(data?: IPollWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.question = _data["question"];
            this.code = _data["code"];
            this.widget = _data["widget"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.allowMultipleVote = _data["allowMultipleVote"];
            this.voteCount = _data["voteCount"];
            this.showVoteCount = _data["showVoteCount"];
            this.showResultWithoutGivingVote = _data["showResultWithoutGivingVote"];
            this.showHoursLeft = _data["showHoursLeft"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.resultShowingEndDate = _data["resultShowingEndDate"] ? new Date(_data["resultShowingEndDate"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["pollOptions"])) {
                this.pollOptions = [] as any;
                for (let item of _data["pollOptions"])
                    this.pollOptions!.push(PollOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PollWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PollWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["question"] = this.question;
        data["code"] = this.code;
        data["widget"] = this.widget;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["allowMultipleVote"] = this.allowMultipleVote;
        data["voteCount"] = this.voteCount;
        data["showVoteCount"] = this.showVoteCount;
        data["showResultWithoutGivingVote"] = this.showResultWithoutGivingVote;
        data["showHoursLeft"] = this.showHoursLeft;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["resultShowingEndDate"] = this.resultShowingEndDate ? this.resultShowingEndDate.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.pollOptions)) {
            data["pollOptions"] = [];
            for (let item of this.pollOptions)
                data["pollOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPollWithDetailsDto {
    id?: string;
    question?: string | undefined;
    code?: string | undefined;
    widget?: string | undefined;
    name?: string | undefined;
    startDate?: Date;
    allowMultipleVote?: boolean;
    voteCount?: number;
    showVoteCount?: boolean;
    showResultWithoutGivingVote?: boolean;
    showHoursLeft?: boolean;
    endDate?: Date | undefined;
    resultShowingEndDate?: Date | undefined;
    tenantId?: string | undefined;
    creationTime?: Date;
    pollOptions?: PollOptionDto[] | undefined;
}

export class UpdatePollDto implements IUpdatePollDto {
    question!: string;
    code!: string;
    widget?: string | undefined;
    name?: string | undefined;
    showVoteCount?: boolean;
    showResultWithoutGivingVote?: boolean;
    showHoursLeft?: boolean;
    startDate?: Date;
    endDate?: Date | undefined;
    resultShowingEndDate?: Date | undefined;
    pollOptions?: PollOptionDto[] | undefined;

    constructor(data?: IUpdatePollDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.question = _data["question"];
            this.code = _data["code"];
            this.widget = _data["widget"];
            this.name = _data["name"];
            this.showVoteCount = _data["showVoteCount"];
            this.showResultWithoutGivingVote = _data["showResultWithoutGivingVote"];
            this.showHoursLeft = _data["showHoursLeft"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.resultShowingEndDate = _data["resultShowingEndDate"] ? new Date(_data["resultShowingEndDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["pollOptions"])) {
                this.pollOptions = [] as any;
                for (let item of _data["pollOptions"])
                    this.pollOptions!.push(PollOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePollDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePollDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question;
        data["code"] = this.code;
        data["widget"] = this.widget;
        data["name"] = this.name;
        data["showVoteCount"] = this.showVoteCount;
        data["showResultWithoutGivingVote"] = this.showResultWithoutGivingVote;
        data["showHoursLeft"] = this.showHoursLeft;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["resultShowingEndDate"] = this.resultShowingEndDate ? this.resultShowingEndDate.toISOString() : <any>undefined;
        if (Array.isArray(this.pollOptions)) {
            data["pollOptions"] = [];
            for (let item of this.pollOptions)
                data["pollOptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdatePollDto {
    question: string;
    code: string;
    widget?: string | undefined;
    name?: string | undefined;
    showVoteCount?: boolean;
    showResultWithoutGivingVote?: boolean;
    showHoursLeft?: boolean;
    startDate?: Date;
    endDate?: Date | undefined;
    resultShowingEndDate?: Date | undefined;
    pollOptions?: PollOptionDto[] | undefined;
}

export class EntityTagCreateDto implements IEntityTagCreateDto {
    tagName!: string;
    entityType!: string;
    entityId!: string;

    constructor(data?: IEntityTagCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagName = _data["tagName"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): EntityTagCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTagCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagName"] = this.tagName;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface IEntityTagCreateDto {
    tagName: string;
    entityType: string;
    entityId: string;
}

export class EntityTagSetDto implements IEntityTagSetDto {
    entityId?: string | undefined;
    entityType?: string | undefined;
    tags!: string[];

    constructor(data?: IEntityTagSetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tags = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): EntityTagSetDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTagSetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IEntityTagSetDto {
    entityId?: string | undefined;
    entityType?: string | undefined;
    tags: string[];
}

export class TagCreateDto implements ITagCreateDto {
    entityType!: string;
    name!: string;

    constructor(data?: ITagCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TagCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["name"] = this.name;
        return data;
    }
}

export interface ITagCreateDto {
    entityType: string;
    name: string;
}

export class TagDefinitionDto implements ITagDefinitionDto {
    entityType?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: ITagDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TagDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITagDefinitionDto {
    entityType?: string | undefined;
    displayName?: string | undefined;
}

export class TagUpdateDto implements ITagUpdateDto {
    name!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: ITagUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): TagUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ITagUpdateDto {
    name: string;
    concurrencyStamp?: string | undefined;
}

export class CreateShortenedUrlDto implements ICreateShortenedUrlDto {
    source!: string;
    target!: string;

    constructor(data?: ICreateShortenedUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.source = _data["source"];
            this.target = _data["target"];
        }
    }

    static fromJS(data: any): CreateShortenedUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShortenedUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source;
        data["target"] = this.target;
        return data;
    }
}

export interface ICreateShortenedUrlDto {
    source: string;
    target: string;
}

export class ShortenedUrlDto implements IShortenedUrlDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    source?: string | undefined;
    target?: string | undefined;

    constructor(data?: IShortenedUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.source = _data["source"];
            this.target = _data["target"];
        }
    }

    static fromJS(data: any): ShortenedUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShortenedUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["source"] = this.source;
        data["target"] = this.target;
        return data;
    }
}

export interface IShortenedUrlDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    source?: string | undefined;
    target?: string | undefined;
}

export class UpdateShortenedUrlDto implements IUpdateShortenedUrlDto {
    target!: string;

    constructor(data?: IUpdateShortenedUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.target = _data["target"];
        }
    }

    static fromJS(data: any): UpdateShortenedUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShortenedUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["target"] = this.target;
        return data;
    }
}

export interface IUpdateShortenedUrlDto {
    target: string;
}

export class BlogFeatureDto implements IBlogFeatureDto {
    id?: string;
    featureName?: string | undefined;
    isEnabled?: boolean;

    constructor(data?: IBlogFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.featureName = _data["featureName"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): BlogFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["featureName"] = this.featureName;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IBlogFeatureDto {
    id?: string;
    featureName?: string | undefined;
    isEnabled?: boolean;
}

export enum BlogPostStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class BlogPostCommonDto implements IBlogPostCommonDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    blogId?: string;
    title?: string | undefined;
    slug?: string | undefined;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
    author?: CmsUserDto3;

    constructor(data?: IBlogPostCommonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.blogId = _data["blogId"];
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.shortDescription = _data["shortDescription"];
            this.content = _data["content"];
            this.coverImageMediaId = _data["coverImageMediaId"];
            this.author = _data["author"] ? CmsUserDto3.fromJS(_data["author"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BlogPostCommonDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlogPostCommonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["blogId"] = this.blogId;
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["shortDescription"] = this.shortDescription;
        data["content"] = this.content;
        data["coverImageMediaId"] = this.coverImageMediaId;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBlogPostCommonDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    blogId?: string;
    title?: string | undefined;
    slug?: string | undefined;
    shortDescription?: string | undefined;
    content?: string | undefined;
    coverImageMediaId?: string | undefined;
    author?: CmsUserDto3;
}

export class PageDto2 implements IPageDto2 {
    id?: string;
    title?: string | undefined;
    slug?: string | undefined;
    content?: string | undefined;
    script?: string | undefined;
    style?: string | undefined;

    constructor(data?: IPageDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.slug = _data["slug"];
            this.content = _data["content"];
            this.script = _data["script"];
            this.style = _data["style"];
        }
    }

    static fromJS(data: any): PageDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new PageDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["slug"] = this.slug;
        data["content"] = this.content;
        data["script"] = this.script;
        data["style"] = this.style;
        return data;
    }
}

export interface IPageDto2 {
    id?: string;
    title?: string | undefined;
    slug?: string | undefined;
    content?: string | undefined;
    script?: string | undefined;
    style?: string | undefined;
}

export class MenuItemDto implements IMenuItemDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    parentId?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean;
    url?: string | undefined;
    icon?: string | undefined;
    order?: number;
    target?: string | undefined;
    elementId?: string | undefined;
    cssClass?: string | undefined;
    pageId?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IMenuItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.url = _data["url"];
            this.icon = _data["icon"];
            this.order = _data["order"];
            this.target = _data["target"];
            this.elementId = _data["elementId"];
            this.cssClass = _data["cssClass"];
            this.pageId = _data["pageId"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): MenuItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["url"] = this.url;
        data["icon"] = this.icon;
        data["order"] = this.order;
        data["target"] = this.target;
        data["elementId"] = this.elementId;
        data["cssClass"] = this.cssClass;
        data["pageId"] = this.pageId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IMenuItemDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    parentId?: string | undefined;
    displayName?: string | undefined;
    isActive?: boolean;
    url?: string | undefined;
    icon?: string | undefined;
    order?: number;
    target?: string | undefined;
    elementId?: string | undefined;
    cssClass?: string | undefined;
    pageId?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class CmsUserDto2 implements ICmsUserDto2 {
    id?: string;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;

    constructor(data?: ICmsUserDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
        }
    }

    static fromJS(data: any): CmsUserDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CmsUserDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        return data;
    }
}

export interface ICmsUserDto2 {
    id?: string;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
}

export class CommentDto implements ICommentDto {
    id?: string;
    entityType?: string | undefined;
    entityId?: string | undefined;
    text?: string | undefined;
    repliedCommentId?: string | undefined;
    creatorId?: string;
    creationTime?: Date;
    author?: CmsUserDto2;
    concurrencyStamp?: string | undefined;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.text = _data["text"];
            this.repliedCommentId = _data["repliedCommentId"];
            this.creatorId = _data["creatorId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.author = _data["author"] ? CmsUserDto2.fromJS(_data["author"]) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["text"] = this.text;
        data["repliedCommentId"] = this.repliedCommentId;
        data["creatorId"] = this.creatorId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ICommentDto {
    id?: string;
    entityType?: string | undefined;
    entityId?: string | undefined;
    text?: string | undefined;
    repliedCommentId?: string | undefined;
    creatorId?: string;
    creationTime?: Date;
    author?: CmsUserDto2;
    concurrencyStamp?: string | undefined;
}

export class CommentWithDetailsDto2 implements ICommentWithDetailsDto2 {
    id?: string;
    entityType?: string | undefined;
    entityId?: string | undefined;
    text?: string | undefined;
    creatorId?: string;
    creationTime?: Date;
    replies?: CommentDto[] | undefined;
    author?: CmsUserDto2;
    concurrencyStamp?: string | undefined;

    constructor(data?: ICommentWithDetailsDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.text = _data["text"];
            this.creatorId = _data["creatorId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["replies"])) {
                this.replies = [] as any;
                for (let item of _data["replies"])
                    this.replies!.push(CommentDto.fromJS(item));
            }
            this.author = _data["author"] ? CmsUserDto2.fromJS(_data["author"]) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): CommentWithDetailsDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new CommentWithDetailsDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["text"] = this.text;
        data["creatorId"] = this.creatorId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.replies)) {
            data["replies"] = [];
            for (let item of this.replies)
                data["replies"].push(item.toJSON());
        }
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ICommentWithDetailsDto2 {
    id?: string;
    entityType?: string | undefined;
    entityId?: string | undefined;
    text?: string | undefined;
    creatorId?: string;
    creationTime?: Date;
    replies?: CommentDto[] | undefined;
    author?: CmsUserDto2;
    concurrencyStamp?: string | undefined;
}

export class CreateCommentInput implements ICreateCommentInput {
    text!: string;
    repliedCommentId?: string | undefined;

    constructor(data?: ICreateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.repliedCommentId = _data["repliedCommentId"];
        }
    }

    static fromJS(data: any): CreateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["repliedCommentId"] = this.repliedCommentId;
        return data;
    }
}

export interface ICreateCommentInput {
    text: string;
    repliedCommentId?: string | undefined;
}

export class UpdateCommentInput implements IUpdateCommentInput {
    text!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateCommentInput {
    text: string;
    concurrencyStamp?: string | undefined;
}

export class ContactCreateInput implements IContactCreateInput {
    contactName?: string | undefined;
    name!: string;
    subject!: string;
    email!: string;
    message!: string;
    recaptchaToken?: string | undefined;

    constructor(data?: IContactCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactName = _data["contactName"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.email = _data["email"];
            this.message = _data["message"];
            this.recaptchaToken = _data["recaptchaToken"];
        }
    }

    static fromJS(data: any): ContactCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactName"] = this.contactName;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["email"] = this.email;
        data["message"] = this.message;
        data["recaptchaToken"] = this.recaptchaToken;
        return data;
    }
}

export interface IContactCreateInput {
    contactName?: string | undefined;
    name: string;
    subject: string;
    email: string;
    message: string;
    recaptchaToken?: string | undefined;
}

export class GlobalResourceDto implements IGlobalResourceDto {
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IGlobalResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GlobalResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IGlobalResourceDto {
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
}

export class CreateNewsletterRecordInput implements ICreateNewsletterRecordInput {
    emailAddress!: string;
    preference!: string;
    source!: string;
    sourceUrl!: string;
    privacyPolicyUrl?: string | undefined;
    additionalPreferences?: string[] | undefined;

    constructor(data?: ICreateNewsletterRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.preference = _data["preference"];
            this.source = _data["source"];
            this.sourceUrl = _data["sourceUrl"];
            this.privacyPolicyUrl = _data["privacyPolicyUrl"];
            if (Array.isArray(_data["additionalPreferences"])) {
                this.additionalPreferences = [] as any;
                for (let item of _data["additionalPreferences"])
                    this.additionalPreferences!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateNewsletterRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewsletterRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["preference"] = this.preference;
        data["source"] = this.source;
        data["sourceUrl"] = this.sourceUrl;
        data["privacyPolicyUrl"] = this.privacyPolicyUrl;
        if (Array.isArray(this.additionalPreferences)) {
            data["additionalPreferences"] = [];
            for (let item of this.additionalPreferences)
                data["additionalPreferences"].push(item);
        }
        return data;
    }
}

export interface ICreateNewsletterRecordInput {
    emailAddress: string;
    preference: string;
    source: string;
    sourceUrl: string;
    privacyPolicyUrl?: string | undefined;
    additionalPreferences?: string[] | undefined;
}

export class NewsletterEmailOptionsDto implements INewsletterEmailOptionsDto {
    privacyPolicyConfirmation?: string | undefined;
    widgetViewPath?: string | undefined;
    additionalPreferences?: string[] | undefined;
    displayAdditionalPreferences?: string[] | undefined;

    constructor(data?: INewsletterEmailOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.privacyPolicyConfirmation = _data["privacyPolicyConfirmation"];
            this.widgetViewPath = _data["widgetViewPath"];
            if (Array.isArray(_data["additionalPreferences"])) {
                this.additionalPreferences = [] as any;
                for (let item of _data["additionalPreferences"])
                    this.additionalPreferences!.push(item);
            }
            if (Array.isArray(_data["displayAdditionalPreferences"])) {
                this.displayAdditionalPreferences = [] as any;
                for (let item of _data["displayAdditionalPreferences"])
                    this.displayAdditionalPreferences!.push(item);
            }
        }
    }

    static fromJS(data: any): NewsletterEmailOptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsletterEmailOptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["privacyPolicyConfirmation"] = this.privacyPolicyConfirmation;
        data["widgetViewPath"] = this.widgetViewPath;
        if (Array.isArray(this.additionalPreferences)) {
            data["additionalPreferences"] = [];
            for (let item of this.additionalPreferences)
                data["additionalPreferences"].push(item);
        }
        if (Array.isArray(this.displayAdditionalPreferences)) {
            data["displayAdditionalPreferences"] = [];
            for (let item of this.displayAdditionalPreferences)
                data["displayAdditionalPreferences"].push(item);
        }
        return data;
    }
}

export interface INewsletterEmailOptionsDto {
    privacyPolicyConfirmation?: string | undefined;
    widgetViewPath?: string | undefined;
    additionalPreferences?: string[] | undefined;
    displayAdditionalPreferences?: string[] | undefined;
}

export class NewsletterPreferenceDetailsDto implements INewsletterPreferenceDetailsDto {
    preference?: string | undefined;
    displayPreference?: string | undefined;
    definition?: string | undefined;
    isSelectedByEmailAddress?: boolean;

    constructor(data?: INewsletterPreferenceDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preference = _data["preference"];
            this.displayPreference = _data["displayPreference"];
            this.definition = _data["definition"];
            this.isSelectedByEmailAddress = _data["isSelectedByEmailAddress"];
        }
    }

    static fromJS(data: any): NewsletterPreferenceDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new NewsletterPreferenceDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preference"] = this.preference;
        data["displayPreference"] = this.displayPreference;
        data["definition"] = this.definition;
        data["isSelectedByEmailAddress"] = this.isSelectedByEmailAddress;
        return data;
    }
}

export interface INewsletterPreferenceDetailsDto {
    preference?: string | undefined;
    displayPreference?: string | undefined;
    definition?: string | undefined;
    isSelectedByEmailAddress?: boolean;
}

export class PreferenceDetailsDto implements IPreferenceDetailsDto {
    preference?: string | undefined;
    isEnabled?: boolean;

    constructor(data?: IPreferenceDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preference = _data["preference"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): PreferenceDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PreferenceDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preference"] = this.preference;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IPreferenceDetailsDto {
    preference?: string | undefined;
    isEnabled?: boolean;
}

export class UpdatePreferenceRequestInput implements IUpdatePreferenceRequestInput {
    emailAddress!: string;
    preferenceDetails!: PreferenceDetailsDto[];
    source!: string;
    sourceUrl!: string;
    securityCode!: string;

    constructor(data?: IUpdatePreferenceRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.preferenceDetails = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            if (Array.isArray(_data["preferenceDetails"])) {
                this.preferenceDetails = [] as any;
                for (let item of _data["preferenceDetails"])
                    this.preferenceDetails!.push(PreferenceDetailsDto.fromJS(item));
            }
            this.source = _data["source"];
            this.sourceUrl = _data["sourceUrl"];
            this.securityCode = _data["securityCode"];
        }
    }

    static fromJS(data: any): UpdatePreferenceRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePreferenceRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        if (Array.isArray(this.preferenceDetails)) {
            data["preferenceDetails"] = [];
            for (let item of this.preferenceDetails)
                data["preferenceDetails"].push(item.toJSON());
        }
        data["source"] = this.source;
        data["sourceUrl"] = this.sourceUrl;
        data["securityCode"] = this.securityCode;
        return data;
    }
}

export interface IUpdatePreferenceRequestInput {
    emailAddress: string;
    preferenceDetails: PreferenceDetailsDto[];
    source: string;
    sourceUrl: string;
    securityCode: string;
}

export class GetResultDto2 implements IGetResultDto2 {
    question?: string | undefined;
    pollVoteCount?: number;
    pollResultDetails?: PollResultDto2[] | undefined;

    constructor(data?: IGetResultDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.question = _data["question"];
            this.pollVoteCount = _data["pollVoteCount"];
            if (Array.isArray(_data["pollResultDetails"])) {
                this.pollResultDetails = [] as any;
                for (let item of _data["pollResultDetails"])
                    this.pollResultDetails!.push(PollResultDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetResultDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new GetResultDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["question"] = this.question;
        data["pollVoteCount"] = this.pollVoteCount;
        if (Array.isArray(this.pollResultDetails)) {
            data["pollResultDetails"] = [];
            for (let item of this.pollResultDetails)
                data["pollResultDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetResultDto2 {
    question?: string | undefined;
    pollVoteCount?: number;
    pollResultDetails?: PollResultDto2[] | undefined;
}

export class PollOptionDto2 implements IPollOptionDto2 {
    id?: string;
    text?: string | undefined;

    constructor(data?: IPollOptionDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): PollOptionDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new PollOptionDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data;
    }
}

export interface IPollOptionDto2 {
    id?: string;
    text?: string | undefined;
}

export class PollResultDto2 implements IPollResultDto2 {
    isSelectedForCurrentUser?: boolean;
    text?: string | undefined;
    voteCount?: number;

    constructor(data?: IPollResultDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSelectedForCurrentUser = _data["isSelectedForCurrentUser"];
            this.text = _data["text"];
            this.voteCount = _data["voteCount"];
        }
    }

    static fromJS(data: any): PollResultDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new PollResultDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSelectedForCurrentUser"] = this.isSelectedForCurrentUser;
        data["text"] = this.text;
        data["voteCount"] = this.voteCount;
        return data;
    }
}

export interface IPollResultDto2 {
    isSelectedForCurrentUser?: boolean;
    text?: string | undefined;
    voteCount?: number;
}

export class PollWithDetailsDto2 implements IPollWithDetailsDto2 {
    id?: string;
    pollOptions?: PollOptionDto2[] | undefined;
    question?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    startDate?: Date;
    allowMultipleVote?: boolean;
    voteCount?: number;
    showVoteCount?: boolean;
    showResultWithoutGivingVote?: boolean;
    showHoursLeft?: boolean;
    endDate?: Date | undefined;
    resultShowingEndDate?: Date | undefined;
    creationTime?: Date;

    constructor(data?: IPollWithDetailsDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["pollOptions"])) {
                this.pollOptions = [] as any;
                for (let item of _data["pollOptions"])
                    this.pollOptions!.push(PollOptionDto2.fromJS(item));
            }
            this.question = _data["question"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.allowMultipleVote = _data["allowMultipleVote"];
            this.voteCount = _data["voteCount"];
            this.showVoteCount = _data["showVoteCount"];
            this.showResultWithoutGivingVote = _data["showResultWithoutGivingVote"];
            this.showHoursLeft = _data["showHoursLeft"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.resultShowingEndDate = _data["resultShowingEndDate"] ? new Date(_data["resultShowingEndDate"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PollWithDetailsDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new PollWithDetailsDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.pollOptions)) {
            data["pollOptions"] = [];
            for (let item of this.pollOptions)
                data["pollOptions"].push(item.toJSON());
        }
        data["question"] = this.question;
        data["code"] = this.code;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["allowMultipleVote"] = this.allowMultipleVote;
        data["voteCount"] = this.voteCount;
        data["showVoteCount"] = this.showVoteCount;
        data["showResultWithoutGivingVote"] = this.showResultWithoutGivingVote;
        data["showHoursLeft"] = this.showHoursLeft;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["resultShowingEndDate"] = this.resultShowingEndDate ? this.resultShowingEndDate.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPollWithDetailsDto2 {
    id?: string;
    pollOptions?: PollOptionDto2[] | undefined;
    question?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    startDate?: Date;
    allowMultipleVote?: boolean;
    voteCount?: number;
    showVoteCount?: boolean;
    showResultWithoutGivingVote?: boolean;
    showHoursLeft?: boolean;
    endDate?: Date | undefined;
    resultShowingEndDate?: Date | undefined;
    creationTime?: Date;
}

export class SubmitPollInput implements ISubmitPollInput {
    pollOptionIds?: string[] | undefined;

    constructor(data?: ISubmitPollInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pollOptionIds"])) {
                this.pollOptionIds = [] as any;
                for (let item of _data["pollOptionIds"])
                    this.pollOptionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SubmitPollInput {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitPollInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pollOptionIds)) {
            data["pollOptionIds"] = [];
            for (let item of this.pollOptionIds)
                data["pollOptionIds"].push(item);
        }
        return data;
    }
}

export interface ISubmitPollInput {
    pollOptionIds?: string[] | undefined;
}

export class CreateUpdateRatingInput implements ICreateUpdateRatingInput {
    starCount!: number;

    constructor(data?: ICreateUpdateRatingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.starCount = _data["starCount"];
        }
    }

    static fromJS(data: any): CreateUpdateRatingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateRatingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["starCount"] = this.starCount;
        return data;
    }
}

export interface ICreateUpdateRatingInput {
    starCount: number;
}

export class RatingDto implements IRatingDto {
    id?: string;
    entityType?: string | undefined;
    entityId?: string | undefined;
    starCount?: number;
    creatorId?: string;
    creationTime?: Date;

    constructor(data?: IRatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityType = _data["entityType"];
            this.entityId = _data["entityId"];
            this.starCount = _data["starCount"];
            this.creatorId = _data["creatorId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["starCount"] = this.starCount;
        data["creatorId"] = this.creatorId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRatingDto {
    id?: string;
    entityType?: string | undefined;
    entityId?: string | undefined;
    starCount?: number;
    creatorId?: string;
    creationTime?: Date;
}

export class RatingWithStarCountDto implements IRatingWithStarCountDto {
    starCount?: number;
    count?: number;
    isSelectedByCurrentUser?: boolean;

    constructor(data?: IRatingWithStarCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.starCount = _data["starCount"];
            this.count = _data["count"];
            this.isSelectedByCurrentUser = _data["isSelectedByCurrentUser"];
        }
    }

    static fromJS(data: any): RatingWithStarCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingWithStarCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["starCount"] = this.starCount;
        data["count"] = this.count;
        data["isSelectedByCurrentUser"] = this.isSelectedByCurrentUser;
        return data;
    }
}

export interface IRatingWithStarCountDto {
    starCount?: number;
    count?: number;
    isSelectedByCurrentUser?: boolean;
}

export class ReactionDto implements IReactionDto {
    name?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IReactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ReactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IReactionDto {
    name?: string | undefined;
    displayName?: string | undefined;
}

export class ReactionWithSelectionDto implements IReactionWithSelectionDto {
    reaction?: ReactionDto;
    count?: number;
    isSelectedByCurrentUser?: boolean;

    constructor(data?: IReactionWithSelectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reaction = _data["reaction"] ? ReactionDto.fromJS(_data["reaction"]) : <any>undefined;
            this.count = _data["count"];
            this.isSelectedByCurrentUser = _data["isSelectedByCurrentUser"];
        }
    }

    static fromJS(data: any): ReactionWithSelectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReactionWithSelectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reaction"] = this.reaction ? this.reaction.toJSON() : <any>undefined;
        data["count"] = this.count;
        data["isSelectedByCurrentUser"] = this.isSelectedByCurrentUser;
        return data;
    }
}

export interface IReactionWithSelectionDto {
    reaction?: ReactionDto;
    count?: number;
    isSelectedByCurrentUser?: boolean;
}

export class ShortenedUrlDto2 implements IShortenedUrlDto2 {
    id?: string;
    source?: string | undefined;
    target?: string | undefined;

    constructor(data?: IShortenedUrlDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.source = _data["source"];
            this.target = _data["target"];
        }
    }

    static fromJS(data: any): ShortenedUrlDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ShortenedUrlDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["source"] = this.source;
        data["target"] = this.target;
        return data;
    }
}

export interface IShortenedUrlDto2 {
    id?: string;
    source?: string | undefined;
    target?: string | undefined;
}

export class TagDto2 implements ITagDto2 {
    id?: string;
    entityType?: string | undefined;
    name?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: ITagDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityType = _data["entityType"];
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): TagDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityType"] = this.entityType;
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ITagDto2 {
    id?: string;
    entityType?: string | undefined;
    name?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class CmsUserDto3 implements ICmsUserDto3 {
    id?: string;
    readonly tenantId?: string | undefined;
    readonly userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;

    constructor(data?: ICmsUserDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).tenantId = _data["tenantId"];
            (<any>this).userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
        }
    }

    static fromJS(data: any): CmsUserDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new CmsUserDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        return data;
    }
}

export interface ICmsUserDto3 {
    id?: string;
    tenantId?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
}

export class CreateDirectoryInput implements ICreateDirectoryInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    parentId?: string | undefined;
    name!: string;

    constructor(data?: ICreateDirectoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.parentId = _data["parentId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateDirectoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDirectoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateDirectoryInput {
    extraProperties?: { [key: string]: any; } | undefined;
    parentId?: string | undefined;
    name: string;
}

export class DirectoryContentDto implements IDirectoryContentDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    name?: string | undefined;
    isDirectory?: boolean;
    size?: number;
    iconInfo?: FileIconInfo;
    concurrencyStamp?: string | undefined;

    constructor(data?: IDirectoryContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.name = _data["name"];
            this.isDirectory = _data["isDirectory"];
            this.size = _data["size"];
            this.iconInfo = _data["iconInfo"] ? FileIconInfo.fromJS(_data["iconInfo"]) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): DirectoryContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DirectoryContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["name"] = this.name;
        data["isDirectory"] = this.isDirectory;
        data["size"] = this.size;
        data["iconInfo"] = this.iconInfo ? this.iconInfo.toJSON() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IDirectoryContentDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    name?: string | undefined;
    isDirectory?: boolean;
    size?: number;
    iconInfo?: FileIconInfo;
    concurrencyStamp?: string | undefined;
}

export class DirectoryDescriptorDto implements IDirectoryDescriptorDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IDirectoryDescriptorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): DirectoryDescriptorDto {
        data = typeof data === 'object' ? data : {};
        let result = new DirectoryDescriptorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IDirectoryDescriptorDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    name?: string | undefined;
    parentId?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class DirectoryDescriptorInfoDto implements IDirectoryDescriptorInfoDto {
    id?: string;
    name?: string | undefined;
    parentId?: string | undefined;
    hasChildren?: boolean;

    constructor(data?: IDirectoryDescriptorInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.hasChildren = _data["hasChildren"];
        }
    }

    static fromJS(data: any): DirectoryDescriptorInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DirectoryDescriptorInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["hasChildren"] = this.hasChildren;
        return data;
    }
}

export interface IDirectoryDescriptorInfoDto {
    id?: string;
    name?: string | undefined;
    parentId?: string | undefined;
    hasChildren?: boolean;
}

export class MoveDirectoryInput implements IMoveDirectoryInput {
    id?: string;
    newParentId?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IMoveDirectoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): MoveDirectoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveDirectoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IMoveDirectoryInput {
    id?: string;
    newParentId?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class RenameDirectoryInput implements IRenameDirectoryInput {
    name!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: IRenameDirectoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): RenameDirectoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameDirectoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IRenameDirectoryInput {
    name: string;
    concurrencyStamp?: string | undefined;
}

export class DownloadTokenResultDto2 implements IDownloadTokenResultDto2 {
    token?: string | undefined;

    constructor(data?: IDownloadTokenResultDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): DownloadTokenResultDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadTokenResultDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IDownloadTokenResultDto2 {
    token?: string | undefined;
}

export class FileDescriptorDto implements IFileDescriptorDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    directoryId?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    size?: number;
    concurrencyStamp?: string | undefined;

    constructor(data?: IFileDescriptorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.directoryId = _data["directoryId"];
            this.name = _data["name"];
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): FileDescriptorDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDescriptorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["directoryId"] = this.directoryId;
        data["name"] = this.name;
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IFileDescriptorDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    directoryId?: string | undefined;
    name?: string | undefined;
    mimeType?: string | undefined;
    size?: number;
    concurrencyStamp?: string | undefined;
}

export class FileIconInfo implements IFileIconInfo {
    icon?: string | undefined;
    type?: FileIconType;

    constructor(data?: IFileIconInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.icon = _data["icon"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): FileIconInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FileIconInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["icon"] = this.icon;
        data["type"] = this.type;
        return data;
    }
}

export interface IFileIconInfo {
    icon?: string | undefined;
    type?: FileIconType;
}

export enum FileIconType {
    _0 = 0,
    _1 = 1,
}

export class FileUploadPreInfoDto implements IFileUploadPreInfoDto {
    fileName?: string | undefined;
    doesExist?: boolean;
    hasValidName?: boolean;

    constructor(data?: IFileUploadPreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.doesExist = _data["doesExist"];
            this.hasValidName = _data["hasValidName"];
        }
    }

    static fromJS(data: any): FileUploadPreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadPreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["doesExist"] = this.doesExist;
        data["hasValidName"] = this.hasValidName;
        return data;
    }
}

export interface IFileUploadPreInfoDto {
    fileName?: string | undefined;
    doesExist?: boolean;
    hasValidName?: boolean;
}

export class FileUploadPreInfoRequest implements IFileUploadPreInfoRequest {
    directoryId?: string | undefined;
    fileName?: string | undefined;
    size?: number;

    constructor(data?: IFileUploadPreInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.directoryId = _data["directoryId"];
            this.fileName = _data["fileName"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): FileUploadPreInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadPreInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["directoryId"] = this.directoryId;
        data["fileName"] = this.fileName;
        data["size"] = this.size;
        return data;
    }
}

export interface IFileUploadPreInfoRequest {
    directoryId?: string | undefined;
    fileName?: string | undefined;
    size?: number;
}

export class MoveFileInput implements IMoveFileInput {
    id?: string;
    newDirectoryId?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IMoveFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newDirectoryId = _data["newDirectoryId"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): MoveFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newDirectoryId"] = this.newDirectoryId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IMoveFileInput {
    id?: string;
    newDirectoryId?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class RenameFileInput implements IRenameFileInput {
    name!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: IRenameFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): RenameFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenameFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IRenameFileInput {
    name: string;
    concurrencyStamp?: string | undefined;
}

export class AnswerDto implements IAnswerDto {
    id?: string;
    questionId?: string;
    choiceId?: string | undefined;
    formResponseId?: string;
    answerDate?: Date;
    value?: string | undefined;

    constructor(data?: IAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionId = _data["questionId"];
            this.choiceId = _data["choiceId"];
            this.formResponseId = _data["formResponseId"];
            this.answerDate = _data["answerDate"] ? new Date(_data["answerDate"].toString()) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionId"] = this.questionId;
        data["choiceId"] = this.choiceId;
        data["formResponseId"] = this.formResponseId;
        data["answerDate"] = this.answerDate ? this.answerDate.toISOString() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

export interface IAnswerDto {
    id?: string;
    questionId?: string;
    choiceId?: string | undefined;
    formResponseId?: string;
    answerDate?: Date;
    value?: string | undefined;
}

export class CreateAnswerDto implements ICreateAnswerDto {
    questionId?: string;
    choiceId?: string | undefined;
    value?: string | undefined;

    constructor(data?: ICreateAnswerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.choiceId = _data["choiceId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateAnswerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAnswerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["choiceId"] = this.choiceId;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateAnswerDto {
    questionId?: string;
    choiceId?: string | undefined;
    value?: string | undefined;
}

export class ChoiceDto implements IChoiceDto {
    id?: string;
    index?: number;
    isCorrect?: boolean;
    value?: string | undefined;

    constructor(data?: IChoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.index = _data["index"];
            this.isCorrect = _data["isCorrect"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ChoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["isCorrect"] = this.isCorrect;
        data["value"] = this.value;
        return data;
    }
}

export interface IChoiceDto {
    id?: string;
    index?: number;
    isCorrect?: boolean;
    value?: string | undefined;
}

export class CreateFormDto implements ICreateFormDto {
    title!: string;
    description?: string | undefined;

    constructor(data?: ICreateFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateFormDto {
    title: string;
    description?: string | undefined;
}

export class FormDto implements IFormDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    title?: string | undefined;
    description?: string | undefined;
    tenantId?: string | undefined;
    canEditResponse?: boolean;
    isCollectingEmail?: boolean;
    requiresLogin?: boolean;
    hasLimitOneResponsePerUser?: boolean;
    isAcceptingResponses?: boolean;
    isQuiz?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            this.canEditResponse = _data["canEditResponse"];
            this.isCollectingEmail = _data["isCollectingEmail"];
            this.requiresLogin = _data["requiresLogin"];
            this.hasLimitOneResponsePerUser = _data["hasLimitOneResponsePerUser"];
            this.isAcceptingResponses = _data["isAcceptingResponses"];
            this.isQuiz = _data["isQuiz"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): FormDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        data["canEditResponse"] = this.canEditResponse;
        data["isCollectingEmail"] = this.isCollectingEmail;
        data["requiresLogin"] = this.requiresLogin;
        data["hasLimitOneResponsePerUser"] = this.hasLimitOneResponsePerUser;
        data["isAcceptingResponses"] = this.isAcceptingResponses;
        data["isQuiz"] = this.isQuiz;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IFormDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    title?: string | undefined;
    description?: string | undefined;
    tenantId?: string | undefined;
    canEditResponse?: boolean;
    isCollectingEmail?: boolean;
    requiresLogin?: boolean;
    hasLimitOneResponsePerUser?: boolean;
    isAcceptingResponses?: boolean;
    isQuiz?: boolean;
    concurrencyStamp?: string | undefined;
}

export class FormInviteEmailInputDto implements IFormInviteEmailInputDto {
    to?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;

    constructor(data?: IFormInviteEmailInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.to = _data["to"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): FormInviteEmailInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormInviteEmailInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["to"] = this.to;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data;
    }
}

export interface IFormInviteEmailInputDto {
    to?: string | undefined;
    subject?: string | undefined;
    body?: string | undefined;
}

export class FormSettingsDto implements IFormSettingsDto {
    title?: string | undefined;
    canEditResponse?: boolean;
    isCollectingEmail?: boolean;
    hasLimitOneResponsePerUser?: boolean;
    isAcceptingResponses?: boolean;
    isQuiz?: boolean;
    requiresLogin?: boolean;

    constructor(data?: IFormSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.canEditResponse = _data["canEditResponse"];
            this.isCollectingEmail = _data["isCollectingEmail"];
            this.hasLimitOneResponsePerUser = _data["hasLimitOneResponsePerUser"];
            this.isAcceptingResponses = _data["isAcceptingResponses"];
            this.isQuiz = _data["isQuiz"];
            this.requiresLogin = _data["requiresLogin"];
        }
    }

    static fromJS(data: any): FormSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["canEditResponse"] = this.canEditResponse;
        data["isCollectingEmail"] = this.isCollectingEmail;
        data["hasLimitOneResponsePerUser"] = this.hasLimitOneResponsePerUser;
        data["isAcceptingResponses"] = this.isAcceptingResponses;
        data["isQuiz"] = this.isQuiz;
        data["requiresLogin"] = this.requiresLogin;
        return data;
    }
}

export interface IFormSettingsDto {
    title?: string | undefined;
    canEditResponse?: boolean;
    isCollectingEmail?: boolean;
    hasLimitOneResponsePerUser?: boolean;
    isAcceptingResponses?: boolean;
    isQuiz?: boolean;
    requiresLogin?: boolean;
}

export class FormWithDetailsDto implements IFormWithDetailsDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    title?: string | undefined;
    description?: string | undefined;
    tenantId?: string | undefined;
    canEditResponse?: boolean;
    isCollectingEmail?: boolean;
    hasLimitOneResponsePerUser?: boolean;
    isAcceptingResponses?: boolean;
    isQuiz?: boolean;
    requiresLogin?: boolean;
    questions?: QuestionDto[] | undefined;

    constructor(data?: IFormWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.tenantId = _data["tenantId"];
            this.canEditResponse = _data["canEditResponse"];
            this.isCollectingEmail = _data["isCollectingEmail"];
            this.hasLimitOneResponsePerUser = _data["hasLimitOneResponsePerUser"];
            this.isAcceptingResponses = _data["isAcceptingResponses"];
            this.isQuiz = _data["isQuiz"];
            this.requiresLogin = _data["requiresLogin"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(QuestionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["tenantId"] = this.tenantId;
        data["canEditResponse"] = this.canEditResponse;
        data["isCollectingEmail"] = this.isCollectingEmail;
        data["hasLimitOneResponsePerUser"] = this.hasLimitOneResponsePerUser;
        data["isAcceptingResponses"] = this.isAcceptingResponses;
        data["isQuiz"] = this.isQuiz;
        data["requiresLogin"] = this.requiresLogin;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFormWithDetailsDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    title?: string | undefined;
    description?: string | undefined;
    tenantId?: string | undefined;
    canEditResponse?: boolean;
    isCollectingEmail?: boolean;
    hasLimitOneResponsePerUser?: boolean;
    isAcceptingResponses?: boolean;
    isQuiz?: boolean;
    requiresLogin?: boolean;
    questions?: QuestionDto[] | undefined;
}

export class UpdateFormDto implements IUpdateFormDto {
    title!: string;
    description?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateFormDto {
    title: string;
    description?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class UpdateFormSettingInputDto implements IUpdateFormSettingInputDto {
    canEditResponse?: boolean;
    isCollectingEmail?: boolean;
    hasLimitOneResponsePerUser?: boolean;
    isAcceptingResponses?: boolean;
    isQuiz?: boolean;
    requiresLogin?: boolean;

    constructor(data?: IUpdateFormSettingInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canEditResponse = _data["canEditResponse"];
            this.isCollectingEmail = _data["isCollectingEmail"];
            this.hasLimitOneResponsePerUser = _data["hasLimitOneResponsePerUser"];
            this.isAcceptingResponses = _data["isAcceptingResponses"];
            this.isQuiz = _data["isQuiz"];
            this.requiresLogin = _data["requiresLogin"];
        }
    }

    static fromJS(data: any): UpdateFormSettingInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFormSettingInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canEditResponse"] = this.canEditResponse;
        data["isCollectingEmail"] = this.isCollectingEmail;
        data["hasLimitOneResponsePerUser"] = this.hasLimitOneResponsePerUser;
        data["isAcceptingResponses"] = this.isAcceptingResponses;
        data["isQuiz"] = this.isQuiz;
        data["requiresLogin"] = this.requiresLogin;
        return data;
    }
}

export interface IUpdateFormSettingInputDto {
    canEditResponse?: boolean;
    isCollectingEmail?: boolean;
    hasLimitOneResponsePerUser?: boolean;
    isAcceptingResponses?: boolean;
    isQuiz?: boolean;
    requiresLogin?: boolean;
}

export enum QuestionTypes {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class CreateQuestionDto implements ICreateQuestionDto {
    index!: number;
    title!: string;
    description?: string | undefined;
    isRequired?: boolean;
    hasOtherOption?: boolean;
    questionType!: QuestionTypes;
    choices?: ChoiceDto[] | undefined;

    constructor(data?: ICreateQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isRequired = _data["isRequired"];
            this.hasOtherOption = _data["hasOtherOption"];
            this.questionType = _data["questionType"];
            if (Array.isArray(_data["choices"])) {
                this.choices = [] as any;
                for (let item of _data["choices"])
                    this.choices!.push(ChoiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isRequired"] = this.isRequired;
        data["hasOtherOption"] = this.hasOtherOption;
        data["questionType"] = this.questionType;
        if (Array.isArray(this.choices)) {
            data["choices"] = [];
            for (let item of this.choices)
                data["choices"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateQuestionDto {
    index: number;
    title: string;
    description?: string | undefined;
    isRequired?: boolean;
    hasOtherOption?: boolean;
    questionType: QuestionTypes;
    choices?: ChoiceDto[] | undefined;
}

export class GetQuestionListDto implements IGetQuestionListDto {

    constructor(data?: IGetQuestionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetQuestionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuestionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetQuestionListDto {
}

export class QuestionDto implements IQuestionDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    formId?: string;
    index?: number;
    title?: string | undefined;
    description?: string | undefined;
    isRequired?: boolean;
    hasOtherOption?: boolean;
    questionType?: QuestionTypes;
    choices?: ChoiceDto[] | undefined;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.formId = _data["formId"];
            this.index = _data["index"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isRequired = _data["isRequired"];
            this.hasOtherOption = _data["hasOtherOption"];
            this.questionType = _data["questionType"];
            if (Array.isArray(_data["choices"])) {
                this.choices = [] as any;
                for (let item of _data["choices"])
                    this.choices!.push(ChoiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["formId"] = this.formId;
        data["index"] = this.index;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isRequired"] = this.isRequired;
        data["hasOtherOption"] = this.hasOtherOption;
        data["questionType"] = this.questionType;
        if (Array.isArray(this.choices)) {
            data["choices"] = [];
            for (let item of this.choices)
                data["choices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    formId?: string;
    index?: number;
    title?: string | undefined;
    description?: string | undefined;
    isRequired?: boolean;
    hasOtherOption?: boolean;
    questionType?: QuestionTypes;
    choices?: ChoiceDto[] | undefined;
}

export class UpdateQuestionDto implements IUpdateQuestionDto {
    index!: number;
    title!: string;
    description?: string | undefined;
    isRequired?: boolean;
    hasOtherOption?: boolean;
    questionType!: QuestionTypes;
    choices?: ChoiceDto[] | undefined;

    constructor(data?: IUpdateQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isRequired = _data["isRequired"];
            this.hasOtherOption = _data["hasOtherOption"];
            this.questionType = _data["questionType"];
            if (Array.isArray(_data["choices"])) {
                this.choices = [] as any;
                for (let item of _data["choices"])
                    this.choices!.push(ChoiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isRequired"] = this.isRequired;
        data["hasOtherOption"] = this.hasOtherOption;
        data["questionType"] = this.questionType;
        if (Array.isArray(this.choices)) {
            data["choices"] = [];
            for (let item of this.choices)
                data["choices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateQuestionDto {
    index: number;
    title: string;
    description?: string | undefined;
    isRequired?: boolean;
    hasOtherOption?: boolean;
    questionType: QuestionTypes;
    choices?: ChoiceDto[] | undefined;
}

export class CreateResponseDto implements ICreateResponseDto {
    email?: string | undefined;
    answers?: CreateAnswerDto[] | undefined;

    constructor(data?: ICreateResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(CreateAnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateResponseDto {
    email?: string | undefined;
    answers?: CreateAnswerDto[] | undefined;
}

export class FormResponseDetailedDto implements IFormResponseDetailedDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    userId?: string | undefined;
    formId?: string;
    email?: string | undefined;
    answers?: AnswerDto[] | undefined;

    constructor(data?: IFormResponseDetailedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.formId = _data["formId"];
            this.email = _data["email"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FormResponseDetailedDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormResponseDetailedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["formId"] = this.formId;
        data["email"] = this.email;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFormResponseDetailedDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    userId?: string | undefined;
    formId?: string;
    email?: string | undefined;
    answers?: AnswerDto[] | undefined;
}

export class FormResponseDto implements IFormResponseDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    userId?: string | undefined;
    formId?: string;
    email?: string | undefined;
    answers?: string[] | undefined;

    constructor(data?: IFormResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.formId = _data["formId"];
            this.email = _data["email"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): FormResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["formId"] = this.formId;
        data["email"] = this.email;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        return data;
    }
}

export interface IFormResponseDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    userId?: string | undefined;
    formId?: string;
    email?: string | undefined;
    answers?: string[] | undefined;
}

export class FormWithResponseDto implements IFormWithResponseDto {
    form?: FormDto;
    response?: FormResponseDto;

    constructor(data?: IFormWithResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.form = _data["form"] ? FormDto.fromJS(_data["form"]) : <any>undefined;
            this.response = _data["response"] ? FormResponseDto.fromJS(_data["response"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FormWithResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new FormWithResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["form"] = this.form ? this.form.toJSON() : <any>undefined;
        data["response"] = this.response ? this.response.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFormWithResponseDto {
    form?: FormDto;
    response?: FormResponseDto;
}

export class QuestionWithAnswersDto implements IQuestionWithAnswersDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    formId?: string;
    index?: number;
    title?: string | undefined;
    description?: string | undefined;
    isRequired?: boolean;
    hasOtherOption?: boolean;
    questionType?: QuestionTypes;
    choices?: ChoiceDto[] | undefined;
    answers?: AnswerDto[] | undefined;

    constructor(data?: IQuestionWithAnswersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.formId = _data["formId"];
            this.index = _data["index"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isRequired = _data["isRequired"];
            this.hasOtherOption = _data["hasOtherOption"];
            this.questionType = _data["questionType"];
            if (Array.isArray(_data["choices"])) {
                this.choices = [] as any;
                for (let item of _data["choices"])
                    this.choices!.push(ChoiceDto.fromJS(item));
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionWithAnswersDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionWithAnswersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["formId"] = this.formId;
        data["index"] = this.index;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isRequired"] = this.isRequired;
        data["hasOtherOption"] = this.hasOtherOption;
        data["questionType"] = this.questionType;
        if (Array.isArray(this.choices)) {
            data["choices"] = [];
            for (let item of this.choices)
                data["choices"].push(item.toJSON());
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionWithAnswersDto {
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    formId?: string;
    index?: number;
    title?: string | undefined;
    description?: string | undefined;
    isRequired?: boolean;
    hasOtherOption?: boolean;
    questionType?: QuestionTypes;
    choices?: ChoiceDto[] | undefined;
    answers?: AnswerDto[] | undefined;
}

export class UpdateResponseDto implements IUpdateResponseDto {
    id?: string;
    formId?: string;
    email?: string | undefined;
    answers?: AnswerDto[] | undefined;

    constructor(data?: IUpdateResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.formId = _data["formId"];
            this.email = _data["email"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(AnswerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["formId"] = this.formId;
        data["email"] = this.email;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateResponseDto {
    id?: string;
    formId?: string;
    email?: string | undefined;
    answers?: AnswerDto[] | undefined;
}

export class GatewayPlanCreateInput implements IGatewayPlanCreateInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    gateway!: string;
    externalId!: string;

    constructor(data?: IGatewayPlanCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.gateway = _data["gateway"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): GatewayPlanCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayPlanCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["gateway"] = this.gateway;
        data["externalId"] = this.externalId;
        return data;
    }
}

export interface IGatewayPlanCreateInput {
    extraProperties?: { [key: string]: any; } | undefined;
    gateway: string;
    externalId: string;
}

export class GatewayPlanUpdateInput implements IGatewayPlanUpdateInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    externalId!: string;

    constructor(data?: IGatewayPlanUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): GatewayPlanUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayPlanUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["externalId"] = this.externalId;
        return data;
    }
}

export interface IGatewayPlanUpdateInput {
    extraProperties?: { [key: string]: any; } | undefined;
    externalId: string;
}

export class PlanCreateInput implements IPlanCreateInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;

    constructor(data?: IPlanCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PlanCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new PlanCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IPlanCreateInput {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
}

export class PlanUpdateInput implements IPlanUpdateInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: IPlanUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): PlanUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new PlanUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IPlanUpdateInput {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    concurrencyStamp?: string | undefined;
}

export class GatewayDto implements IGatewayDto {
    name?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IGatewayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): GatewayDto {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IGatewayDto {
    name?: string | undefined;
    displayName?: string | undefined;
}

export class IPaymentRequestProductExtraParameterConfiguration implements IIPaymentRequestProductExtraParameterConfiguration {

    constructor(data?: IIPaymentRequestProductExtraParameterConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IPaymentRequestProductExtraParameterConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new IPaymentRequestProductExtraParameterConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIPaymentRequestProductExtraParameterConfiguration {
}

export class GatewayPlanDto implements IGatewayPlanDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    planId?: string;
    gateway?: string | undefined;
    externalId?: string | undefined;

    constructor(data?: IGatewayPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.planId = _data["planId"];
            this.gateway = _data["gateway"];
            this.externalId = _data["externalId"];
        }
    }

    static fromJS(data: any): GatewayPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["planId"] = this.planId;
        data["gateway"] = this.gateway;
        data["externalId"] = this.externalId;
        return data;
    }
}

export interface IGatewayPlanDto {
    extraProperties?: { [key: string]: any; } | undefined;
    planId?: string;
    gateway?: string | undefined;
    externalId?: string | undefined;
}

export class PlanDto implements IPlanDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): PlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IPlanDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class PaymentRequestCreateDto implements IPaymentRequestCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    currency?: string | undefined;
    products?: PaymentRequestProductCreateDto[] | undefined;

    constructor(data?: IPaymentRequestCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.currency = _data["currency"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(PaymentRequestProductCreateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentRequestCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["currency"] = this.currency;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaymentRequestCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    currency?: string | undefined;
    products?: PaymentRequestProductCreateDto[] | undefined;
}

export class PaymentRequestProductCreateDto implements IPaymentRequestProductCreateDto {
    code!: string;
    name!: string;
    unitPrice?: number;
    count?: number;
    totalPrice?: number | undefined;
    paymentType?: PaymentType;
    planId?: string | undefined;
    extraProperties?: { [key: string]: IPaymentRequestProductExtraParameterConfiguration; } | undefined;

    constructor(data?: IPaymentRequestProductCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.unitPrice = _data["unitPrice"];
            this.count = _data["count"];
            this.totalPrice = _data["totalPrice"];
            this.paymentType = _data["paymentType"];
            this.planId = _data["planId"];
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key] ? IPaymentRequestProductExtraParameterConfiguration.fromJS(_data["extraProperties"][key]) : new IPaymentRequestProductExtraParameterConfiguration();
                }
            }
        }
    }

    static fromJS(data: any): PaymentRequestProductCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestProductCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["unitPrice"] = this.unitPrice;
        data["count"] = this.count;
        data["totalPrice"] = this.totalPrice;
        data["paymentType"] = this.paymentType;
        data["planId"] = this.planId;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = this.extraProperties[key] ? this.extraProperties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IPaymentRequestProductCreateDto {
    code: string;
    name: string;
    unitPrice?: number;
    count?: number;
    totalPrice?: number | undefined;
    paymentType?: PaymentType;
    planId?: string | undefined;
    extraProperties?: { [key: string]: IPaymentRequestProductExtraParameterConfiguration; } | undefined;
}

export class PaymentRequestProductDto implements IPaymentRequestProductDto {
    paymentRequestId?: string;
    code?: string | undefined;
    name?: string | undefined;
    unitPrice?: number;
    count?: number;
    totalPrice?: number;
    paymentType?: PaymentType;
    readonly planId?: string;
    extraProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IPaymentRequestProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentRequestId = _data["paymentRequestId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.unitPrice = _data["unitPrice"];
            this.count = _data["count"];
            this.totalPrice = _data["totalPrice"];
            this.paymentType = _data["paymentType"];
            (<any>this).planId = _data["planId"];
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaymentRequestProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentRequestId"] = this.paymentRequestId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["unitPrice"] = this.unitPrice;
        data["count"] = this.count;
        data["totalPrice"] = this.totalPrice;
        data["paymentType"] = this.paymentType;
        data["planId"] = this.planId;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IPaymentRequestProductDto {
    paymentRequestId?: string;
    code?: string | undefined;
    name?: string | undefined;
    unitPrice?: number;
    count?: number;
    totalPrice?: number;
    paymentType?: PaymentType;
    planId?: string;
    extraProperties?: { [key: string]: any; } | undefined;
}

export class PaymentRequestStartDto implements IPaymentRequestStartDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    paymentRequestId?: string;
    returnUrl!: string;
    cancelUrl?: string | undefined;

    constructor(data?: IPaymentRequestStartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.paymentRequestId = _data["paymentRequestId"];
            this.returnUrl = _data["returnUrl"];
            this.cancelUrl = _data["cancelUrl"];
        }
    }

    static fromJS(data: any): PaymentRequestStartDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestStartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["paymentRequestId"] = this.paymentRequestId;
        data["returnUrl"] = this.returnUrl;
        data["cancelUrl"] = this.cancelUrl;
        return data;
    }
}

export interface IPaymentRequestStartDto {
    extraProperties?: { [key: string]: any; } | undefined;
    paymentRequestId?: string;
    returnUrl: string;
    cancelUrl?: string | undefined;
}

export class PaymentRequestStartResultDto implements IPaymentRequestStartResultDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    checkoutLink?: string | undefined;

    constructor(data?: IPaymentRequestStartResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.checkoutLink = _data["checkoutLink"];
        }
    }

    static fromJS(data: any): PaymentRequestStartResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestStartResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["checkoutLink"] = this.checkoutLink;
        return data;
    }
}

export interface IPaymentRequestStartResultDto {
    extraProperties?: { [key: string]: any; } | undefined;
    checkoutLink?: string | undefined;
}

export enum PaymentRequestState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class PaymentRequestWithDetailsDto implements IPaymentRequestWithDetailsDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    products?: PaymentRequestProductDto[] | undefined;
    currency?: string | undefined;
    state?: PaymentRequestState;
    failReason?: string | undefined;
    emailSendDate?: Date | undefined;
    gateway?: string | undefined;
    externalSubscriptionId?: string | undefined;
    totalPrice?: number;
    creationTime?: Date;

    constructor(data?: IPaymentRequestWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(PaymentRequestProductDto.fromJS(item));
            }
            this.currency = _data["currency"];
            this.state = _data["state"];
            this.failReason = _data["failReason"];
            this.emailSendDate = _data["emailSendDate"] ? new Date(_data["emailSendDate"].toString()) : <any>undefined;
            this.gateway = _data["gateway"];
            this.externalSubscriptionId = _data["externalSubscriptionId"];
            this.totalPrice = _data["totalPrice"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentRequestWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["currency"] = this.currency;
        data["state"] = this.state;
        data["failReason"] = this.failReason;
        data["emailSendDate"] = this.emailSendDate ? this.emailSendDate.toISOString() : <any>undefined;
        data["gateway"] = this.gateway;
        data["externalSubscriptionId"] = this.externalSubscriptionId;
        data["totalPrice"] = this.totalPrice;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPaymentRequestWithDetailsDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    products?: PaymentRequestProductDto[] | undefined;
    currency?: string | undefined;
    state?: PaymentRequestState;
    failReason?: string | undefined;
    emailSendDate?: Date | undefined;
    gateway?: string | undefined;
    externalSubscriptionId?: string | undefined;
    totalPrice?: number;
    creationTime?: Date;
}

export enum PaymentType {
    _0 = 0,
    _1 = 1,
}

export class EditionCreateDto implements IEditionCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName!: string;
    planId?: string | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.planId = _data["planId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["planId"] = this.planId;
        return data;
    }
}

export interface IEditionCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName: string;
    planId?: string | undefined;
}

export class EditionDto implements IEditionDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    displayName?: string | undefined;
    planId?: string | undefined;
    planName?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.planId = _data["planId"];
            this.planName = _data["planName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): EditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["planId"] = this.planId;
        data["planName"] = this.planName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IEditionDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    displayName?: string | undefined;
    planId?: string | undefined;
    planName?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class EditionLookupDto implements IEditionLookupDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    displayName?: string | undefined;

    constructor(data?: IEditionLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EditionLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEditionLookupDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    displayName?: string | undefined;
}

export class EditionUpdateDto implements IEditionUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName!: string;
    planId?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IEditionUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.planId = _data["planId"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): EditionUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["planId"] = this.planId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IEditionUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName: string;
    planId?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class SaasTenantConnectionStringsDto implements ISaasTenantConnectionStringsDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    default?: string | undefined;
    databases?: SaasTenantDatabaseConnectionStringsDto[] | undefined;

    constructor(data?: ISaasTenantConnectionStringsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.default = _data["default"];
            if (Array.isArray(_data["databases"])) {
                this.databases = [] as any;
                for (let item of _data["databases"])
                    this.databases!.push(SaasTenantDatabaseConnectionStringsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaasTenantConnectionStringsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantConnectionStringsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["default"] = this.default;
        if (Array.isArray(this.databases)) {
            data["databases"] = [];
            for (let item of this.databases)
                data["databases"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaasTenantConnectionStringsDto {
    extraProperties?: { [key: string]: any; } | undefined;
    default?: string | undefined;
    databases?: SaasTenantDatabaseConnectionStringsDto[] | undefined;
}

export class SaasTenantCreateDto implements ISaasTenantCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    editionId?: string | undefined;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    editionEndDateUtc?: Date | undefined;
    adminEmailAddress!: string;
    adminPassword!: string;
    connectionStrings?: SaasTenantConnectionStringsDto;

    constructor(data?: ISaasTenantCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.editionId = _data["editionId"];
            this.activationState = _data["activationState"];
            this.activationEndDate = _data["activationEndDate"] ? new Date(_data["activationEndDate"].toString()) : <any>undefined;
            this.editionEndDateUtc = _data["editionEndDateUtc"] ? new Date(_data["editionEndDateUtc"].toString()) : <any>undefined;
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.connectionStrings = _data["connectionStrings"] ? SaasTenantConnectionStringsDto.fromJS(_data["connectionStrings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaasTenantCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["editionId"] = this.editionId;
        data["activationState"] = this.activationState;
        data["activationEndDate"] = this.activationEndDate ? this.activationEndDate.toISOString() : <any>undefined;
        data["editionEndDateUtc"] = this.editionEndDateUtc ? this.editionEndDateUtc.toISOString() : <any>undefined;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionStrings"] = this.connectionStrings ? this.connectionStrings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISaasTenantCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    editionId?: string | undefined;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    editionEndDateUtc?: Date | undefined;
    adminEmailAddress: string;
    adminPassword: string;
    connectionStrings?: SaasTenantConnectionStringsDto;
}

export class SaasTenantDatabaseConnectionStringsDto implements ISaasTenantDatabaseConnectionStringsDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    databaseName?: string | undefined;
    connectionString?: string | undefined;

    constructor(data?: ISaasTenantDatabaseConnectionStringsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.databaseName = _data["databaseName"];
            this.connectionString = _data["connectionString"];
        }
    }

    static fromJS(data: any): SaasTenantDatabaseConnectionStringsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantDatabaseConnectionStringsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["databaseName"] = this.databaseName;
        data["connectionString"] = this.connectionString;
        return data;
    }
}

export interface ISaasTenantDatabaseConnectionStringsDto {
    extraProperties?: { [key: string]: any; } | undefined;
    databaseName?: string | undefined;
    connectionString?: string | undefined;
}

export class SaasTenantDatabasesDto implements ISaasTenantDatabasesDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    databases?: string[] | undefined;

    constructor(data?: ISaasTenantDatabasesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            if (Array.isArray(_data["databases"])) {
                this.databases = [] as any;
                for (let item of _data["databases"])
                    this.databases!.push(item);
            }
        }
    }

    static fromJS(data: any): SaasTenantDatabasesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantDatabasesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        if (Array.isArray(this.databases)) {
            data["databases"] = [];
            for (let item of this.databases)
                data["databases"].push(item);
        }
        return data;
    }
}

export interface ISaasTenantDatabasesDto {
    extraProperties?: { [key: string]: any; } | undefined;
    databases?: string[] | undefined;
}

export class SaasTenantDto implements ISaasTenantDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    editionId?: string | undefined;
    editionEndDateUtc?: Date | undefined;
    editionName?: string | undefined;
    hasDefaultConnectionString?: boolean;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: ISaasTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.editionId = _data["editionId"];
            this.editionEndDateUtc = _data["editionEndDateUtc"] ? new Date(_data["editionEndDateUtc"].toString()) : <any>undefined;
            this.editionName = _data["editionName"];
            this.hasDefaultConnectionString = _data["hasDefaultConnectionString"];
            this.activationState = _data["activationState"];
            this.activationEndDate = _data["activationEndDate"] ? new Date(_data["activationEndDate"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): SaasTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["editionId"] = this.editionId;
        data["editionEndDateUtc"] = this.editionEndDateUtc ? this.editionEndDateUtc.toISOString() : <any>undefined;
        data["editionName"] = this.editionName;
        data["hasDefaultConnectionString"] = this.hasDefaultConnectionString;
        data["activationState"] = this.activationState;
        data["activationEndDate"] = this.activationEndDate ? this.activationEndDate.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ISaasTenantDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    editionId?: string | undefined;
    editionEndDateUtc?: Date | undefined;
    editionName?: string | undefined;
    hasDefaultConnectionString?: boolean;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    concurrencyStamp?: string | undefined;
}

export class SaasTenantSetPasswordDto implements ISaasTenantSetPasswordDto {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: ISaasTenantSetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SaasTenantSetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantSetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ISaasTenantSetPasswordDto {
    username?: string | undefined;
    password?: string | undefined;
}

export class SaasTenantUpdateDto implements ISaasTenantUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    editionId?: string | undefined;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    editionEndDateUtc?: Date | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: ISaasTenantUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.editionId = _data["editionId"];
            this.activationState = _data["activationState"];
            this.activationEndDate = _data["activationEndDate"] ? new Date(_data["activationEndDate"].toString()) : <any>undefined;
            this.editionEndDateUtc = _data["editionEndDateUtc"] ? new Date(_data["editionEndDateUtc"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): SaasTenantUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["editionId"] = this.editionId;
        data["activationState"] = this.activationState;
        data["activationEndDate"] = this.activationEndDate ? this.activationEndDate.toISOString() : <any>undefined;
        data["editionEndDateUtc"] = this.editionEndDateUtc ? this.editionEndDateUtc.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ISaasTenantUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    editionId?: string | undefined;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    editionEndDateUtc?: Date | undefined;
    concurrencyStamp?: string | undefined;
}

export class GetEditionUsageStatisticsResultDto implements IGetEditionUsageStatisticsResultDto {
    data?: { [key: string]: number; } | undefined;

    constructor(data?: IGetEditionUsageStatisticsResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetEditionUsageStatisticsResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionUsageStatisticsResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface IGetEditionUsageStatisticsResultDto {
    data?: { [key: string]: number; } | undefined;
}

export enum TenantActivationState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}