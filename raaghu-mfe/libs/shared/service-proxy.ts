//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import Instance  from './interceptor';
import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ServiceProxy {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : Instance;

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param includeTypes (optional) 
     * @return Success
     */
    apiDefinition(includeTypes: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationApiDescriptionModel> {
        let url_ = this.baseUrl + "/api/abp/api-definition?";
        if (includeTypes === null)
            throw new Error("The parameter 'includeTypes' cannot be null.");
        else if (includeTypes !== undefined)
            url_ += "IncludeTypes=" + encodeURIComponent("" + includeTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApiDefinition(_response);
        });
    }

    protected processApiDefinition(response: AxiosResponse): Promise<ApplicationApiDescriptionModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationApiDescriptionModel.fromJS(resultData200);
            return Promise.resolve<ApplicationApiDescriptionModel>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationApiDescriptionModel>(null as any);
    }

    /**
     * @param includeLocalizationResources (optional) 
     * @return Success
     */
    applicationConfiguration(includeLocalizationResources: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/abp/application-configuration?";
        if (includeLocalizationResources === null)
            throw new Error("The parameter 'includeLocalizationResources' cannot be null.");
        else if (includeLocalizationResources !== undefined)
            url_ += "IncludeLocalizationResources=" + encodeURIComponent("" + includeLocalizationResources) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationConfiguration(_response);
        });
    }

    protected processApplicationConfiguration(response: AxiosResponse): Promise<ApplicationConfigurationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationConfigurationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationConfigurationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationConfigurationDto>(null as any);
    }

    /**
     * @param onlyDynamics (optional) 
     * @return Success
     */
    applicationLocalization(cultureName: string, onlyDynamics: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationLocalizationDto> {
        let url_ = this.baseUrl + "/api/abp/application-localization?";
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined and cannot be null.");
        else
            url_ += "CultureName=" + encodeURIComponent("" + cultureName) + "&";
        if (onlyDynamics === null)
            throw new Error("The parameter 'onlyDynamics' cannot be null.");
        else if (onlyDynamics !== undefined)
            url_ += "OnlyDynamics=" + encodeURIComponent("" + onlyDynamics) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationLocalization(_response);
        });
    }

    protected processApplicationLocalization(response: AxiosResponse): Promise<ApplicationLocalizationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationLocalizationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationLocalizationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationLocalizationDto>(null as any);
    }

    /**
     * @return Success
     */
    byName(name: string , cancelToken?: CancelToken | undefined): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/tenants/by-name/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByName(_response);
        });
    }

    protected processByName(response: AxiosResponse): Promise<FindTenantResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200);
            return Promise.resolve<FindTenantResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(null as any);
    }

    /**
     * @return Success
     */
    byId(id: string , cancelToken?: CancelToken | undefined): Promise<FindTenantResultDto> {
        let url_ = this.baseUrl + "/api/abp/multi-tenancy/tenants/by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processById(_response);
        });
    }

    protected processById(response: AxiosResponse): Promise<FindTenantResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindTenantResultDto.fromJS(resultData200);
            return Promise.resolve<FindTenantResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindTenantResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-password-reset-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendPasswordResetCode(_response);
        });
    }

    protected processSendPasswordResetCode(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyPasswordResetToken(body: VerifyPasswordResetTokenInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/verify-password-reset-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyPasswordResetToken(_response);
        });
    }

    protected processVerifyPasswordResetToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    confirmationState(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserConfirmationStateDto> {
        let url_ = this.baseUrl + "/api/account/confirmation-state?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmationState(_response);
        });
    }

    protected processConfirmationState(response: AxiosResponse): Promise<IdentityUserConfirmationStateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserConfirmationStateDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserConfirmationStateDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserConfirmationStateDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPhoneNumberConfirmationToken(body: SendPhoneNumberConfirmationTokenDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-phone-number-confirmation-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendPhoneNumberConfirmationToken(_response);
        });
    }

    protected processSendPhoneNumberConfirmationToken(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailConfirmationToken(body: SendEmailConfirmationTokenDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-email-confirmation-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendEmailConfirmationToken(_response);
        });
    }

    protected processSendEmailConfirmationToken(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyEmailConfirmationToken(body: VerifyEmailConfirmationTokenInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/verify-email-confirmation-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyEmailConfirmationToken(_response);
        });
    }

    protected processVerifyEmailConfirmationToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmPhoneNumber(body: ConfirmPhoneNumberInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/confirm-phone-number";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmPhoneNumber(_response);
        });
    }

    protected processConfirmPhoneNumber(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmEmail(body: ConfirmEmailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/confirm-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param type (optional) 
     * @param imageContent (optional) 
     * @return Success
     */
    profilePicturePOST(type: ProfilePictureType | undefined, imageContent: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/profile-picture?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imageContent === null || imageContent === undefined)
            throw new Error("The parameter 'imageContent' cannot be null.");
        else
            content_.append("ImageContent", imageContent.data, imageContent.fileName ? imageContent.fileName : "ImageContent");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfilePicturePOST(_response);
        });
    }

    protected processProfilePicturePOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    profilePictureGET(id: string , cancelToken?: CancelToken | undefined): Promise<ProfilePictureSourceDto> {
        let url_ = this.baseUrl + "/api/account/profile-picture/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfilePictureGET(_response);
        });
    }

    protected processProfilePictureGET(response: AxiosResponse): Promise<ProfilePictureSourceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfilePictureSourceDto.fromJS(resultData200);
            return Promise.resolve<ProfilePictureSourceDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfilePictureSourceDto>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorProviders(userId: string, token: string , cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/account/two-factor-providers?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "Token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorProviders(_response);
        });
    }

    protected processTwoFactorProviders(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorCode(body: SendTwoFactorCodeInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/send-two-factor-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendTwoFactorCode(_response);
        });
    }

    protected processSendTwoFactorCode(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param applicationName (optional) 
     * @param identity (optional) 
     * @param action (optional) 
     * @param userName (optional) 
     * @param clientId (optional) 
     * @param correlationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    securityLogs(startTime: Date | undefined, endTime: Date | undefined, applicationName: string | undefined, identity: string | undefined, action: string | undefined, userName: string | undefined, clientId: string | undefined, correlationId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/account/security-logs?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (applicationName === null)
            throw new Error("The parameter 'applicationName' cannot be null.");
        else if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (identity === null)
            throw new Error("The parameter 'identity' cannot be null.");
        else if (identity !== undefined)
            url_ += "Identity=" + encodeURIComponent("" + identity) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "Action=" + encodeURIComponent("" + action) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (correlationId === null)
            throw new Error("The parameter 'correlationId' cannot be null.");
        else if (correlationId !== undefined)
            url_ += "CorrelationId=" + encodeURIComponent("" + correlationId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSecurityLogs(_response);
        });
    }

    protected processSecurityLogs(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    profilePictureFile(id: string , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/account/profile-picture-file/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfilePictureFile(_response);
        });
    }

    protected processProfilePictureFile(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param captchaResponse (optional) 
     * @return Success
     */
    recaptchaValidate(captchaResponse: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/recaptcha-validate?";
        if (captchaResponse === null)
            throw new Error("The parameter 'captchaResponse' cannot be null.");
        else if (captchaResponse !== undefined)
            url_ += "captchaResponse=" + encodeURIComponent("" + captchaResponse) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecaptchaValidate(_response);
        });
    }

    protected processRecaptchaValidate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalProviderGET(  cancelToken?: CancelToken | undefined): Promise<ExternalProviderDto> {
        let url_ = this.baseUrl + "/api/account/external-provider";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalProviderGET(_response);
        });
    }

    protected processExternalProviderGET(response: AxiosResponse): Promise<ExternalProviderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalProviderDto.fromJS(resultData200);
            return Promise.resolve<ExternalProviderDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalProviderDto>(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param name (optional) 
     * @return Success
     */
    byName2(tenantId: string | undefined, name: string | undefined , cancelToken?: CancelToken | undefined): Promise<ExternalProviderItemWithSecretDto> {
        let url_ = this.baseUrl + "/api/account/external-provider/by-name?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByName2(_response);
        });
    }

    protected processByName2(response: AxiosResponse): Promise<ExternalProviderItemWithSecretDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalProviderItemWithSecretDto.fromJS(resultData200);
            return Promise.resolve<ExternalProviderItemWithSecretDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalProviderItemWithSecretDto>(null as any);
    }

    /**
     * @return Success
     */
    settingsGET(  cancelToken?: CancelToken | undefined): Promise<AccountSettingsDto> {
        let url_ = this.baseUrl + "/api/account-admin/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsGET(_response);
        });
    }

    protected processSettingsGET(response: AxiosResponse): Promise<AccountSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountSettingsDto.fromJS(resultData200);
            return Promise.resolve<AccountSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    settingsPUT(body: AccountSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account-admin/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsPUT(_response);
        });
    }

    protected processSettingsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorGET(  cancelToken?: CancelToken | undefined): Promise<AccountTwoFactorSettingsDto> {
        let url_ = this.baseUrl + "/api/account-admin/settings/two-factor";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorGET(_response);
        });
    }

    protected processTwoFactorGET(response: AxiosResponse): Promise<AccountTwoFactorSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountTwoFactorSettingsDto.fromJS(resultData200);
            return Promise.resolve<AccountTwoFactorSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountTwoFactorSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    twoFactorPUT(body: AccountTwoFactorSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account-admin/settings/two-factor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorPUT(_response);
        });
    }

    protected processTwoFactorPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    recaptchaGET(  cancelToken?: CancelToken | undefined): Promise<AccountRecaptchaSettingsDto> {
        let url_ = this.baseUrl + "/api/account-admin/settings/recaptcha";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecaptchaGET(_response);
        });
    }

    protected processRecaptchaGET(response: AxiosResponse): Promise<AccountRecaptchaSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountRecaptchaSettingsDto.fromJS(resultData200);
            return Promise.resolve<AccountRecaptchaSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountRecaptchaSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recaptchaPUT(body: AccountRecaptchaSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account-admin/settings/recaptcha";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecaptchaPUT(_response);
        });
    }

    protected processRecaptchaPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalProviderGET2(  cancelToken?: CancelToken | undefined): Promise<AccountExternalProviderSettingsDto> {
        let url_ = this.baseUrl + "/api/account-admin/settings/external-provider";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalProviderGET2(_response);
        });
    }

    protected processExternalProviderGET2(response: AxiosResponse): Promise<AccountExternalProviderSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccountExternalProviderSettingsDto.fromJS(resultData200);
            return Promise.resolve<AccountExternalProviderSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccountExternalProviderSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalProviderPUT(body: UpdateExternalProviderDto[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account-admin/settings/external-provider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalProviderPUT(_response);
        });
    }

    protected processExternalProviderPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    applicationsGET(id: string , cancelToken?: CancelToken | undefined): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/openiddict/applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsGET(_response);
        });
    }

    protected processApplicationsGET(response: AxiosResponse): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applicationsPUT(id: string, body: UpdateApplicationInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/openiddict/applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsPUT(_response);
        });
    }

    protected processApplicationsPUT(response: AxiosResponse): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    applicationsGET2(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/openiddict/applications?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsGET2(_response);
        });
    }

    protected processApplicationsGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    applicationsPOST(body: CreateApplicationInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationDto> {
        let url_ = this.baseUrl + "/api/openiddict/applications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsPOST(_response);
        });
    }

    protected processApplicationsPOST(response: AxiosResponse): Promise<ApplicationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationDto.fromJS(resultData200);
            return Promise.resolve<ApplicationDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    applicationsDELETE(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/openiddict/applications?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplicationsDELETE(_response);
        });
    }

    protected processApplicationsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param url (optional) 
     * @param userName (optional) 
     * @param applicationName (optional) 
     * @param clientIpAddress (optional) 
     * @param correlationId (optional) 
     * @param httpMethod (optional) 
     * @param httpStatusCode (optional) 
     * @param maxExecutionDuration (optional) 
     * @param minExecutionDuration (optional) 
     * @param hasException (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    auditLogs(startTime: Date | undefined, endTime: Date | undefined, url: string | undefined, userName: string | undefined, applicationName: string | undefined, clientIpAddress: string | undefined, correlationId: string | undefined, httpMethod: string | undefined, httpStatusCode: HttpStatusCode | undefined, maxExecutionDuration: number | undefined, minExecutionDuration: number | undefined, hasException: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (url === null)
            throw new Error("The parameter 'url' cannot be null.");
        else if (url !== undefined)
            url_ += "Url=" + encodeURIComponent("" + url) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (applicationName === null)
            throw new Error("The parameter 'applicationName' cannot be null.");
        else if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (clientIpAddress === null)
            throw new Error("The parameter 'clientIpAddress' cannot be null.");
        else if (clientIpAddress !== undefined)
            url_ += "ClientIpAddress=" + encodeURIComponent("" + clientIpAddress) + "&";
        if (correlationId === null)
            throw new Error("The parameter 'correlationId' cannot be null.");
        else if (correlationId !== undefined)
            url_ += "CorrelationId=" + encodeURIComponent("" + correlationId) + "&";
        if (httpMethod === null)
            throw new Error("The parameter 'httpMethod' cannot be null.");
        else if (httpMethod !== undefined)
            url_ += "HttpMethod=" + encodeURIComponent("" + httpMethod) + "&";
        if (httpStatusCode === null)
            throw new Error("The parameter 'httpStatusCode' cannot be null.");
        else if (httpStatusCode !== undefined)
            url_ += "HttpStatusCode=" + encodeURIComponent("" + httpStatusCode) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuditLogs(_response);
        });
    }

    protected processAuditLogs(response: AxiosResponse): Promise<PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    auditLogs2(id: string , cancelToken?: CancelToken | undefined): Promise<AuditLogDto> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuditLogs2(_response);
        });
    }

    protected processAuditLogs2(response: AxiosResponse): Promise<AuditLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuditLogDto.fromJS(resultData200);
            return Promise.resolve<AuditLogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuditLogDto>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    errorRate(startDate: Date | undefined, endDate: Date | undefined , cancelToken?: CancelToken | undefined): Promise<GetErrorRateOutput> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/statistics/error-rate?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processErrorRate(_response);
        });
    }

    protected processErrorRate(response: AxiosResponse): Promise<GetErrorRateOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetErrorRateOutput.fromJS(resultData200);
            return Promise.resolve<GetErrorRateOutput>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetErrorRateOutput>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    averageExecutionDurationPerDay(startDate: Date | undefined, endDate: Date | undefined , cancelToken?: CancelToken | undefined): Promise<GetAverageExecutionDurationPerDayOutput> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/statistics/average-execution-duration-per-day?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAverageExecutionDurationPerDay(_response);
        });
    }

    protected processAverageExecutionDurationPerDay(response: AxiosResponse): Promise<GetAverageExecutionDurationPerDayOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAverageExecutionDurationPerDayOutput.fromJS(resultData200);
            return Promise.resolve<GetAverageExecutionDurationPerDayOutput>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAverageExecutionDurationPerDayOutput>(null as any);
    }

    /**
     * @param auditLogId (optional) 
     * @param entityChangeType (optional) 
     * @param entityId (optional) 
     * @param entityTypeFullName (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    entityChanges(auditLogId: string | undefined, entityChangeType: EntityChangeType | undefined, entityId: string | undefined, entityTypeFullName: string | undefined, startDate: Date | undefined, endDate: Date | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/entity-changes?";
        if (auditLogId === null)
            throw new Error("The parameter 'auditLogId' cannot be null.");
        else if (auditLogId !== undefined)
            url_ += "AuditLogId=" + encodeURIComponent("" + auditLogId) + "&";
        if (entityChangeType === null)
            throw new Error("The parameter 'entityChangeType' cannot be null.");
        else if (entityChangeType !== undefined)
            url_ += "EntityChangeType=" + encodeURIComponent("" + entityChangeType) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityChanges(_response);
        });
    }

    protected processEntityChanges(response: AxiosResponse): Promise<PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param entityTypeFullName (optional) 
     * @return Success
     */
    entityChangesWithUsername(entityId: string | undefined, entityTypeFullName: string | undefined , cancelToken?: CancelToken | undefined): Promise<EntityChangeWithUsernameDto[]> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/entity-changes-with-username?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityChangesWithUsername(_response);
        });
    }

    protected processEntityChangesWithUsername(response: AxiosResponse): Promise<EntityChangeWithUsernameDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityChangeWithUsernameDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<EntityChangeWithUsernameDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityChangeWithUsernameDto[]>(null as any);
    }

    /**
     * @return Success
     */
    entityChangeWithUsername(entityChangeId: string , cancelToken?: CancelToken | undefined): Promise<EntityChangeWithUsernameDto> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/entity-change-with-username/{entityChangeId}";
        if (entityChangeId === undefined || entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' must be defined.");
        url_ = url_.replace("{entityChangeId}", encodeURIComponent("" + entityChangeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityChangeWithUsername(_response);
        });
    }

    protected processEntityChangeWithUsername(response: AxiosResponse): Promise<EntityChangeWithUsernameDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityChangeWithUsernameDto.fromJS(resultData200);
            return Promise.resolve<EntityChangeWithUsernameDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityChangeWithUsernameDto>(null as any);
    }

    /**
     * @return Success
     */
    entityChanges2(entityChangeId: string , cancelToken?: CancelToken | undefined): Promise<EntityChangeDto> {
        let url_ = this.baseUrl + "/api/audit-logging/audit-logs/entity-changes/{entityChangeId}";
        if (entityChangeId === undefined || entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' must be defined.");
        url_ = url_.replace("{entityChangeId}", encodeURIComponent("" + entityChangeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEntityChanges2(_response);
        });
    }

    protected processEntityChanges2(response: AxiosResponse): Promise<EntityChangeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EntityChangeDto.fromJS(resultData200);
            return Promise.resolve<EntityChangeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EntityChangeDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    claimTypesGET(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/claim-types?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesGET(_response);
        });
    }

    protected processClaimTypesGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claimTypesPOST(body: CreateClaimTypeDto | undefined , cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto> {
        let url_ = this.baseUrl + "/api/identity/claim-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesPOST(_response);
        });
    }

    protected processClaimTypesPOST(response: AxiosResponse): Promise<ClaimTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClaimTypeDto.fromJS(resultData200);
            return Promise.resolve<ClaimTypeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto>(null as any);
    }

    /**
     * @return Success
     */
    claimTypesGET2(id: string , cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto> {
        let url_ = this.baseUrl + "/api/identity/claim-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesGET2(_response);
        });
    }

    protected processClaimTypesGET2(response: AxiosResponse): Promise<ClaimTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClaimTypeDto.fromJS(resultData200);
            return Promise.resolve<ClaimTypeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claimTypesPUT(id: string, body: UpdateClaimTypeDto | undefined , cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto> {
        let url_ = this.baseUrl + "/api/identity/claim-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesPUT(_response);
        });
    }

    protected processClaimTypesPUT(response: AxiosResponse): Promise<ClaimTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ClaimTypeDto.fromJS(resultData200);
            return Promise.resolve<ClaimTypeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto>(null as any);
    }

    /**
     * @return Success
     */
    claimTypesDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/claim-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimTypesDELETE(_response);
        });
    }

    protected processClaimTypesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    editionsGET(id: string , cancelToken?: CancelToken | undefined): Promise<EditionDto> {
        let url_ = this.baseUrl + "/api/saas/editions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsGET(_response);
        });
    }

    protected processEditionsGET(response: AxiosResponse): Promise<EditionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EditionDto.fromJS(resultData200);
            return Promise.resolve<EditionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EditionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editionsPUT(id: string, body: EditionUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<EditionDto> {
        let url_ = this.baseUrl + "/api/saas/editions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsPUT(_response);
        });
    }

    protected processEditionsPUT(response: AxiosResponse): Promise<EditionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EditionDto.fromJS(resultData200);
            return Promise.resolve<EditionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EditionDto>(null as any);
    }

    /**
     * @return Success
     */
    editionsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/editions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsDELETE(_response);
        });
    }

    protected processEditionsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    editionsGET2(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/saas/editions?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsGET2(_response);
        });
    }

    protected processEditionsGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editionsPOST(body: EditionCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<EditionDto> {
        let url_ = this.baseUrl + "/api/saas/editions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsPOST(_response);
        });
    }

    protected processEditionsPOST(response: AxiosResponse): Promise<EditionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EditionDto.fromJS(resultData200);
            return Promise.resolve<EditionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EditionDto>(null as any);
    }

    /**
     * @return Success
     */
    usageStatistic(  cancelToken?: CancelToken | undefined): Promise<GetEditionUsageStatisticsResultDto> {
        let url_ = this.baseUrl + "/api/saas/editions/statistics/usage-statistic";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsageStatistic(_response);
        });
    }

    protected processUsageStatistic(response: AxiosResponse): Promise<GetEditionUsageStatisticsResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetEditionUsageStatisticsResultDto.fromJS(resultData200);
            return Promise.resolve<GetEditionUsageStatisticsResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetEditionUsageStatisticsResultDto>(null as any);
    }

    /**
     * @return Success
     */
    planLookup(  cancelToken?: CancelToken | undefined): Promise<PlanDto[]> {
        let url_ = this.baseUrl + "/api/saas/editions/plan-lookup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPlanLookup(_response);
        });
    }

    protected processPlanLookup(response: AxiosResponse): Promise<PlanDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlanDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PlanDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto[]>(null as any);
    }

    /**
     * @param editionId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    subscription(editionId: string | undefined, tenantId: string | undefined , cancelToken?: CancelToken | undefined): Promise<PaymentRequestWithDetailsDto> {
        let url_ = this.baseUrl + "/api/saas/subscription?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscription(_response);
        });
    }

    protected processSubscription(response: AxiosResponse): Promise<PaymentRequestWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaymentRequestWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<PaymentRequestWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaymentRequestWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    emailingGET(  cancelToken?: CancelToken | undefined): Promise<EmailSettingsDto> {
        let url_ = this.baseUrl + "/api/setting-management/emailing";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailingGET(_response);
        });
    }

    protected processEmailingGET(response: AxiosResponse): Promise<EmailSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EmailSettingsDto.fromJS(resultData200);
            return Promise.resolve<EmailSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EmailSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    emailingPOST(body: UpdateEmailSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/setting-management/emailing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmailingPOST(_response);
        });
    }

    protected processEmailingPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/setting-management/emailing/send-test-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendTestEmail(_response);
        });
    }

    protected processSendTestEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    externalLogin(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/external-login";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalLogin(_response);
        });
    }

    protected processExternalLogin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    featuresGET(providerName: string | undefined, providerKey: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetFeatureListResultDto> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesGET(_response);
        });
    }

    protected processFeaturesGET(response: AxiosResponse): Promise<GetFeatureListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetFeatureListResultDto.fromJS(resultData200);
            return Promise.resolve<GetFeatureListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetFeatureListResultDto>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    featuresPUT(providerName: string | undefined, providerKey: string | undefined, body: UpdateFeaturesDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesPUT(_response);
        });
    }

    protected processFeaturesPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    featuresDELETE(providerName: string | undefined, providerKey: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/feature-management/features?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFeaturesDELETE(_response);
        });
    }

    protected processFeaturesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    prepareData(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/gdpr/requests/prepare-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPrepareData(_response);
        });
    }

    protected processPrepareData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    downloadToken(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<DownloadTokenResultDto> {
        let url_ = this.baseUrl + "/api/gdpr/requests/download-token?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDownloadToken(_response);
        });
    }

    protected processDownloadToken(response: AxiosResponse): Promise<DownloadTokenResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DownloadTokenResultDto.fromJS(resultData200);
            return Promise.resolve<DownloadTokenResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DownloadTokenResultDto>(null as any);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    data(requestId: string, token: string | undefined , cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/gdpr/requests/data/{requestId}?";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processData(_response);
        });
    }

    protected processData(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    isRequestAllowed(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/gdpr/requests/is-request-allowed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsRequestAllowed(_response);
        });
    }

    protected processIsRequestAllowed(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    list(userId: string | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/gdpr/requests/list?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    requests(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/gdpr/requests";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequests(_response);
        });
    }

    protected processRequests(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    all(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/language-management/languages/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: AxiosResponse): Promise<ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param resourceName (optional) 
     * @param baseCultureName (optional) 
     * @param targetCultureName (optional) 
     * @param getOnlyEmptyValues (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    languagesGET(filter: string | undefined, resourceName: string | undefined, baseCultureName: string | undefined, targetCultureName: string | undefined, getOnlyEmptyValues: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/language-management/languages?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (resourceName === null)
            throw new Error("The parameter 'resourceName' cannot be null.");
        else if (resourceName !== undefined)
            url_ += "ResourceName=" + encodeURIComponent("" + resourceName) + "&";
        if (baseCultureName === null)
            throw new Error("The parameter 'baseCultureName' cannot be null.");
        else if (baseCultureName !== undefined)
            url_ += "BaseCultureName=" + encodeURIComponent("" + baseCultureName) + "&";
        if (targetCultureName === null)
            throw new Error("The parameter 'targetCultureName' cannot be null.");
        else if (targetCultureName !== undefined)
            url_ += "TargetCultureName=" + encodeURIComponent("" + targetCultureName) + "&";
        if (getOnlyEmptyValues === null)
            throw new Error("The parameter 'getOnlyEmptyValues' cannot be null.");
        else if (getOnlyEmptyValues !== undefined)
            url_ += "GetOnlyEmptyValues=" + encodeURIComponent("" + getOnlyEmptyValues) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesGET(_response);
        });
    }

    protected processLanguagesGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    languagesPOST(body: CreateLanguageDto | undefined , cancelToken?: CancelToken | undefined): Promise<LanguageDto> {
        let url_ = this.baseUrl + "/api/language-management/languages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesPOST(_response);
        });
    }

    protected processLanguagesPOST(response: AxiosResponse): Promise<LanguageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageDto.fromJS(resultData200);
            return Promise.resolve<LanguageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageDto>(null as any);
    }

    /**
     * @return Success
     */
    languagesGET2(id: string , cancelToken?: CancelToken | undefined): Promise<LanguageDto> {
        let url_ = this.baseUrl + "/api/language-management/languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesGET2(_response);
        });
    }

    protected processLanguagesGET2(response: AxiosResponse): Promise<LanguageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageDto.fromJS(resultData200);
            return Promise.resolve<LanguageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    languagesPUT(id: string, body: UpdateLanguageDto | undefined , cancelToken?: CancelToken | undefined): Promise<LanguageDto> {
        let url_ = this.baseUrl + "/api/language-management/languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesPUT(_response);
        });
    }

    protected processLanguagesPUT(response: AxiosResponse): Promise<LanguageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageDto.fromJS(resultData200);
            return Promise.resolve<LanguageDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageDto>(null as any);
    }

    /**
     * @return Success
     */
    languagesDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/language-management/languages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguagesDELETE(_response);
        });
    }

    protected processLanguagesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    setAsDefault(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/language-management/languages/{id}/set-as-default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetAsDefault(_response);
        });
    }

    protected processSetAsDefault(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    resources(  cancelToken?: CancelToken | undefined): Promise<LanguageResourceDto[]> {
        let url_ = this.baseUrl + "/api/language-management/languages/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResources(_response);
        });
    }

    protected processResources(response: AxiosResponse): Promise<LanguageResourceDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageResourceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LanguageResourceDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageResourceDto[]>(null as any);
    }

    /**
     * @return Success
     */
    cultureList(  cancelToken?: CancelToken | undefined): Promise<CultureInfoDto[]> {
        let url_ = this.baseUrl + "/api/language-management/languages/culture-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCultureList(_response);
        });
    }

    protected processCultureList(response: AxiosResponse): Promise<CultureInfoDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CultureInfoDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CultureInfoDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CultureInfoDto[]>(null as any);
    }

    /**
     * @return Success
     */
    flagList(  cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/language-management/languages/flag-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFlagList(_response);
        });
    }

    protected processFlagList(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param resourceName (optional) 
     * @param baseCultureName (optional) 
     * @param targetCultureName (optional) 
     * @param getOnlyEmptyValues (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    languageTextsGET(filter: string | undefined, resourceName: string | undefined, baseCultureName: string | undefined, targetCultureName: string | undefined, getOnlyEmptyValues: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/language-management/language-texts?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (resourceName === null)
            throw new Error("The parameter 'resourceName' cannot be null.");
        else if (resourceName !== undefined)
            url_ += "ResourceName=" + encodeURIComponent("" + resourceName) + "&";
        if (baseCultureName === null)
            throw new Error("The parameter 'baseCultureName' cannot be null.");
        else if (baseCultureName !== undefined)
            url_ += "BaseCultureName=" + encodeURIComponent("" + baseCultureName) + "&";
        if (targetCultureName === null)
            throw new Error("The parameter 'targetCultureName' cannot be null.");
        else if (targetCultureName !== undefined)
            url_ += "TargetCultureName=" + encodeURIComponent("" + targetCultureName) + "&";
        if (getOnlyEmptyValues === null)
            throw new Error("The parameter 'getOnlyEmptyValues' cannot be null.");
        else if (getOnlyEmptyValues !== undefined)
            url_ += "GetOnlyEmptyValues=" + encodeURIComponent("" + getOnlyEmptyValues) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageTextsGET(_response);
        });
    }

    protected processLanguageTextsGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param baseCultureName (optional) 
     * @return Success
     */
    languageTextsGET2(resourceName: string, cultureName: string, name: string, baseCultureName: string | undefined , cancelToken?: CancelToken | undefined): Promise<LanguageTextDto> {
        let url_ = this.baseUrl + "/api/language-management/language-texts/{resourceName}/{cultureName}/{name}?";
        if (resourceName === undefined || resourceName === null)
            throw new Error("The parameter 'resourceName' must be defined.");
        url_ = url_.replace("{resourceName}", encodeURIComponent("" + resourceName));
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined.");
        url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (baseCultureName === null)
            throw new Error("The parameter 'baseCultureName' cannot be null.");
        else if (baseCultureName !== undefined)
            url_ += "baseCultureName=" + encodeURIComponent("" + baseCultureName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageTextsGET2(_response);
        });
    }

    protected processLanguageTextsGET2(response: AxiosResponse): Promise<LanguageTextDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageTextDto.fromJS(resultData200);
            return Promise.resolve<LanguageTextDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageTextDto>(null as any);
    }

    /**
     * @param value (optional) 
     * @return Success
     */
    languageTextsPUT(resourceName: string, cultureName: string, name: string, value: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/language-management/language-texts/{resourceName}/{cultureName}/{name}?";
        if (resourceName === undefined || resourceName === null)
            throw new Error("The parameter 'resourceName' must be defined.");
        url_ = url_.replace("{resourceName}", encodeURIComponent("" + resourceName));
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined.");
        url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageTextsPUT(_response);
        });
    }

    protected processLanguageTextsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    restore(resourceName: string, cultureName: string, name: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/language-management/language-texts/{resourceName}/{cultureName}/{name}/restore";
        if (resourceName === undefined || resourceName === null)
            throw new Error("The parameter 'resourceName' must be defined.");
        url_ = url_.replace("{resourceName}", encodeURIComponent("" + resourceName));
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined.");
        url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestore(_response);
        });
    }

    protected processRestore(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: UserLoginInfo | undefined , cancelToken?: CancelToken | undefined): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<AbpLoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AbpLoginResult.fromJS(resultData200);
            return Promise.resolve<AbpLoginResult>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AbpLoginResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkLogin(body: LinkUserLoginInfo | undefined , cancelToken?: CancelToken | undefined): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/linkLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLinkLogin(_response);
        });
    }

    protected processLinkLogin(response: AxiosResponse): Promise<AbpLoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AbpLoginResult.fromJS(resultData200);
            return Promise.resolve<AbpLoginResult>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AbpLoginResult>(null as any);
    }

    /**
     * @return Success
     */
    logout(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPassword(body: UserLoginInfo | undefined , cancelToken?: CancelToken | undefined): Promise<AbpLoginResult> {
        let url_ = this.baseUrl + "/api/account/checkPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPassword(_response);
        });
    }

    protected processCheckPassword(response: AxiosResponse): Promise<AbpLoginResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AbpLoginResult.fromJS(resultData200);
            return Promise.resolve<AbpLoginResult>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AbpLoginResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT(id: string, body: OrganizationUnitRoleInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPUT(_response);
        });
    }

    protected processRolesPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    rolesGET(id: string, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/roles?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET(_response);
        });
    }

    protected processRolesGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    membersPUT(id: string, body: OrganizationUnitUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/members";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMembersPUT(_response);
        });
    }

    protected processMembersPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @param userName (optional) 
     * @param phoneNumber (optional) 
     * @param emailAddress (optional) 
     * @param isLockedOut (optional) 
     * @param notActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    membersGET(id: string, filter: string | undefined, roleId: string | undefined, organizationUnitId: string | undefined, userName: string | undefined, phoneNumber: string | undefined, emailAddress: string | undefined, isLockedOut: boolean | undefined, notActive: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/members?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "EmailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (isLockedOut === null)
            throw new Error("The parameter 'isLockedOut' cannot be null.");
        else if (isLockedOut !== undefined)
            url_ += "IsLockedOut=" + encodeURIComponent("" + isLockedOut) + "&";
        if (notActive === null)
            throw new Error("The parameter 'notActive' cannot be null.");
        else if (notActive !== undefined)
            url_ += "NotActive=" + encodeURIComponent("" + notActive) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMembersGET(_response);
        });
    }

    protected processMembersGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    organizationUnitsPOST(body: OrganizationUnitCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitWithDetailsDto> {
        let url_ = this.baseUrl + "/api/identity/organization-units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsPOST(_response);
        });
    }

    protected processOrganizationUnitsPOST(response: AxiosResponse): Promise<OrganizationUnitWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<OrganizationUnitWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitWithDetailsDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    organizationUnitsDELETE(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsDELETE(_response);
        });
    }

    protected processOrganizationUnitsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    organizationUnitsGET(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsGET(_response);
        });
    }

    protected processOrganizationUnitsGET(response: AxiosResponse): Promise<PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    organizationUnitsGET2(id: string , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitWithDetailsDto> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsGET2(_response);
        });
    }

    protected processOrganizationUnitsGET2(response: AxiosResponse): Promise<OrganizationUnitWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<OrganizationUnitWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitWithDetailsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    organizationUnitsPUT(id: string, body: OrganizationUnitUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitWithDetailsDto> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsPUT(_response);
        });
    }

    protected processOrganizationUnitsPUT(response: AxiosResponse): Promise<OrganizationUnitWithDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitWithDetailsDto.fromJS(resultData200);
            return Promise.resolve<OrganizationUnitWithDetailsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitWithDetailsDto>(null as any);
    }

    /**
     * @return Success
     */
    all2(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll2(_response);
        });
    }

    protected processAll2(response: AxiosResponse): Promise<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    move(id: string, body: OrganizationUnitMoveInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/move";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMove(_response);
        });
    }

    protected processMove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    availableUsers(filter: string | undefined, id: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/available-users?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAvailableUsers(_response);
        });
    }

    protected processAvailableUsers(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param id (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    availableRoles(filter: string | undefined, id: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/organization-units/available-roles?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAvailableRoles(_response);
        });
    }

    protected processAvailableRoles(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    membersDELETE(id: string, memberId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/members/{memberId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (memberId === undefined || memberId === null)
            throw new Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMembersDELETE(_response);
        });
    }

    protected processMembersDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    rolesDELETE(id: string, roleId: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/organization-units/{id}/roles/{roleId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesDELETE(_response);
        });
    }

    protected processRolesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @return Success
     */
    permissionsGET(providerName: string | undefined, providerKey: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetPermissionListResultDto> {
        let url_ = this.baseUrl + "/api/permission-management/permissions?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsGET(_response);
        });
    }

    protected processPermissionsGET(response: AxiosResponse): Promise<GetPermissionListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetPermissionListResultDto.fromJS(resultData200);
            return Promise.resolve<GetPermissionListResultDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPermissionListResultDto>(null as any);
    }

    /**
     * @param providerName (optional) 
     * @param providerKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    permissionsPUT(providerName: string | undefined, providerKey: string | undefined, body: UpdatePermissionsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/permission-management/permissions?";
        if (providerName === null)
            throw new Error("The parameter 'providerName' cannot be null.");
        else if (providerName !== undefined)
            url_ += "providerName=" + encodeURIComponent("" + providerName) + "&";
        if (providerKey === null)
            throw new Error("The parameter 'providerKey' cannot be null.");
        else if (providerKey !== undefined)
            url_ += "providerKey=" + encodeURIComponent("" + providerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsPUT(_response);
        });
    }

    protected processPermissionsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    myProfileGET(  cancelToken?: CancelToken | undefined): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/account/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMyProfileGET(_response);
        });
    }

    protected processMyProfileGET(response: AxiosResponse): Promise<ProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileDto.fromJS(resultData200);
            return Promise.resolve<ProfileDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    myProfilePUT(body: UpdateProfileDto | undefined , cancelToken?: CancelToken | undefined): Promise<ProfileDto> {
        let url_ = this.baseUrl + "/api/account/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMyProfilePUT(_response);
        });
    }

    protected processMyProfilePUT(response: AxiosResponse): Promise<ProfileDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileDto.fromJS(resultData200);
            return Promise.resolve<ProfileDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePasswordPOST(body: ChangePasswordInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/my-profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePasswordPOST(_response);
        });
    }

    protected processChangePasswordPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorEnabled(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/my-profile/two-factor-enabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorEnabled(_response);
        });
    }

    protected processTwoFactorEnabled(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param enabled (optional) 
     * @return Success
     */
    setTwoFactorEnabled(enabled: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/my-profile/set-two-factor-enabled?";
        if (enabled === null)
            throw new Error("The parameter 'enabled' cannot be null.");
        else if (enabled !== undefined)
            url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetTwoFactorEnabled(_response);
        });
    }

    protected processSetTwoFactorEnabled(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    rolesGET2(id: string , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET2(_response);
        });
    }

    protected processRolesGET2(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT2(id: string, body: IdentityRoleUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPUT2(_response);
        });
    }

    protected processRolesPUT2(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @return Success
     */
    rolesDELETE2(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesDELETE2(_response);
        });
    }

    protected processRolesDELETE2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPOST(body: IdentityRoleCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/identity/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPOST(_response);
        });
    }

    protected processRolesPOST(response: AxiosResponse): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityRoleDto.fromJS(resultData200);
            return Promise.resolve<IdentityRoleDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    rolesGET3(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/roles?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET3(_response);
        });
    }

    protected processRolesGET3(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    all3(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/roles/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll3(_response);
        });
    }

    protected processAll3(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claims(id: string, body: IdentityRoleClaimDto[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaims(_response);
        });
    }

    protected processClaims(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    claimsAll(id: string , cancelToken?: CancelToken | undefined): Promise<IdentityRoleClaimDto[]> {
        let url_ = this.baseUrl + "/api/identity/roles/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimsAll(_response);
        });
    }

    protected processClaimsAll(response: AxiosResponse): Promise<IdentityRoleClaimDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityRoleClaimDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<IdentityRoleClaimDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleClaimDto[]>(null as any);
    }

    /**
     * @return Success
     */
    allClaimTypes(  cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto[]> {
        let url_ = this.baseUrl + "/api/identity/roles/all-claim-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAllClaimTypes(_response);
        });
    }

    protected processAllClaimTypes(response: AxiosResponse): Promise<ClaimTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ClaimTypeDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    scopesGET(id: string , cancelToken?: CancelToken | undefined): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/openiddict/scopes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesGET(_response);
        });
    }

    protected processScopesGET(response: AxiosResponse): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScopeDto.fromJS(resultData200);
            return Promise.resolve<ScopeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    scopesPUT(id: string, body: UpdateScopeInput | undefined , cancelToken?: CancelToken | undefined): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/openiddict/scopes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesPUT(_response);
        });
    }

    protected processScopesPUT(response: AxiosResponse): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScopeDto.fromJS(resultData200);
            return Promise.resolve<ScopeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    scopesGET2(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/openiddict/scopes?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesGET2(_response);
        });
    }

    protected processScopesGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    scopesPOST(body: CreateScopeInput | undefined , cancelToken?: CancelToken | undefined): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/openiddict/scopes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesPOST(_response);
        });
    }

    protected processScopesPOST(response: AxiosResponse): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ScopeDto.fromJS(resultData200);
            return Promise.resolve<ScopeDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    scopesDELETE(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/openiddict/scopes?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processScopesDELETE(_response);
        });
    }

    protected processScopesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    allAll(  cancelToken?: CancelToken | undefined): Promise<ScopeDto[]> {
        let url_ = this.baseUrl + "/api/openiddict/scopes/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAllAll(_response);
        });
    }

    protected processAllAll(response: AxiosResponse): Promise<ScopeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScopeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ScopeDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ScopeDto[]>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param applicationName (optional) 
     * @param identity (optional) 
     * @param action (optional) 
     * @param userName (optional) 
     * @param clientId (optional) 
     * @param correlationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    securityLogs2(startTime: Date | undefined, endTime: Date | undefined, applicationName: string | undefined, identity: string | undefined, action: string | undefined, userName: string | undefined, clientId: string | undefined, correlationId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/security-logs?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (applicationName === null)
            throw new Error("The parameter 'applicationName' cannot be null.");
        else if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (identity === null)
            throw new Error("The parameter 'identity' cannot be null.");
        else if (identity !== undefined)
            url_ += "Identity=" + encodeURIComponent("" + identity) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "Action=" + encodeURIComponent("" + action) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (correlationId === null)
            throw new Error("The parameter 'correlationId' cannot be null.");
        else if (correlationId !== undefined)
            url_ += "CorrelationId=" + encodeURIComponent("" + correlationId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSecurityLogs2(_response);
        });
    }

    protected processSecurityLogs2(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    securityLogs3(id: string , cancelToken?: CancelToken | undefined): Promise<IdentitySecurityLogDto> {
        let url_ = this.baseUrl + "/api/identity/security-logs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSecurityLogs3(_response);
        });
    }

    protected processSecurityLogs3(response: AxiosResponse): Promise<IdentitySecurityLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentitySecurityLogDto.fromJS(resultData200);
            return Promise.resolve<IdentitySecurityLogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentitySecurityLogDto>(null as any);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param applicationName (optional) 
     * @param identity (optional) 
     * @param action (optional) 
     * @param userName (optional) 
     * @param clientId (optional) 
     * @param correlationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    my(startTime: Date | undefined, endTime: Date | undefined, applicationName: string | undefined, identity: string | undefined, action: string | undefined, userName: string | undefined, clientId: string | undefined, correlationId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/security-logs/my?";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toISOString() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (applicationName === null)
            throw new Error("The parameter 'applicationName' cannot be null.");
        else if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&";
        if (identity === null)
            throw new Error("The parameter 'identity' cannot be null.");
        else if (identity !== undefined)
            url_ += "Identity=" + encodeURIComponent("" + identity) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "Action=" + encodeURIComponent("" + action) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (correlationId === null)
            throw new Error("The parameter 'correlationId' cannot be null.");
        else if (correlationId !== undefined)
            url_ += "CorrelationId=" + encodeURIComponent("" + correlationId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMy(_response);
        });
    }

    protected processMy(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    my2(id: string , cancelToken?: CancelToken | undefined): Promise<IdentitySecurityLogDto> {
        let url_ = this.baseUrl + "/api/identity/security-logs/my/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMy2(_response);
        });
    }

    protected processMy2(response: AxiosResponse): Promise<IdentitySecurityLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentitySecurityLogDto.fromJS(resultData200);
            return Promise.resolve<IdentitySecurityLogDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentitySecurityLogDto>(null as any);
    }

    /**
     * @return Success
     */
    settingsGET2(  cancelToken?: CancelToken | undefined): Promise<IdentitySettingsDto> {
        let url_ = this.baseUrl + "/api/identity/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsGET2(_response);
        });
    }

    protected processSettingsGET2(response: AxiosResponse): Promise<IdentitySettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentitySettingsDto.fromJS(resultData200);
            return Promise.resolve<IdentitySettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentitySettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    settingsPUT2(body: IdentitySettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSettingsPUT2(_response);
        });
    }

    protected processSettingsPUT2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    ldapGET(  cancelToken?: CancelToken | undefined): Promise<IdentityLdapSettingsDto> {
        let url_ = this.baseUrl + "/api/identity/settings/ldap";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLdapGET(_response);
        });
    }

    protected processLdapGET(response: AxiosResponse): Promise<IdentityLdapSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityLdapSettingsDto.fromJS(resultData200);
            return Promise.resolve<IdentityLdapSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityLdapSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ldapPUT(body: IdentityLdapSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/settings/ldap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLdapPUT(_response);
        });
    }

    protected processLdapPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    oauthGET(  cancelToken?: CancelToken | undefined): Promise<IdentityOAuthSettingsDto> {
        let url_ = this.baseUrl + "/api/identity/settings/oauth";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOauthGET(_response);
        });
    }

    protected processOauthGET(response: AxiosResponse): Promise<IdentityOAuthSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityOAuthSettingsDto.fromJS(resultData200);
            return Promise.resolve<IdentityOAuthSettingsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityOAuthSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    oauthPUT(body: IdentityOAuthSettingsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/settings/oauth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOauthPUT(_response);
        });
    }

    protected processOauthPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tenantsGET(id: string , cancelToken?: CancelToken | undefined): Promise<SaasTenantDto> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsGET(_response);
        });
    }

    protected processTenantsGET(response: AxiosResponse): Promise<SaasTenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tenantsPUT(id: string, body: SaasTenantUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<SaasTenantDto> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsPUT(_response);
        });
    }

    protected processTenantsPUT(response: AxiosResponse): Promise<SaasTenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantDto>(null as any);
    }

    /**
     * @return Success
     */
    tenantsDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsDELETE(_response);
        });
    }

    protected processTenantsDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param getEditionNames (optional) 
     * @param editionId (optional) 
     * @param expirationDateMin (optional) 
     * @param expirationDateMax (optional) 
     * @param activationState (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    tenantsGET2(filter: string | undefined, getEditionNames: boolean | undefined, editionId: string | undefined, expirationDateMin: Date | undefined, expirationDateMax: Date | undefined, activationState: TenantActivationState | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/saas/tenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (getEditionNames === null)
            throw new Error("The parameter 'getEditionNames' cannot be null.");
        else if (getEditionNames !== undefined)
            url_ += "GetEditionNames=" + encodeURIComponent("" + getEditionNames) + "&";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (expirationDateMin === null)
            throw new Error("The parameter 'expirationDateMin' cannot be null.");
        else if (expirationDateMin !== undefined)
            url_ += "ExpirationDateMin=" + encodeURIComponent(expirationDateMin ? "" + expirationDateMin.toISOString() : "") + "&";
        if (expirationDateMax === null)
            throw new Error("The parameter 'expirationDateMax' cannot be null.");
        else if (expirationDateMax !== undefined)
            url_ += "ExpirationDateMax=" + encodeURIComponent(expirationDateMax ? "" + expirationDateMax.toISOString() : "") + "&";
        if (activationState === null)
            throw new Error("The parameter 'activationState' cannot be null.");
        else if (activationState !== undefined)
            url_ += "ActivationState=" + encodeURIComponent("" + activationState) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsGET2(_response);
        });
    }

    protected processTenantsGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tenantsPOST(body: SaasTenantCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<SaasTenantDto> {
        let url_ = this.baseUrl + "/api/saas/tenants";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTenantsPOST(_response);
        });
    }

    protected processTenantsPOST(response: AxiosResponse): Promise<SaasTenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantDto>(null as any);
    }

    /**
     * @return Success
     */
    databases(  cancelToken?: CancelToken | undefined): Promise<SaasTenantDatabasesDto> {
        let url_ = this.baseUrl + "/api/saas/tenants/databases";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDatabases(_response);
        });
    }

    protected processDatabases(response: AxiosResponse): Promise<SaasTenantDatabasesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantDatabasesDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantDatabasesDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantDatabasesDto>(null as any);
    }

    /**
     * @return Success
     */
    connectionStringsGET(id: string , cancelToken?: CancelToken | undefined): Promise<SaasTenantConnectionStringsDto> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}/connection-strings";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnectionStringsGET(_response);
        });
    }

    protected processConnectionStringsGET(response: AxiosResponse): Promise<SaasTenantConnectionStringsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SaasTenantConnectionStringsDto.fromJS(resultData200);
            return Promise.resolve<SaasTenantConnectionStringsDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SaasTenantConnectionStringsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    connectionStringsPUT(id: string, body: SaasTenantConnectionStringsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}/connection-strings";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConnectionStringsPUT(_response);
        });
    }

    protected processConnectionStringsPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    applyDatabaseMigrations(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}/apply-database-migrations";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApplyDatabaseMigrations(_response);
        });
    }

    protected processApplyDatabaseMigrations(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    editionsAll(  cancelToken?: CancelToken | undefined): Promise<EditionLookupDto[]> {
        let url_ = this.baseUrl + "/api/saas/tenants/lookup/editions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEditionsAll(_response);
        });
    }

    protected processEditionsAll(response: AxiosResponse): Promise<EditionLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EditionLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<EditionLookupDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EditionLookupDto[]>(null as any);
    }

    /**
     * @param connectionString (optional) 
     * @return Success
     */
    checkConnectionString(connectionString: string | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/saas/tenants/check-connection-string?";
        if (connectionString === null)
            throw new Error("The parameter 'connectionString' cannot be null.");
        else if (connectionString !== undefined)
            url_ += "connectionString=" + encodeURIComponent("" + connectionString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckConnectionString(_response);
        });
    }

    protected processCheckConnectionString(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPassword(id: string, body: SaasTenantSetPasswordDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/saas/tenants/{id}/set-password";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetPassword(_response);
        });
    }

    protected processSetPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param cultureName (optional) 
     * @return Success
     */
    templateContentsGET(templateName: string, cultureName: string | undefined , cancelToken?: CancelToken | undefined): Promise<TextTemplateContentDto> {
        let url_ = this.baseUrl + "/api/text-template-management/template-contents?";
        if (templateName === undefined || templateName === null)
            throw new Error("The parameter 'templateName' must be defined and cannot be null.");
        else
            url_ += "TemplateName=" + encodeURIComponent("" + templateName) + "&";
        if (cultureName === null)
            throw new Error("The parameter 'cultureName' cannot be null.");
        else if (cultureName !== undefined)
            url_ += "CultureName=" + encodeURIComponent("" + cultureName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateContentsGET(_response);
        });
    }

    protected processTemplateContentsGET(response: AxiosResponse): Promise<TextTemplateContentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TextTemplateContentDto.fromJS(resultData200);
            return Promise.resolve<TextTemplateContentDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TextTemplateContentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    templateContentsPUT(body: UpdateTemplateContentInput | undefined , cancelToken?: CancelToken | undefined): Promise<TextTemplateContentDto> {
        let url_ = this.baseUrl + "/api/text-template-management/template-contents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateContentsPUT(_response);
        });
    }

    protected processTemplateContentsPUT(response: AxiosResponse): Promise<TextTemplateContentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TextTemplateContentDto.fromJS(resultData200);
            return Promise.resolve<TextTemplateContentDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TextTemplateContentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    restoreToDefault(body: RestoreTemplateContentInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/text-template-management/template-contents/restore-to-default";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRestoreToDefault(_response);
        });
    }

    protected processRestoreToDefault(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    templateDefinitions(filterText: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/text-template-management/template-definitions?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateDefinitions(_response);
        });
    }

    protected processTemplateDefinitions(response: AxiosResponse): Promise<PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    templateDefinitions2(name: string , cancelToken?: CancelToken | undefined): Promise<TemplateDefinitionDto> {
        let url_ = this.baseUrl + "/api/text-template-management/template-definitions/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTemplateDefinitions2(_response);
        });
    }

    protected processTemplateDefinitions2(response: AxiosResponse): Promise<TemplateDefinitionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TemplateDefinitionDto.fromJS(resultData200);
            return Promise.resolve<TemplateDefinitionDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TemplateDefinitionDto>(null as any);
    }

    /**
     * @return Success
     */
    usersGET(id: string , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersGET(_response);
        });
    }

    protected processUsersGET(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPUT(id: string, body: IdentityUserUpdateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    usersDELETE(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersDELETE(_response);
        });
    }

    protected processUsersDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param filter (optional) 
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @param userName (optional) 
     * @param phoneNumber (optional) 
     * @param emailAddress (optional) 
     * @param isLockedOut (optional) 
     * @param notActive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    usersGET2(filter: string | undefined, roleId: string | undefined, organizationUnitId: string | undefined, userName: string | undefined, phoneNumber: string | undefined, emailAddress: string | undefined, isLockedOut: boolean | undefined, notActive: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (emailAddress === null)
            throw new Error("The parameter 'emailAddress' cannot be null.");
        else if (emailAddress !== undefined)
            url_ += "EmailAddress=" + encodeURIComponent("" + emailAddress) + "&";
        if (isLockedOut === null)
            throw new Error("The parameter 'isLockedOut' cannot be null.");
        else if (isLockedOut !== undefined)
            url_ += "IsLockedOut=" + encodeURIComponent("" + isLockedOut) + "&";
        if (notActive === null)
            throw new Error("The parameter 'notActive' cannot be null.");
        else if (notActive !== undefined)
            url_ += "NotActive=" + encodeURIComponent("" + notActive) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersGET2(_response);
        });
    }

    protected processUsersGET2(response: AxiosResponse): Promise<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    usersPOST(body: IdentityUserCreateDto | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersPOST(_response);
        });
    }

    protected processUsersPOST(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    rolesGET4(id: string , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesGET4(_response);
        });
    }

    protected processRolesGET4(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rolesPUT3(id: string, body: IdentityUserUpdateRolesDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesPUT3(_response);
        });
    }

    protected processRolesPUT3(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    assignableRoles(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/assignable-roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAssignableRoles(_response);
        });
    }

    protected processAssignableRoles(response: AxiosResponse): Promise<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    availableOrganizationUnits(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/available-organization-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAvailableOrganizationUnits(_response);
        });
    }

    protected processAvailableOrganizationUnits(response: AxiosResponse): Promise<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    allClaimTypes2(  cancelToken?: CancelToken | undefined): Promise<ClaimTypeDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/all-claim-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAllClaimTypes2(_response);
        });
    }

    protected processAllClaimTypes2(response: AxiosResponse): Promise<ClaimTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClaimTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ClaimTypeDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ClaimTypeDto[]>(null as any);
    }

    /**
     * @return Success
     */
    claimsAll2(id: string , cancelToken?: CancelToken | undefined): Promise<IdentityUserClaimDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaimsAll2(_response);
        });
    }

    protected processClaimsAll2(response: AxiosResponse): Promise<IdentityUserClaimDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityUserClaimDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<IdentityUserClaimDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserClaimDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    claims2(id: string, body: IdentityUserClaimDto[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClaims2(_response);
        });
    }

    protected processClaims2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    organizationUnitsAll(id: string , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/organization-units";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsAll(_response);
        });
    }

    protected processOrganizationUnitsAll(response: AxiosResponse): Promise<OrganizationUnitDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrganizationUnitDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDto[]>(null as any);
    }

    /**
     * @return Success
     */
    lock(id: string, lockoutEnd: Date , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/lock/{lockoutEnd}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lockoutEnd === undefined || lockoutEnd === null)
            throw new Error("The parameter 'lockoutEnd' must be defined.");
        url_ = url_.replace("{lockoutEnd}", encodeURIComponent(lockoutEnd ? "" + lockoutEnd.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLock(_response);
        });
    }

    protected processLock(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    unlock(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/unlock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnlock(_response);
        });
    }

    protected processUnlock(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    byUsername(username: string , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-username/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByUsername(_response);
        });
    }

    protected processByUsername(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    byEmail(email: string , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/by-email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByEmail(_response);
        });
    }

    protected processByEmail(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorEnabled2(id: string , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/two-factor-enabled";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorEnabled2(_response);
        });
    }

    protected processTwoFactorEnabled2(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    twoFactorPUT2(id: string, enabled: boolean , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/two-factor/{enabled}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (enabled === undefined || enabled === null)
            throw new Error("The parameter 'enabled' must be defined.");
        url_ = url_.replace("{enabled}", encodeURIComponent("" + enabled));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTwoFactorPUT2(_response);
        });
    }

    protected processTwoFactorPUT2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePasswordPUT(id: string, body: IdentityUserUpdatePasswordInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/users/{id}/change-password";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePasswordPUT(_response);
        });
    }

    protected processChangePasswordPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    rolesAll(  cancelToken?: CancelToken | undefined): Promise<IdentityRoleLookupDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRolesAll(_response);
        });
    }

    protected processRolesAll(response: AxiosResponse): Promise<IdentityRoleLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityRoleLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<IdentityRoleLookupDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityRoleLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    organizationUnitsAll2(  cancelToken?: CancelToken | undefined): Promise<OrganizationUnitLookupDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/organization-units";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOrganizationUnitsAll2(_response);
        });
    }

    protected processOrganizationUnitsAll2(response: AxiosResponse): Promise<OrganizationUnitLookupDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUnitLookupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<OrganizationUnitLookupDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitLookupDto[]>(null as any);
    }

    /**
     * @return Success
     */
    externalLoginProviders(  cancelToken?: CancelToken | undefined): Promise<ExternalLoginProviderDto[]> {
        let url_ = this.baseUrl + "/api/identity/users/external-login-Providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalLoginProviders(_response);
        });
    }

    protected processExternalLoginProviders(response: AxiosResponse): Promise<ExternalLoginProviderDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ExternalLoginProviderDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalLoginProviderDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importExternalUser(body: ImportExternalUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/identity/users/import-external-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportExternalUser(_response);
        });
    }

    protected processImportExternalUser(response: AxiosResponse): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityUserDto.fromJS(resultData200);
            return Promise.resolve<IdentityUserDto>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    link(body: LinkUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/link-user/link";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLink(_response);
        });
    }

    protected processLink(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlink(body: UnLinkUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/account/link-user/unlink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnlink(_response);
        });
    }

    protected processUnlink(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isLinked(body: IsLinkedInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/link-user/is-linked";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsLinked(_response);
        });
    }

    protected processIsLinked(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    generateLinkToken(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/account/link-user/generate-link-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerateLinkToken(_response);
        });
    }

    protected processGenerateLinkToken(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyLinkToken(body: VerifyLinkTokenInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/link-user/verify-link-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyLinkToken(_response);
        });
    }

    protected processVerifyLinkToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    generateLinkLoginToken(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/account/link-user/generate-link-login-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGenerateLinkLoginToken(_response);
        });
    }

    protected processGenerateLinkLoginToken(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyLinkLoginToken(body: VerifyLinkLoginTokenInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/account/link-user/verify-link-login-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerifyLinkLoginToken(_response);
        });
    }

    protected processVerifyLinkLoginToken(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return Success
     */
    linkUser(  cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/account/link-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLinkUser(_response);
        });
    }

    protected processLinkUser(response: AxiosResponse): Promise<ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @return Success
     */
    lookup(id: string , cancelToken?: CancelToken | undefined): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLookup(_response);
        });
    }

    protected processLookup(response: AxiosResponse): Promise<UserData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserData.fromJS(resultData200);
            return Promise.resolve<UserData>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserData>(null as any);
    }

    /**
     * @return Success
     */
    byUsername2(userName: string , cancelToken?: CancelToken | undefined): Promise<UserData> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/by-username/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByUsername2(_response);
        });
    }

    protected processByUsername2(response: AxiosResponse): Promise<UserData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserData.fromJS(resultData200);
            return Promise.resolve<UserData>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserData>(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param filter (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    search(sorting: string | undefined, filter: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/search?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null.fromJS(resultData200);
            return Promise.resolve<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null>(null as any);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    count(filter: string | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/identity/users/lookup/count?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCount(_response);
        });
    }

    protected processCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 501) {
            const _responseText = response.data;
            let result501: any = null;
            let resultData501  = _responseText;
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

export enum HttpStatusCode {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export class AccountExternalProviderSettingsDto implements IAccountExternalProviderSettingsDto {
    settings?: ExternalProviderSettings[] | undefined;

    constructor(data?: IAccountExternalProviderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ExternalProviderSettings.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountExternalProviderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountExternalProviderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAccountExternalProviderSettingsDto {
    settings?: ExternalProviderSettings[] | undefined;
}

export class AccountRecaptchaSettingsDto implements IAccountRecaptchaSettingsDto {
    useCaptchaOnLogin?: boolean;
    useCaptchaOnRegistration?: boolean;
    verifyBaseUrl?: string | undefined;
    siteKey?: string | undefined;
    siteSecret?: string | undefined;
    version?: number;
    score?: number;

    constructor(data?: IAccountRecaptchaSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.verifyBaseUrl = _data["verifyBaseUrl"];
            this.siteKey = _data["siteKey"];
            this.siteSecret = _data["siteSecret"];
            this.version = _data["version"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): AccountRecaptchaSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountRecaptchaSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["verifyBaseUrl"] = this.verifyBaseUrl;
        data["siteKey"] = this.siteKey;
        data["siteSecret"] = this.siteSecret;
        data["version"] = this.version;
        data["score"] = this.score;
        return data;
    }
}

export interface IAccountRecaptchaSettingsDto {
    useCaptchaOnLogin?: boolean;
    useCaptchaOnRegistration?: boolean;
    verifyBaseUrl?: string | undefined;
    siteKey?: string | undefined;
    siteSecret?: string | undefined;
    version?: number;
    score?: number;
}

export class AccountSettingsDto implements IAccountSettingsDto {
    isSelfRegistrationEnabled?: boolean;
    enableLocalLogin?: boolean;

    constructor(data?: IAccountSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSelfRegistrationEnabled = _data["isSelfRegistrationEnabled"];
            this.enableLocalLogin = _data["enableLocalLogin"];
        }
    }

    static fromJS(data: any): AccountSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSelfRegistrationEnabled"] = this.isSelfRegistrationEnabled;
        data["enableLocalLogin"] = this.enableLocalLogin;
        return data;
    }
}

export interface IAccountSettingsDto {
    isSelfRegistrationEnabled?: boolean;
    enableLocalLogin?: boolean;
}

export class AccountTwoFactorSettingsDto implements IAccountTwoFactorSettingsDto {
    twoFactorBehaviour?: IdentityProTwoFactorBehaviour;
    isRememberBrowserEnabled?: boolean;
    usersCanChange?: boolean;

    constructor(data?: IAccountTwoFactorSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twoFactorBehaviour = _data["twoFactorBehaviour"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.usersCanChange = _data["usersCanChange"];
        }
    }

    static fromJS(data: any): AccountTwoFactorSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountTwoFactorSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twoFactorBehaviour"] = this.twoFactorBehaviour;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["usersCanChange"] = this.usersCanChange;
        return data;
    }
}

export interface IAccountTwoFactorSettingsDto {
    twoFactorBehaviour?: IdentityProTwoFactorBehaviour;
    isRememberBrowserEnabled?: boolean;
    usersCanChange?: boolean;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword?: string | undefined;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword?: string | undefined;
    newPassword: string;
}

export class ConfirmEmailInput implements IConfirmEmailInput {
    userId!: string;
    token!: string;

    constructor(data?: IConfirmEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data;
    }
}

export interface IConfirmEmailInput {
    userId: string;
    token: string;
}

export class ConfirmPhoneNumberInput implements IConfirmPhoneNumberInput {
    userId!: string;
    token!: string;

    constructor(data?: IConfirmPhoneNumberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmPhoneNumberInput {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPhoneNumberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data;
    }
}

export interface IConfirmPhoneNumberInput {
    userId: string;
    token: string;
}

export class ExternalProviderDto implements IExternalProviderDto {
    providers?: ExternalProviderItemDto[] | undefined;

    constructor(data?: IExternalProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providers"])) {
                this.providers = [] as any;
                for (let item of _data["providers"])
                    this.providers!.push(ExternalProviderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providers)) {
            data["providers"] = [];
            for (let item of this.providers)
                data["providers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderDto {
    providers?: ExternalProviderItemDto[] | undefined;
}

export class ExternalProviderItemDto implements IExternalProviderItemDto {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;

    constructor(data?: IExternalProviderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderItemDto {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
}

export class ExternalProviderItemWithSecretDto implements IExternalProviderItemWithSecretDto {
    success?: boolean;
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;

    constructor(data?: IExternalProviderItemWithSecretDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.name = _data["name"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
            if (Array.isArray(_data["secretProperties"])) {
                this.secretProperties = [] as any;
                for (let item of _data["secretProperties"])
                    this.secretProperties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderItemWithSecretDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderItemWithSecretDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.secretProperties)) {
            data["secretProperties"] = [];
            for (let item of this.secretProperties)
                data["secretProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderItemWithSecretDto {
    success?: boolean;
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;
}

export class ExternalProviderSettings implements IExternalProviderSettings {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;

    constructor(data?: IExternalProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
            if (Array.isArray(_data["secretProperties"])) {
                this.secretProperties = [] as any;
                for (let item of _data["secretProperties"])
                    this.secretProperties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.secretProperties)) {
            data["secretProperties"] = [];
            for (let item of this.secretProperties)
                data["secretProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderSettings {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;
}

export class ExternalProviderSettingsProperty implements IExternalProviderSettingsProperty {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IExternalProviderSettingsProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExternalProviderSettingsProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderSettingsProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IExternalProviderSettingsProperty {
    name?: string | undefined;
    value?: string | undefined;
}

export class IdentityUserConfirmationStateDto implements IIdentityUserConfirmationStateDto {
    emailConfirmed?: boolean;
    phoneNumberConfirmed?: boolean;

    constructor(data?: IIdentityUserConfirmationStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
        }
    }

    static fromJS(data: any): IdentityUserConfirmationStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserConfirmationStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        return data;
    }
}

export interface IIdentityUserConfirmationStateDto {
    emailConfirmed?: boolean;
    phoneNumberConfirmed?: boolean;
}

export class IsLinkedInput implements IIsLinkedInput {
    userId?: string;
    tenantId?: string | undefined;

    constructor(data?: IIsLinkedInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsLinkedInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsLinkedInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IIsLinkedInput {
    userId?: string;
    tenantId?: string | undefined;
}

export class LinkUserDto implements ILinkUserDto {
    targetUserId?: string;
    targetUserName?: string | undefined;
    targetTenantId?: string | undefined;
    targetTenantName?: string | undefined;
    directlyLinked?: boolean;

    constructor(data?: ILinkUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.targetUserName = _data["targetUserName"];
            this.targetTenantId = _data["targetTenantId"];
            this.targetTenantName = _data["targetTenantName"];
            this.directlyLinked = _data["directlyLinked"];
        }
    }

    static fromJS(data: any): LinkUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["targetUserName"] = this.targetUserName;
        data["targetTenantId"] = this.targetTenantId;
        data["targetTenantName"] = this.targetTenantName;
        data["directlyLinked"] = this.directlyLinked;
        return data;
    }
}

export interface ILinkUserDto {
    targetUserId?: string;
    targetUserName?: string | undefined;
    targetTenantId?: string | undefined;
    targetTenantName?: string | undefined;
    directlyLinked?: boolean;
}

export class LinkUserInput implements ILinkUserInput {
    userId?: string;
    tenantId?: string | undefined;
    token!: string;

    constructor(data?: ILinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): LinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["token"] = this.token;
        return data;
    }
}

export interface ILinkUserInput {
    userId?: string;
    tenantId?: string | undefined;
    token: string;
}

export class ProfileDto implements IProfileDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    name?: string | undefined;
    surname?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    isExternal?: boolean;
    hasPassword?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.isExternal = _data["isExternal"];
            this.hasPassword = _data["hasPassword"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["isExternal"] = this.isExternal;
        data["hasPassword"] = this.hasPassword;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IProfileDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    name?: string | undefined;
    surname?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    isExternal?: boolean;
    hasPassword?: boolean;
    concurrencyStamp?: string | undefined;
}

export class ProfilePictureSourceDto implements IProfilePictureSourceDto {
    type?: ProfilePictureType;
    source?: string | undefined;
    fileContent?: string | undefined;

    constructor(data?: IProfilePictureSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.source = _data["source"];
            this.fileContent = _data["fileContent"];
        }
    }

    static fromJS(data: any): ProfilePictureSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePictureSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["source"] = this.source;
        data["fileContent"] = this.fileContent;
        return data;
    }
}

export interface IProfilePictureSourceDto {
    type?: ProfilePictureType;
    source?: string | undefined;
    fileContent?: string | undefined;
}

export enum ProfilePictureType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class AbpLoginResult implements IAbpLoginResult {
    result?: LoginResultType;
    readonly description?: string | undefined;

    constructor(data?: IAbpLoginResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            (<any>this).description = _data["description"];
        }
    }

    static fromJS(data: any): AbpLoginResult {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLoginResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["description"] = this.description;
        return data;
    }
}

export interface IAbpLoginResult {
    result?: LoginResultType;
    description?: string | undefined;
}

export class LinkUserLoginInfo implements ILinkUserLoginInfo {
    linkUserId!: string;
    linkTenantId?: string | undefined;

    constructor(data?: ILinkUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkUserId = _data["linkUserId"];
            this.linkTenantId = _data["linkTenantId"];
        }
    }

    static fromJS(data: any): LinkUserLoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LinkUserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkUserId"] = this.linkUserId;
        data["linkTenantId"] = this.linkTenantId;
        return data;
    }
}

export interface ILinkUserLoginInfo {
    linkUserId: string;
    linkTenantId?: string | undefined;
}

export enum LoginResultType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class UserLoginInfo implements IUserLoginInfo {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberMe?: boolean;
    tenanId?: string | undefined;

    constructor(data?: IUserLoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
            this.tenanId = _data["tenanId"];
        }
    }

    static fromJS(data: any): UserLoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        data["tenanId"] = this.tenanId;
        return data;
    }
}

export interface IUserLoginInfo {
    userNameOrEmailAddress: string;
    password: string;
    rememberMe?: boolean;
    tenanId?: string | undefined;
}

export class RegisterDto implements IRegisterDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName!: string;
    emailAddress!: string;
    password!: string;
    appName!: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;
    captchaResponse?: string | undefined;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.appName = _data["appName"];
            this.returnUrl = _data["returnUrl"];
            this.returnUrlHash = _data["returnUrlHash"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["appName"] = this.appName;
        data["returnUrl"] = this.returnUrl;
        data["returnUrlHash"] = this.returnUrlHash;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IRegisterDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName: string;
    emailAddress: string;
    password: string;
    appName: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;
    captchaResponse?: string | undefined;
}

export class ResetPasswordDto implements IResetPasswordDto {
    userId?: string;
    resetToken!: string;
    password!: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetToken = _data["resetToken"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetToken"] = this.resetToken;
        data["password"] = this.password;
        return data;
    }
}

export interface IResetPasswordDto {
    userId?: string;
    resetToken: string;
    password: string;
}

export class SendEmailConfirmationTokenDto implements ISendEmailConfirmationTokenDto {
    appName!: string;
    userId!: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;

    constructor(data?: ISendEmailConfirmationTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appName = _data["appName"];
            this.userId = _data["userId"];
            this.returnUrl = _data["returnUrl"];
            this.returnUrlHash = _data["returnUrlHash"];
        }
    }

    static fromJS(data: any): SendEmailConfirmationTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailConfirmationTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName;
        data["userId"] = this.userId;
        data["returnUrl"] = this.returnUrl;
        data["returnUrlHash"] = this.returnUrlHash;
        return data;
    }
}

export interface ISendEmailConfirmationTokenDto {
    appName: string;
    userId: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;
}

export class SendPasswordResetCodeDto implements ISendPasswordResetCodeDto {
    email!: string;
    appName!: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;

    constructor(data?: ISendPasswordResetCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.appName = _data["appName"];
            this.returnUrl = _data["returnUrl"];
            this.returnUrlHash = _data["returnUrlHash"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["appName"] = this.appName;
        data["returnUrl"] = this.returnUrl;
        data["returnUrlHash"] = this.returnUrlHash;
        return data;
    }
}

export interface ISendPasswordResetCodeDto {
    email: string;
    appName: string;
    returnUrl?: string | undefined;
    returnUrlHash?: string | undefined;
}

export class SendPhoneNumberConfirmationTokenDto implements ISendPhoneNumberConfirmationTokenDto {
    userId!: string;
    phoneNumber?: string | undefined;

    constructor(data?: ISendPhoneNumberConfirmationTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendPhoneNumberConfirmationTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendPhoneNumberConfirmationTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ISendPhoneNumberConfirmationTokenDto {
    userId: string;
    phoneNumber?: string | undefined;
}

export class SendTwoFactorCodeInput implements ISendTwoFactorCodeInput {
    userId!: string;
    provider!: string;
    token!: string;

    constructor(data?: ISendTwoFactorCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.provider = _data["provider"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): SendTwoFactorCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        data["token"] = this.token;
        return data;
    }
}

export interface ISendTwoFactorCodeInput {
    userId: string;
    provider: string;
    token: string;
}

export class UnLinkUserInput implements IUnLinkUserInput {
    userId?: string;
    tenantId?: string | undefined;

    constructor(data?: IUnLinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnLinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnLinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IUnLinkUserInput {
    userId?: string;
    tenantId?: string | undefined;
}

export class UpdateExternalProviderDto implements IUpdateExternalProviderDto {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;

    constructor(data?: IUpdateExternalProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
            if (Array.isArray(_data["secretProperties"])) {
                this.secretProperties = [] as any;
                for (let item of _data["secretProperties"])
                    this.secretProperties!.push(ExternalProviderSettingsProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateExternalProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExternalProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.secretProperties)) {
            data["secretProperties"] = [];
            for (let item of this.secretProperties)
                data["secretProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateExternalProviderDto {
    name?: string | undefined;
    enabled?: boolean;
    properties?: ExternalProviderSettingsProperty[] | undefined;
    secretProperties?: ExternalProviderSettingsProperty[] | undefined;
}

export class UpdateProfileDto implements IUpdateProfileDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName!: string;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    phoneNumber?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.phoneNumber = _data["phoneNumber"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["phoneNumber"] = this.phoneNumber;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateProfileDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName: string;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    phoneNumber?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class VerifyEmailConfirmationTokenInput implements IVerifyEmailConfirmationTokenInput {
    userId!: string;
    token!: string;

    constructor(data?: IVerifyEmailConfirmationTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyEmailConfirmationTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyEmailConfirmationTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data;
    }
}

export interface IVerifyEmailConfirmationTokenInput {
    userId: string;
    token: string;
}

export class VerifyLinkLoginTokenInput implements IVerifyLinkLoginTokenInput {
    userId!: string;
    tenantId?: string | undefined;
    token!: string;

    constructor(data?: IVerifyLinkLoginTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyLinkLoginTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyLinkLoginTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["token"] = this.token;
        return data;
    }
}

export interface IVerifyLinkLoginTokenInput {
    userId: string;
    tenantId?: string | undefined;
    token: string;
}

export class VerifyLinkTokenInput implements IVerifyLinkTokenInput {
    userId!: string;
    tenantId?: string | undefined;
    token!: string;

    constructor(data?: IVerifyLinkTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyLinkTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyLinkTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["token"] = this.token;
        return data;
    }
}

export interface IVerifyLinkTokenInput {
    userId: string;
    tenantId?: string | undefined;
    token: string;
}

export class VerifyPasswordResetTokenInput implements IVerifyPasswordResetTokenInput {
    userId?: string;
    resetToken!: string;

    constructor(data?: IVerifyPasswordResetTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetToken = _data["resetToken"];
        }
    }

    static fromJS(data: any): VerifyPasswordResetTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyPasswordResetTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetToken"] = this.resetToken;
        return data;
    }
}

export interface IVerifyPasswordResetTokenInput {
    userId?: string;
    resetToken: string;
}

export class ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LinkUserDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfLinkUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LinkUserDto[] | undefined;
}

export class ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | undefined;
}

export class ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: OrganizationUnitWithDetailsDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitWithDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: OrganizationUnitWithDetailsDto[] | undefined;
}

export class ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageDto[] | undefined;

    constructor(data?: IListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageDto[] | undefined;
}

export class ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: UserData[] | undefined;

    constructor(data?: IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDto_1OfOfUserDataAndAbstractionsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: UserData[] | undefined;
}

export class PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: AuditLogDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfAuditLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: AuditLogDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: EntityChangeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfEntityChangeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: EntityChangeDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: GdprRequestDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GdprRequestDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfGdprRequestDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: GdprRequestDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ClaimTypeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClaimTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfClaimTypeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ClaimTypeDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityRoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfIdentityRoleDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityRoleDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentitySecurityLogDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentitySecurityLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfIdentitySecurityLogDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentitySecurityLogDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityUserDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityUserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfIdentityUserDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: IdentityUserDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: OrganizationUnitWithDetailsDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitWithDetailsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfOrganizationUnitWithDetailsDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: OrganizationUnitWithDetailsDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfLanguageDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageTextDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfLanguageTextDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: LanguageTextDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ApplicationDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfApplicationDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ApplicationDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ScopeDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ScopeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfScopeDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: ScopeDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: TemplateDefinitionDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateDefinitionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfTemplateDefinitionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: TemplateDefinitionDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: EditionDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfEditionDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: EditionDto[] | undefined;
    totalCount?: number;
}

export class PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null implements IPagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: SaasTenantDto[] | undefined;
    totalCount?: number;

    constructor(data?: IPagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SaasTenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPagedResultDto_1OfOfSaasTenantDtoAndContractsAnd_0AndCulture_neutralAndPublicKeyToken_null {
    items?: SaasTenantDto[] | undefined;
    totalCount?: number;
}

export class ApplicationAuthConfigurationDto implements IApplicationAuthConfigurationDto {
    grantedPolicies?: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationAuthConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["grantedPolicies"]) {
                this.grantedPolicies = {} as any;
                for (let key in _data["grantedPolicies"]) {
                    if (_data["grantedPolicies"].hasOwnProperty(key))
                        (<any>this.grantedPolicies)![key] = _data["grantedPolicies"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationAuthConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAuthConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.grantedPolicies) {
            data["grantedPolicies"] = {};
            for (let key in this.grantedPolicies) {
                if (this.grantedPolicies.hasOwnProperty(key))
                    (<any>data["grantedPolicies"])[key] = (<any>this.grantedPolicies)[key];
            }
        }
        return data;
    }
}

export interface IApplicationAuthConfigurationDto {
    grantedPolicies?: { [key: string]: boolean; } | undefined;
}

export class ApplicationConfigurationDto implements IApplicationConfigurationDto {
    localization?: ApplicationLocalizationConfigurationDto;
    auth?: ApplicationAuthConfigurationDto;
    setting?: ApplicationSettingConfigurationDto;
    currentUser?: CurrentUserDto;
    features?: ApplicationFeatureConfigurationDto;
    globalFeatures?: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy?: MultiTenancyInfoDto;
    currentTenant?: CurrentTenantDto;
    timing?: TimingDto;
    clock?: ClockDto;
    objectExtensions?: ObjectExtensionsDto;
    extraProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IApplicationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localization = _data["localization"] ? ApplicationLocalizationConfigurationDto.fromJS(_data["localization"]) : <any>undefined;
            this.auth = _data["auth"] ? ApplicationAuthConfigurationDto.fromJS(_data["auth"]) : <any>undefined;
            this.setting = _data["setting"] ? ApplicationSettingConfigurationDto.fromJS(_data["setting"]) : <any>undefined;
            this.currentUser = _data["currentUser"] ? CurrentUserDto.fromJS(_data["currentUser"]) : <any>undefined;
            this.features = _data["features"] ? ApplicationFeatureConfigurationDto.fromJS(_data["features"]) : <any>undefined;
            this.globalFeatures = _data["globalFeatures"] ? ApplicationGlobalFeatureConfigurationDto.fromJS(_data["globalFeatures"]) : <any>undefined;
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyInfoDto.fromJS(_data["multiTenancy"]) : <any>undefined;
            this.currentTenant = _data["currentTenant"] ? CurrentTenantDto.fromJS(_data["currentTenant"]) : <any>undefined;
            this.timing = _data["timing"] ? TimingDto.fromJS(_data["timing"]) : <any>undefined;
            this.clock = _data["clock"] ? ClockDto.fromJS(_data["clock"]) : <any>undefined;
            this.objectExtensions = _data["objectExtensions"] ? ObjectExtensionsDto.fromJS(_data["objectExtensions"]) : <any>undefined;
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["globalFeatures"] = this.globalFeatures ? this.globalFeatures.toJSON() : <any>undefined;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["currentTenant"] = this.currentTenant ? this.currentTenant.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["objectExtensions"] = this.objectExtensions ? this.objectExtensions.toJSON() : <any>undefined;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IApplicationConfigurationDto {
    localization?: ApplicationLocalizationConfigurationDto;
    auth?: ApplicationAuthConfigurationDto;
    setting?: ApplicationSettingConfigurationDto;
    currentUser?: CurrentUserDto;
    features?: ApplicationFeatureConfigurationDto;
    globalFeatures?: ApplicationGlobalFeatureConfigurationDto;
    multiTenancy?: MultiTenancyInfoDto;
    currentTenant?: CurrentTenantDto;
    timing?: TimingDto;
    clock?: ClockDto;
    objectExtensions?: ObjectExtensionsDto;
    extraProperties?: { [key: string]: any; } | undefined;
}

export class ApplicationFeatureConfigurationDto implements IApplicationFeatureConfigurationDto {
    values?: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IApplicationFeatureConfigurationDto {
    values?: { [key: string]: string; } | undefined;
}

export class ApplicationGlobalFeatureConfigurationDto implements IApplicationGlobalFeatureConfigurationDto {
    enabledFeatures?: string[] | undefined;

    constructor(data?: IApplicationGlobalFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledFeatures"])) {
                this.enabledFeatures = [] as any;
                for (let item of _data["enabledFeatures"])
                    this.enabledFeatures!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationGlobalFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationGlobalFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledFeatures)) {
            data["enabledFeatures"] = [];
            for (let item of this.enabledFeatures)
                data["enabledFeatures"].push(item);
        }
        return data;
    }
}

export interface IApplicationGlobalFeatureConfigurationDto {
    enabledFeatures?: string[] | undefined;
}

export class ApplicationLocalizationConfigurationDto implements IApplicationLocalizationConfigurationDto {
    values?: { [key: string]: { [key: string]: string; }; } | undefined;
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
    languages?: LanguageInfo[] | undefined;
    currentCulture?: CurrentCultureDto;
    defaultResourceName?: string | undefined;
    languagesMap?: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap?: { [key: string]: NameValue[]; } | undefined;

    constructor(data?: IApplicationLocalizationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
            if (_data["resources"]) {
                this.resources = {} as any;
                for (let key in _data["resources"]) {
                    if (_data["resources"].hasOwnProperty(key))
                        (<any>this.resources)![key] = _data["resources"][key] ? ApplicationLocalizationResourceDto.fromJS(_data["resources"][key]) : new ApplicationLocalizationResourceDto();
                }
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
            this.currentCulture = _data["currentCulture"] ? CurrentCultureDto.fromJS(_data["currentCulture"]) : <any>undefined;
            this.defaultResourceName = _data["defaultResourceName"];
            if (_data["languagesMap"]) {
                this.languagesMap = {} as any;
                for (let key in _data["languagesMap"]) {
                    if (_data["languagesMap"].hasOwnProperty(key))
                        (<any>this.languagesMap)![key] = _data["languagesMap"][key] ? _data["languagesMap"][key].map((i: any) => NameValue.fromJS(i)) : <any>undefined;
                }
            }
            if (_data["languageFilesMap"]) {
                this.languageFilesMap = {} as any;
                for (let key in _data["languageFilesMap"]) {
                    if (_data["languageFilesMap"].hasOwnProperty(key))
                        (<any>this.languageFilesMap)![key] = _data["languageFilesMap"][key] ? _data["languageFilesMap"][key].map((i: any) => NameValue.fromJS(i)) : <any>undefined;
                }
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        if (this.resources) {
            data["resources"] = {};
            for (let key in this.resources) {
                if (this.resources.hasOwnProperty(key))
                    (<any>data["resources"])[key] = this.resources[key] ? this.resources[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        data["defaultResourceName"] = this.defaultResourceName;
        if (this.languagesMap) {
            data["languagesMap"] = {};
            for (let key in this.languagesMap) {
                if (this.languagesMap.hasOwnProperty(key))
                    (<any>data["languagesMap"])[key] = (<any>this.languagesMap)[key];
            }
        }
        if (this.languageFilesMap) {
            data["languageFilesMap"] = {};
            for (let key in this.languageFilesMap) {
                if (this.languageFilesMap.hasOwnProperty(key))
                    (<any>data["languageFilesMap"])[key] = (<any>this.languageFilesMap)[key];
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationConfigurationDto {
    values?: { [key: string]: { [key: string]: string; }; } | undefined;
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
    languages?: LanguageInfo[] | undefined;
    currentCulture?: CurrentCultureDto;
    defaultResourceName?: string | undefined;
    languagesMap?: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap?: { [key: string]: NameValue[]; } | undefined;
}

export class ApplicationLocalizationDto implements IApplicationLocalizationDto {
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;

    constructor(data?: IApplicationLocalizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["resources"]) {
                this.resources = {} as any;
                for (let key in _data["resources"]) {
                    if (_data["resources"].hasOwnProperty(key))
                        (<any>this.resources)![key] = _data["resources"][key] ? ApplicationLocalizationResourceDto.fromJS(_data["resources"][key]) : new ApplicationLocalizationResourceDto();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.resources) {
            data["resources"] = {};
            for (let key in this.resources) {
                if (this.resources.hasOwnProperty(key))
                    (<any>data["resources"])[key] = this.resources[key] ? this.resources[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationDto {
    resources?: { [key: string]: ApplicationLocalizationResourceDto; } | undefined;
}

export class ApplicationLocalizationResourceDto implements IApplicationLocalizationResourceDto {
    texts?: { [key: string]: string; } | undefined;
    baseResources?: string[] | undefined;

    constructor(data?: IApplicationLocalizationResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["texts"]) {
                this.texts = {} as any;
                for (let key in _data["texts"]) {
                    if (_data["texts"].hasOwnProperty(key))
                        (<any>this.texts)![key] = _data["texts"][key];
                }
            }
            if (Array.isArray(_data["baseResources"])) {
                this.baseResources = [] as any;
                for (let item of _data["baseResources"])
                    this.baseResources!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.texts) {
            data["texts"] = {};
            for (let key in this.texts) {
                if (this.texts.hasOwnProperty(key))
                    (<any>data["texts"])[key] = (<any>this.texts)[key];
            }
        }
        if (Array.isArray(this.baseResources)) {
            data["baseResources"] = [];
            for (let item of this.baseResources)
                data["baseResources"].push(item);
        }
        return data;
    }
}

export interface IApplicationLocalizationResourceDto {
    texts?: { [key: string]: string; } | undefined;
    baseResources?: string[] | undefined;
}

export class ApplicationSettingConfigurationDto implements IApplicationSettingConfigurationDto {
    values?: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationSettingConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationSettingConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IApplicationSettingConfigurationDto {
    values?: { [key: string]: string; } | undefined;
}

export class ClockDto implements IClockDto {
    kind?: string | undefined;

    constructor(data?: IClockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
        }
    }

    static fromJS(data: any): ClockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        return data;
    }
}

export interface IClockDto {
    kind?: string | undefined;
}

export class CurrentCultureDto implements ICurrentCultureDto {
    displayName?: string | undefined;
    englishName?: string | undefined;
    threeLetterIsoLanguageName?: string | undefined;
    twoLetterIsoLanguageName?: string | undefined;
    isRightToLeft?: boolean;
    cultureName?: string | undefined;
    name?: string | undefined;
    nativeName?: string | undefined;
    dateTimeFormat?: DateTimeFormatDto;

    constructor(data?: ICurrentCultureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.englishName = _data["englishName"];
            this.threeLetterIsoLanguageName = _data["threeLetterIsoLanguageName"];
            this.twoLetterIsoLanguageName = _data["twoLetterIsoLanguageName"];
            this.isRightToLeft = _data["isRightToLeft"];
            this.cultureName = _data["cultureName"];
            this.name = _data["name"];
            this.nativeName = _data["nativeName"];
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatDto.fromJS(_data["dateTimeFormat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CurrentCultureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentCultureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["englishName"] = this.englishName;
        data["threeLetterIsoLanguageName"] = this.threeLetterIsoLanguageName;
        data["twoLetterIsoLanguageName"] = this.twoLetterIsoLanguageName;
        data["isRightToLeft"] = this.isRightToLeft;
        data["cultureName"] = this.cultureName;
        data["name"] = this.name;
        data["nativeName"] = this.nativeName;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICurrentCultureDto {
    displayName?: string | undefined;
    englishName?: string | undefined;
    threeLetterIsoLanguageName?: string | undefined;
    twoLetterIsoLanguageName?: string | undefined;
    isRightToLeft?: boolean;
    cultureName?: string | undefined;
    name?: string | undefined;
    nativeName?: string | undefined;
    dateTimeFormat?: DateTimeFormatDto;
}

export class CurrentUserDto implements ICurrentUserDto {
    isAuthenticated?: boolean;
    id?: string | undefined;
    tenantId?: string | undefined;
    impersonatorUserId?: string | undefined;
    impersonatorTenantId?: string | undefined;
    impersonatorUserName?: string | undefined;
    impersonatorTenantName?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surName?: string | undefined;
    email?: string | undefined;
    emailVerified?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberVerified?: boolean;
    roles?: string[] | undefined;

    constructor(data?: ICurrentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAuthenticated = _data["isAuthenticated"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserName = _data["impersonatorUserName"];
            this.impersonatorTenantName = _data["impersonatorTenantName"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surName = _data["surName"];
            this.email = _data["email"];
            this.emailVerified = _data["emailVerified"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberVerified = _data["phoneNumberVerified"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CurrentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAuthenticated"] = this.isAuthenticated;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserName"] = this.impersonatorUserName;
        data["impersonatorTenantName"] = this.impersonatorTenantName;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surName"] = this.surName;
        data["email"] = this.email;
        data["emailVerified"] = this.emailVerified;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberVerified"] = this.phoneNumberVerified;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICurrentUserDto {
    isAuthenticated?: boolean;
    id?: string | undefined;
    tenantId?: string | undefined;
    impersonatorUserId?: string | undefined;
    impersonatorTenantId?: string | undefined;
    impersonatorUserName?: string | undefined;
    impersonatorTenantName?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surName?: string | undefined;
    email?: string | undefined;
    emailVerified?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberVerified?: boolean;
    roles?: string[] | undefined;
}

export class DateTimeFormatDto implements IDateTimeFormatDto {
    calendarAlgorithmType?: string | undefined;
    dateTimeFormatLong?: string | undefined;
    shortDatePattern?: string | undefined;
    fullDateTimePattern?: string | undefined;
    dateSeparator?: string | undefined;
    shortTimePattern?: string | undefined;
    longTimePattern?: string | undefined;

    constructor(data?: IDateTimeFormatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calendarAlgorithmType = _data["calendarAlgorithmType"];
            this.dateTimeFormatLong = _data["dateTimeFormatLong"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.fullDateTimePattern = _data["fullDateTimePattern"];
            this.dateSeparator = _data["dateSeparator"];
            this.shortTimePattern = _data["shortTimePattern"];
            this.longTimePattern = _data["longTimePattern"];
        }
    }

    static fromJS(data: any): DateTimeFormatDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarAlgorithmType"] = this.calendarAlgorithmType;
        data["dateTimeFormatLong"] = this.dateTimeFormatLong;
        data["shortDatePattern"] = this.shortDatePattern;
        data["fullDateTimePattern"] = this.fullDateTimePattern;
        data["dateSeparator"] = this.dateSeparator;
        data["shortTimePattern"] = this.shortTimePattern;
        data["longTimePattern"] = this.longTimePattern;
        return data;
    }
}

export interface IDateTimeFormatDto {
    calendarAlgorithmType?: string | undefined;
    dateTimeFormatLong?: string | undefined;
    shortDatePattern?: string | undefined;
    fullDateTimePattern?: string | undefined;
    dateSeparator?: string | undefined;
    shortTimePattern?: string | undefined;
    longTimePattern?: string | undefined;
}

export class IanaTimeZone implements IIanaTimeZone {
    timeZoneName?: string | undefined;

    constructor(data?: IIanaTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneName = _data["timeZoneName"];
        }
    }

    static fromJS(data: any): IanaTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new IanaTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneName"] = this.timeZoneName;
        return data;
    }
}

export interface IIanaTimeZone {
    timeZoneName?: string | undefined;
}

export class EntityExtensionDto implements IEntityExtensionDto {
    properties?: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration?: { [key: string]: any; } | undefined;

    constructor(data?: IEntityExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? ExtensionPropertyDto.fromJS(_data["properties"][key]) : new ExtensionPropertyDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): EntityExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IEntityExtensionDto {
    properties?: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration?: { [key: string]: any; } | undefined;
}

export class ExtensionEnumDto implements IExtensionEnumDto {
    fields?: ExtensionEnumFieldDto[] | undefined;
    localizationResource?: string | undefined;

    constructor(data?: IExtensionEnumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ExtensionEnumFieldDto.fromJS(item));
            }
            this.localizationResource = _data["localizationResource"];
        }
    }

    static fromJS(data: any): ExtensionEnumDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["localizationResource"] = this.localizationResource;
        return data;
    }
}

export interface IExtensionEnumDto {
    fields?: ExtensionEnumFieldDto[] | undefined;
    localizationResource?: string | undefined;
}

export class ExtensionEnumFieldDto implements IExtensionEnumFieldDto {
    name?: string | undefined;
    value?: any | undefined;

    constructor(data?: IExtensionEnumFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExtensionEnumFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IExtensionEnumFieldDto {
    name?: string | undefined;
    value?: any | undefined;
}

export class ExtensionPropertyApiCreateDto implements IExtensionPropertyApiCreateDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiCreateDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyApiDto implements IExtensionPropertyApiDto {
    onGet?: ExtensionPropertyApiGetDto;
    onCreate?: ExtensionPropertyApiCreateDto;
    onUpdate?: ExtensionPropertyApiUpdateDto;

    constructor(data?: IExtensionPropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onGet = _data["onGet"] ? ExtensionPropertyApiGetDto.fromJS(_data["onGet"]) : <any>undefined;
            this.onCreate = _data["onCreate"] ? ExtensionPropertyApiCreateDto.fromJS(_data["onCreate"]) : <any>undefined;
            this.onUpdate = _data["onUpdate"] ? ExtensionPropertyApiUpdateDto.fromJS(_data["onUpdate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onGet"] = this.onGet ? this.onGet.toJSON() : <any>undefined;
        data["onCreate"] = this.onCreate ? this.onCreate.toJSON() : <any>undefined;
        data["onUpdate"] = this.onUpdate ? this.onUpdate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyApiDto {
    onGet?: ExtensionPropertyApiGetDto;
    onCreate?: ExtensionPropertyApiCreateDto;
    onUpdate?: ExtensionPropertyApiUpdateDto;
}

export class ExtensionPropertyApiGetDto implements IExtensionPropertyApiGetDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiGetDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyApiUpdateDto implements IExtensionPropertyApiUpdateDto {
    isAvailable?: boolean;

    constructor(data?: IExtensionPropertyApiUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiUpdateDto {
    isAvailable?: boolean;
}

export class ExtensionPropertyAttributeDto implements IExtensionPropertyAttributeDto {
    typeSimple?: string | undefined;
    config?: { [key: string]: any; } | undefined;

    constructor(data?: IExtensionPropertyAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeSimple = _data["typeSimple"];
            if (_data["config"]) {
                this.config = {} as any;
                for (let key in _data["config"]) {
                    if (_data["config"].hasOwnProperty(key))
                        (<any>this.config)![key] = _data["config"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExtensionPropertyAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeSimple"] = this.typeSimple;
        if (this.config) {
            data["config"] = {};
            for (let key in this.config) {
                if (this.config.hasOwnProperty(key))
                    (<any>data["config"])[key] = (<any>this.config)[key];
            }
        }
        return data;
    }
}

export interface IExtensionPropertyAttributeDto {
    typeSimple?: string | undefined;
    config?: { [key: string]: any; } | undefined;
}

export class ExtensionPropertyDto implements IExtensionPropertyDto {
    type?: string | undefined;
    typeSimple?: string | undefined;
    displayName?: LocalizableStringDto;
    api?: ExtensionPropertyApiDto;
    ui?: ExtensionPropertyUiDto;
    attributes?: ExtensionPropertyAttributeDto[] | undefined;
    configuration?: { [key: string]: any; } | undefined;
    defaultValue?: any | undefined;

    constructor(data?: IExtensionPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.displayName = _data["displayName"] ? LocalizableStringDto.fromJS(_data["displayName"]) : <any>undefined;
            this.api = _data["api"] ? ExtensionPropertyApiDto.fromJS(_data["api"]) : <any>undefined;
            this.ui = _data["ui"] ? ExtensionPropertyUiDto.fromJS(_data["ui"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ExtensionPropertyAttributeDto.fromJS(item));
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): ExtensionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["api"] = this.api ? this.api.toJSON() : <any>undefined;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IExtensionPropertyDto {
    type?: string | undefined;
    typeSimple?: string | undefined;
    displayName?: LocalizableStringDto;
    api?: ExtensionPropertyApiDto;
    ui?: ExtensionPropertyUiDto;
    attributes?: ExtensionPropertyAttributeDto[] | undefined;
    configuration?: { [key: string]: any; } | undefined;
    defaultValue?: any | undefined;
}

export class ExtensionPropertyUiDto implements IExtensionPropertyUiDto {
    onTable?: ExtensionPropertyUiTableDto;
    onCreateForm?: ExtensionPropertyUiFormDto;
    onEditForm?: ExtensionPropertyUiFormDto;
    lookup?: ExtensionPropertyUiLookupDto;

    constructor(data?: IExtensionPropertyUiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onTable = _data["onTable"] ? ExtensionPropertyUiTableDto.fromJS(_data["onTable"]) : <any>undefined;
            this.onCreateForm = _data["onCreateForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onCreateForm"]) : <any>undefined;
            this.onEditForm = _data["onEditForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onEditForm"]) : <any>undefined;
            this.lookup = _data["lookup"] ? ExtensionPropertyUiLookupDto.fromJS(_data["lookup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTable"] = this.onTable ? this.onTable.toJSON() : <any>undefined;
        data["onCreateForm"] = this.onCreateForm ? this.onCreateForm.toJSON() : <any>undefined;
        data["onEditForm"] = this.onEditForm ? this.onEditForm.toJSON() : <any>undefined;
        data["lookup"] = this.lookup ? this.lookup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyUiDto {
    onTable?: ExtensionPropertyUiTableDto;
    onCreateForm?: ExtensionPropertyUiFormDto;
    onEditForm?: ExtensionPropertyUiFormDto;
    lookup?: ExtensionPropertyUiLookupDto;
}

export class ExtensionPropertyUiFormDto implements IExtensionPropertyUiFormDto {
    isVisible?: boolean;

    constructor(data?: IExtensionPropertyUiFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiFormDto {
    isVisible?: boolean;
}

export class ExtensionPropertyUiLookupDto implements IExtensionPropertyUiLookupDto {
    url?: string | undefined;
    resultListPropertyName?: string | undefined;
    displayPropertyName?: string | undefined;
    valuePropertyName?: string | undefined;
    filterParamName?: string | undefined;

    constructor(data?: IExtensionPropertyUiLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.resultListPropertyName = _data["resultListPropertyName"];
            this.displayPropertyName = _data["displayPropertyName"];
            this.valuePropertyName = _data["valuePropertyName"];
            this.filterParamName = _data["filterParamName"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["resultListPropertyName"] = this.resultListPropertyName;
        data["displayPropertyName"] = this.displayPropertyName;
        data["valuePropertyName"] = this.valuePropertyName;
        data["filterParamName"] = this.filterParamName;
        return data;
    }
}

export interface IExtensionPropertyUiLookupDto {
    url?: string | undefined;
    resultListPropertyName?: string | undefined;
    displayPropertyName?: string | undefined;
    valuePropertyName?: string | undefined;
    filterParamName?: string | undefined;
}

export class ExtensionPropertyUiTableDto implements IExtensionPropertyUiTableDto {
    isVisible?: boolean;

    constructor(data?: IExtensionPropertyUiTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiTableDto {
    isVisible?: boolean;
}

export class LocalizableStringDto implements ILocalizableStringDto {
    name?: string | undefined;
    resource?: string | undefined;

    constructor(data?: ILocalizableStringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.resource = _data["resource"];
        }
    }

    static fromJS(data: any): LocalizableStringDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableStringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["resource"] = this.resource;
        return data;
    }
}

export interface ILocalizableStringDto {
    name?: string | undefined;
    resource?: string | undefined;
}

export class ModuleExtensionDto implements IModuleExtensionDto {
    entities?: { [key: string]: EntityExtensionDto; } | undefined;
    configuration?: { [key: string]: any; } | undefined;

    constructor(data?: IModuleExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["entities"]) {
                this.entities = {} as any;
                for (let key in _data["entities"]) {
                    if (_data["entities"].hasOwnProperty(key))
                        (<any>this.entities)![key] = _data["entities"][key] ? EntityExtensionDto.fromJS(_data["entities"][key]) : new EntityExtensionDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ModuleExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.entities) {
            data["entities"] = {};
            for (let key in this.entities) {
                if (this.entities.hasOwnProperty(key))
                    (<any>data["entities"])[key] = this.entities[key] ? this.entities[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IModuleExtensionDto {
    entities?: { [key: string]: EntityExtensionDto; } | undefined;
    configuration?: { [key: string]: any; } | undefined;
}

export class ObjectExtensionsDto implements IObjectExtensionsDto {
    modules?: { [key: string]: ModuleExtensionDto; } | undefined;
    enums?: { [key: string]: ExtensionEnumDto; } | undefined;

    constructor(data?: IObjectExtensionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleExtensionDto.fromJS(_data["modules"][key]) : new ModuleExtensionDto();
                }
            }
            if (_data["enums"]) {
                this.enums = {} as any;
                for (let key in _data["enums"]) {
                    if (_data["enums"].hasOwnProperty(key))
                        (<any>this.enums)![key] = _data["enums"][key] ? ExtensionEnumDto.fromJS(_data["enums"][key]) : new ExtensionEnumDto();
                }
            }
        }
    }

    static fromJS(data: any): ObjectExtensionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectExtensionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.enums) {
            data["enums"] = {};
            for (let key in this.enums) {
                if (this.enums.hasOwnProperty(key))
                    (<any>data["enums"])[key] = this.enums[key] ? this.enums[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IObjectExtensionsDto {
    modules?: { [key: string]: ModuleExtensionDto; } | undefined;
    enums?: { [key: string]: ExtensionEnumDto; } | undefined;
}

export class TimeZone implements ITimeZone {
    iana?: IanaTimeZone;
    windows?: WindowsTimeZone;

    constructor(data?: ITimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iana = _data["iana"] ? IanaTimeZone.fromJS(_data["iana"]) : <any>undefined;
            this.windows = _data["windows"] ? WindowsTimeZone.fromJS(_data["windows"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new TimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimeZone {
    iana?: IanaTimeZone;
    windows?: WindowsTimeZone;
}

export class TimingDto implements ITimingDto {
    timeZone?: TimeZone;

    constructor(data?: ITimingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZone = _data["timeZone"] ? TimeZone.fromJS(_data["timeZone"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimingDto {
    timeZone?: TimeZone;
}

export class WindowsTimeZone implements IWindowsTimeZone {
    timeZoneId?: string | undefined;

    constructor(data?: IWindowsTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): WindowsTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new WindowsTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface IWindowsTimeZone {
    timeZoneId?: string | undefined;
}

export class CurrentTenantDto implements ICurrentTenantDto {
    id?: string | undefined;
    name?: string | undefined;
    isAvailable?: boolean;

    constructor(data?: ICurrentTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): CurrentTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface ICurrentTenantDto {
    id?: string | undefined;
    name?: string | undefined;
    isAvailable?: boolean;
}

export class FindTenantResultDto implements IFindTenantResultDto {
    success?: boolean;
    tenantId?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IFindTenantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FindTenantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindTenantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IFindTenantResultDto {
    success?: boolean;
    tenantId?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class MultiTenancyInfoDto implements IMultiTenancyInfoDto {
    isEnabled?: boolean;

    constructor(data?: IMultiTenancyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): MultiTenancyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IMultiTenancyInfoDto {
    isEnabled?: boolean;
}

export class AuditLogActionDto implements IAuditLogActionDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    tenantId?: string | undefined;
    auditLogId?: string;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    parameters?: string | undefined;
    executionTime?: Date;
    executionDuration?: number;

    constructor(data?: IAuditLogActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.auditLogId = _data["auditLogId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? new Date(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
        }
    }

    static fromJS(data: any): AuditLogActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["auditLogId"] = this.auditLogId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        return data;
    }
}

export interface IAuditLogActionDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    tenantId?: string | undefined;
    auditLogId?: string;
    serviceName?: string | undefined;
    methodName?: string | undefined;
    parameters?: string | undefined;
    executionTime?: Date;
    executionDuration?: number;
}

export class AuditLogDto implements IAuditLogDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    userId?: string | undefined;
    userName?: string | undefined;
    tenantId?: string | undefined;
    tenantName?: string | undefined;
    impersonatorUserId?: string | undefined;
    impersonatorUserName?: string | undefined;
    impersonatorTenantId?: string | undefined;
    impersonatorTenantName?: string | undefined;
    executionTime?: Date;
    executionDuration?: number;
    clientIpAddress?: string | undefined;
    clientName?: string | undefined;
    browserInfo?: string | undefined;
    httpMethod?: string | undefined;
    url?: string | undefined;
    exceptions?: string | undefined;
    comments?: string | undefined;
    httpStatusCode?: number | undefined;
    applicationName?: string | undefined;
    correlationId?: string | undefined;
    entityChanges?: EntityChangeDto[] | undefined;
    actions?: AuditLogActionDto[] | undefined;

    constructor(data?: IAuditLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.impersonatorUserName = _data["impersonatorUserName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorTenantName = _data["impersonatorTenantName"];
            this.executionTime = _data["executionTime"] ? new Date(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            this.exceptions = _data["exceptions"];
            this.comments = _data["comments"];
            this.httpStatusCode = _data["httpStatusCode"];
            this.applicationName = _data["applicationName"];
            this.correlationId = _data["correlationId"];
            if (Array.isArray(_data["entityChanges"])) {
                this.entityChanges = [] as any;
                for (let item of _data["entityChanges"])
                    this.entityChanges!.push(EntityChangeDto.fromJS(item));
            }
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(AuditLogActionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorUserName"] = this.impersonatorUserName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorTenantName"] = this.impersonatorTenantName;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        data["exceptions"] = this.exceptions;
        data["comments"] = this.comments;
        data["httpStatusCode"] = this.httpStatusCode;
        data["applicationName"] = this.applicationName;
        data["correlationId"] = this.correlationId;
        if (Array.isArray(this.entityChanges)) {
            data["entityChanges"] = [];
            for (let item of this.entityChanges)
                data["entityChanges"].push(item.toJSON());
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAuditLogDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    userId?: string | undefined;
    userName?: string | undefined;
    tenantId?: string | undefined;
    tenantName?: string | undefined;
    impersonatorUserId?: string | undefined;
    impersonatorUserName?: string | undefined;
    impersonatorTenantId?: string | undefined;
    impersonatorTenantName?: string | undefined;
    executionTime?: Date;
    executionDuration?: number;
    clientIpAddress?: string | undefined;
    clientName?: string | undefined;
    browserInfo?: string | undefined;
    httpMethod?: string | undefined;
    url?: string | undefined;
    exceptions?: string | undefined;
    comments?: string | undefined;
    httpStatusCode?: number | undefined;
    applicationName?: string | undefined;
    correlationId?: string | undefined;
    entityChanges?: EntityChangeDto[] | undefined;
    actions?: AuditLogActionDto[] | undefined;
}

export class EntityChangeDto implements IEntityChangeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    auditLogId?: string;
    tenantId?: string | undefined;
    changeTime?: Date;
    changeType?: EntityChangeType;
    entityId?: string | undefined;
    entityTypeFullName?: string | undefined;
    propertyChanges?: EntityPropertyChangeDto[] | undefined;

    constructor(data?: IEntityChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.auditLogId = _data["auditLogId"];
            this.tenantId = _data["tenantId"];
            this.changeTime = _data["changeTime"] ? new Date(_data["changeTime"].toString()) : <any>undefined;
            this.changeType = _data["changeType"];
            this.entityId = _data["entityId"];
            this.entityTypeFullName = _data["entityTypeFullName"];
            if (Array.isArray(_data["propertyChanges"])) {
                this.propertyChanges = [] as any;
                for (let item of _data["propertyChanges"])
                    this.propertyChanges!.push(EntityPropertyChangeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["auditLogId"] = this.auditLogId;
        data["tenantId"] = this.tenantId;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["changeType"] = this.changeType;
        data["entityId"] = this.entityId;
        data["entityTypeFullName"] = this.entityTypeFullName;
        if (Array.isArray(this.propertyChanges)) {
            data["propertyChanges"] = [];
            for (let item of this.propertyChanges)
                data["propertyChanges"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntityChangeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    auditLogId?: string;
    tenantId?: string | undefined;
    changeTime?: Date;
    changeType?: EntityChangeType;
    entityId?: string | undefined;
    entityTypeFullName?: string | undefined;
    propertyChanges?: EntityPropertyChangeDto[] | undefined;
}

export class EntityChangeWithUsernameDto implements IEntityChangeWithUsernameDto {
    entityChange?: EntityChangeDto;
    userName?: string | undefined;

    constructor(data?: IEntityChangeWithUsernameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityChange = _data["entityChange"] ? EntityChangeDto.fromJS(_data["entityChange"]) : <any>undefined;
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): EntityChangeWithUsernameDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeWithUsernameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChange"] = this.entityChange ? this.entityChange.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IEntityChangeWithUsernameDto {
    entityChange?: EntityChangeDto;
    userName?: string | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    id?: string;
    tenantId?: string | undefined;
    entityChangeId?: string;
    newValue?: string | undefined;
    originalValue?: string | undefined;
    propertyName?: string | undefined;
    propertyTypeFullName?: string | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        return data;
    }
}

export interface IEntityPropertyChangeDto {
    id?: string;
    tenantId?: string | undefined;
    entityChangeId?: string;
    newValue?: string | undefined;
    originalValue?: string | undefined;
    propertyName?: string | undefined;
    propertyTypeFullName?: string | undefined;
}

export class GetAverageExecutionDurationPerDayOutput implements IGetAverageExecutionDurationPerDayOutput {
    data?: { [key: string]: number; } | undefined;

    constructor(data?: IGetAverageExecutionDurationPerDayOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetAverageExecutionDurationPerDayOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAverageExecutionDurationPerDayOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface IGetAverageExecutionDurationPerDayOutput {
    data?: { [key: string]: number; } | undefined;
}

export class GetErrorRateOutput implements IGetErrorRateOutput {
    data?: { [key: string]: number; } | undefined;

    constructor(data?: IGetErrorRateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetErrorRateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetErrorRateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface IGetErrorRateOutput {
    data?: { [key: string]: number; } | undefined;
}

export enum EntityChangeType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class FeatureDto implements IFeatureDto {
    name?: string | undefined;
    displayName?: string | undefined;
    value?: string | undefined;
    provider?: FeatureProviderDto;
    description?: string | undefined;
    valueType?: IStringValueType;
    depth?: number;
    parentName?: string | undefined;

    constructor(data?: IFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.value = _data["value"];
            this.provider = _data["provider"] ? FeatureProviderDto.fromJS(_data["provider"]) : <any>undefined;
            this.description = _data["description"];
            this.valueType = _data["valueType"] ? IStringValueType.fromJS(_data["valueType"]) : <any>undefined;
            this.depth = _data["depth"];
            this.parentName = _data["parentName"];
        }
    }

    static fromJS(data: any): FeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["value"] = this.value;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["valueType"] = this.valueType ? this.valueType.toJSON() : <any>undefined;
        data["depth"] = this.depth;
        data["parentName"] = this.parentName;
        return data;
    }
}

export interface IFeatureDto {
    name?: string | undefined;
    displayName?: string | undefined;
    value?: string | undefined;
    provider?: FeatureProviderDto;
    description?: string | undefined;
    valueType?: IStringValueType;
    depth?: number;
    parentName?: string | undefined;
}

export class FeatureGroupDto implements IFeatureGroupDto {
    name?: string | undefined;
    displayName?: string | undefined;
    features?: FeatureDto[] | undefined;

    constructor(data?: IFeatureGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeatureGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFeatureGroupDto {
    name?: string | undefined;
    displayName?: string | undefined;
    features?: FeatureDto[] | undefined;
}

export class FeatureProviderDto implements IFeatureProviderDto {
    name?: string | undefined;
    key?: string | undefined;

    constructor(data?: IFeatureProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): FeatureProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["key"] = this.key;
        return data;
    }
}

export interface IFeatureProviderDto {
    name?: string | undefined;
    key?: string | undefined;
}

export class GetFeatureListResultDto implements IGetFeatureListResultDto {
    groups?: FeatureGroupDto[] | undefined;

    constructor(data?: IGetFeatureListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(FeatureGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetFeatureListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeatureListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetFeatureListResultDto {
    groups?: FeatureGroupDto[] | undefined;
}

export class UpdateFeatureDto implements IUpdateFeatureDto {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: IUpdateFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateFeatureDto {
    name?: string | undefined;
    value?: string | undefined;
}

export class UpdateFeaturesDto implements IUpdateFeaturesDto {
    features?: UpdateFeatureDto[] | undefined;

    constructor(data?: IUpdateFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(UpdateFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateFeaturesDto {
    features?: UpdateFeatureDto[] | undefined;
}

export class DownloadTokenResultDto implements IDownloadTokenResultDto {
    token?: string | undefined;

    constructor(data?: IDownloadTokenResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): DownloadTokenResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadTokenResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IDownloadTokenResultDto {
    token?: string | undefined;
}

export class GdprRequestDto implements IGdprRequestDto {
    id?: string;
    creationTime?: Date;
    readyTime?: Date;

    constructor(data?: IGdprRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.readyTime = _data["readyTime"] ? new Date(_data["readyTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GdprRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GdprRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["readyTime"] = this.readyTime ? this.readyTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGdprRequestDto {
    id?: string;
    creationTime?: Date;
    readyTime?: Date;
}

export class ActionApiDescriptionModel implements IActionApiDescriptionModel {
    uniqueName?: string | undefined;
    name?: string | undefined;
    httpMethod?: string | undefined;
    url?: string | undefined;
    supportedVersions?: string[] | undefined;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | undefined;
    parameters?: ParameterApiDescriptionModel[] | undefined;
    returnValue?: ReturnValueApiDescriptionModel;
    allowAnonymous?: boolean | undefined;
    implementFrom?: string | undefined;

    constructor(data?: IActionApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueName = _data["uniqueName"];
            this.name = _data["name"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            if (Array.isArray(_data["supportedVersions"])) {
                this.supportedVersions = [] as any;
                for (let item of _data["supportedVersions"])
                    this.supportedVersions!.push(item);
            }
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(ParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>undefined;
            this.allowAnonymous = _data["allowAnonymous"];
            this.implementFrom = _data["implementFrom"];
        }
    }

    static fromJS(data: any): ActionApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName;
        data["name"] = this.name;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        if (Array.isArray(this.supportedVersions)) {
            data["supportedVersions"] = [];
            for (let item of this.supportedVersions)
                data["supportedVersions"].push(item);
        }
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        data["allowAnonymous"] = this.allowAnonymous;
        data["implementFrom"] = this.implementFrom;
        return data;
    }
}

export interface IActionApiDescriptionModel {
    uniqueName?: string | undefined;
    name?: string | undefined;
    httpMethod?: string | undefined;
    url?: string | undefined;
    supportedVersions?: string[] | undefined;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | undefined;
    parameters?: ParameterApiDescriptionModel[] | undefined;
    returnValue?: ReturnValueApiDescriptionModel;
    allowAnonymous?: boolean | undefined;
    implementFrom?: string | undefined;
}

export class ApplicationApiDescriptionModel implements IApplicationApiDescriptionModel {
    modules?: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types?: { [key: string]: TypeApiDescriptionModel; } | undefined;

    constructor(data?: IApplicationApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleApiDescriptionModel.fromJS(_data["modules"][key]) : new ModuleApiDescriptionModel();
                }
            }
            if (_data["types"]) {
                this.types = {} as any;
                for (let key in _data["types"]) {
                    if (_data["types"].hasOwnProperty(key))
                        (<any>this.types)![key] = _data["types"][key] ? TypeApiDescriptionModel.fromJS(_data["types"][key]) : new TypeApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    (<any>data["types"])[key] = this.types[key] ? this.types[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationApiDescriptionModel {
    modules?: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types?: { [key: string]: TypeApiDescriptionModel; } | undefined;
}

export class ControllerApiDescriptionModel implements IControllerApiDescriptionModel {
    controllerName?: string | undefined;
    controllerGroupName?: string | undefined;
    isRemoteService?: boolean;
    isIntegrationService?: boolean;
    apiVersion?: string | undefined;
    type?: string | undefined;
    interfaces?: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions?: { [key: string]: ActionApiDescriptionModel; } | undefined;

    constructor(data?: IControllerApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllerName = _data["controllerName"];
            this.controllerGroupName = _data["controllerGroupName"];
            this.isRemoteService = _data["isRemoteService"];
            this.isIntegrationService = _data["isIntegrationService"];
            this.apiVersion = _data["apiVersion"];
            this.type = _data["type"];
            if (Array.isArray(_data["interfaces"])) {
                this.interfaces = [] as any;
                for (let item of _data["interfaces"])
                    this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item));
            }
            if (_data["actions"]) {
                this.actions = {} as any;
                for (let key in _data["actions"]) {
                    if (_data["actions"].hasOwnProperty(key))
                        (<any>this.actions)![key] = _data["actions"][key] ? ActionApiDescriptionModel.fromJS(_data["actions"][key]) : new ActionApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ControllerApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerName"] = this.controllerName;
        data["controllerGroupName"] = this.controllerGroupName;
        data["isRemoteService"] = this.isRemoteService;
        data["isIntegrationService"] = this.isIntegrationService;
        data["apiVersion"] = this.apiVersion;
        data["type"] = this.type;
        if (Array.isArray(this.interfaces)) {
            data["interfaces"] = [];
            for (let item of this.interfaces)
                data["interfaces"].push(item.toJSON());
        }
        if (this.actions) {
            data["actions"] = {};
            for (let key in this.actions) {
                if (this.actions.hasOwnProperty(key))
                    (<any>data["actions"])[key] = this.actions[key] ? this.actions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IControllerApiDescriptionModel {
    controllerName?: string | undefined;
    controllerGroupName?: string | undefined;
    isRemoteService?: boolean;
    isIntegrationService?: boolean;
    apiVersion?: string | undefined;
    type?: string | undefined;
    interfaces?: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions?: { [key: string]: ActionApiDescriptionModel; } | undefined;
}

export class ControllerInterfaceApiDescriptionModel implements IControllerInterfaceApiDescriptionModel {
    type?: string | undefined;
    name?: string | undefined;
    methods?: InterfaceMethodApiDescriptionModel[] | undefined;

    constructor(data?: IControllerInterfaceApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            if (Array.isArray(_data["methods"])) {
                this.methods = [] as any;
                for (let item of _data["methods"])
                    this.methods!.push(InterfaceMethodApiDescriptionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ControllerInterfaceApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerInterfaceApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        if (Array.isArray(this.methods)) {
            data["methods"] = [];
            for (let item of this.methods)
                data["methods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IControllerInterfaceApiDescriptionModel {
    type?: string | undefined;
    name?: string | undefined;
    methods?: InterfaceMethodApiDescriptionModel[] | undefined;
}

export class InterfaceMethodApiDescriptionModel implements IInterfaceMethodApiDescriptionModel {
    name?: string | undefined;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | undefined;
    returnValue?: ReturnValueApiDescriptionModel;

    constructor(data?: IInterfaceMethodApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InterfaceMethodApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new InterfaceMethodApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInterfaceMethodApiDescriptionModel {
    name?: string | undefined;
    parametersOnMethod?: MethodParameterApiDescriptionModel[] | undefined;
    returnValue?: ReturnValueApiDescriptionModel;
}

export class MethodParameterApiDescriptionModel implements IMethodParameterApiDescriptionModel {
    name?: string | undefined;
    typeAsString?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isOptional?: boolean;
    defaultValue?: any | undefined;

    constructor(data?: IMethodParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeAsString = _data["typeAsString"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): MethodParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new MethodParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeAsString"] = this.typeAsString;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IMethodParameterApiDescriptionModel {
    name?: string | undefined;
    typeAsString?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isOptional?: boolean;
    defaultValue?: any | undefined;
}

export class ModuleApiDescriptionModel implements IModuleApiDescriptionModel {
    rootPath?: string | undefined;
    remoteServiceName?: string | undefined;
    controllers?: { [key: string]: ControllerApiDescriptionModel; } | undefined;

    constructor(data?: IModuleApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"];
            this.remoteServiceName = _data["remoteServiceName"];
            if (_data["controllers"]) {
                this.controllers = {} as any;
                for (let key in _data["controllers"]) {
                    if (_data["controllers"].hasOwnProperty(key))
                        (<any>this.controllers)![key] = _data["controllers"][key] ? ControllerApiDescriptionModel.fromJS(_data["controllers"][key]) : new ControllerApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ModuleApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath;
        data["remoteServiceName"] = this.remoteServiceName;
        if (this.controllers) {
            data["controllers"] = {};
            for (let key in this.controllers) {
                if (this.controllers.hasOwnProperty(key))
                    (<any>data["controllers"])[key] = this.controllers[key] ? this.controllers[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IModuleApiDescriptionModel {
    rootPath?: string | undefined;
    remoteServiceName?: string | undefined;
    controllers?: { [key: string]: ControllerApiDescriptionModel; } | undefined;
}

export class ParameterApiDescriptionModel implements IParameterApiDescriptionModel {
    nameOnMethod?: string | undefined;
    name?: string | undefined;
    jsonName?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isOptional?: boolean;
    defaultValue?: any | undefined;
    constraintTypes?: string[] | undefined;
    bindingSourceId?: string | undefined;
    descriptorName?: string | undefined;

    constructor(data?: IParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameOnMethod = _data["nameOnMethod"];
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
            if (Array.isArray(_data["constraintTypes"])) {
                this.constraintTypes = [] as any;
                for (let item of _data["constraintTypes"])
                    this.constraintTypes!.push(item);
            }
            this.bindingSourceId = _data["bindingSourceId"];
            this.descriptorName = _data["descriptorName"];
        }
    }

    static fromJS(data: any): ParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOnMethod"] = this.nameOnMethod;
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        if (Array.isArray(this.constraintTypes)) {
            data["constraintTypes"] = [];
            for (let item of this.constraintTypes)
                data["constraintTypes"].push(item);
        }
        data["bindingSourceId"] = this.bindingSourceId;
        data["descriptorName"] = this.descriptorName;
        return data;
    }
}

export interface IParameterApiDescriptionModel {
    nameOnMethod?: string | undefined;
    name?: string | undefined;
    jsonName?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isOptional?: boolean;
    defaultValue?: any | undefined;
    constraintTypes?: string[] | undefined;
    bindingSourceId?: string | undefined;
    descriptorName?: string | undefined;
}

export class PropertyApiDescriptionModel implements IPropertyApiDescriptionModel {
    name?: string | undefined;
    jsonName?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isRequired?: boolean;
    minLength?: number | undefined;
    maxLength?: number | undefined;
    minimum?: string | undefined;
    maximum?: string | undefined;
    regex?: string | undefined;

    constructor(data?: IPropertyApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isRequired = _data["isRequired"];
            this.minLength = _data["minLength"];
            this.maxLength = _data["maxLength"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
            this.regex = _data["regex"];
        }
    }

    static fromJS(data: any): PropertyApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isRequired"] = this.isRequired;
        data["minLength"] = this.minLength;
        data["maxLength"] = this.maxLength;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["regex"] = this.regex;
        return data;
    }
}

export interface IPropertyApiDescriptionModel {
    name?: string | undefined;
    jsonName?: string | undefined;
    type?: string | undefined;
    typeSimple?: string | undefined;
    isRequired?: boolean;
    minLength?: number | undefined;
    maxLength?: number | undefined;
    minimum?: string | undefined;
    maximum?: string | undefined;
    regex?: string | undefined;
}

export class ReturnValueApiDescriptionModel implements IReturnValueApiDescriptionModel {
    type?: string | undefined;
    typeSimple?: string | undefined;

    constructor(data?: IReturnValueApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
        }
    }

    static fromJS(data: any): ReturnValueApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnValueApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        return data;
    }
}

export interface IReturnValueApiDescriptionModel {
    type?: string | undefined;
    typeSimple?: string | undefined;
}

export class TypeApiDescriptionModel implements ITypeApiDescriptionModel {
    baseType?: string | undefined;
    isEnum?: boolean;
    enumNames?: string[] | undefined;
    enumValues?: any[] | undefined;
    genericArguments?: string[] | undefined;
    properties?: PropertyApiDescriptionModel[] | undefined;

    constructor(data?: ITypeApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseType = _data["baseType"];
            this.isEnum = _data["isEnum"];
            if (Array.isArray(_data["enumNames"])) {
                this.enumNames = [] as any;
                for (let item of _data["enumNames"])
                    this.enumNames!.push(item);
            }
            if (Array.isArray(_data["enumValues"])) {
                this.enumValues = [] as any;
                for (let item of _data["enumValues"])
                    this.enumValues!.push(item);
            }
            if (Array.isArray(_data["genericArguments"])) {
                this.genericArguments = [] as any;
                for (let item of _data["genericArguments"])
                    this.genericArguments!.push(item);
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(PropertyApiDescriptionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new TypeApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseType"] = this.baseType;
        data["isEnum"] = this.isEnum;
        if (Array.isArray(this.enumNames)) {
            data["enumNames"] = [];
            for (let item of this.enumNames)
                data["enumNames"].push(item);
        }
        if (Array.isArray(this.enumValues)) {
            data["enumValues"] = [];
            for (let item of this.enumValues)
                data["enumValues"].push(item);
        }
        if (Array.isArray(this.genericArguments)) {
            data["genericArguments"] = [];
            for (let item of this.genericArguments)
                data["genericArguments"].push(item);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeApiDescriptionModel {
    baseType?: string | undefined;
    isEnum?: boolean;
    enumNames?: string[] | undefined;
    enumValues?: any[] | undefined;
    genericArguments?: string[] | undefined;
    properties?: PropertyApiDescriptionModel[] | undefined;
}

export class RemoteServiceErrorInfo implements IRemoteServiceErrorInfo {
    code?: string | undefined;
    message?: string | undefined;
    details?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    validationErrors?: RemoteServiceValidationErrorInfo[] | undefined;

    constructor(data?: IRemoteServiceErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(RemoteServiceValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RemoteServiceErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRemoteServiceErrorInfo {
    code?: string | undefined;
    message?: string | undefined;
    details?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    validationErrors?: RemoteServiceValidationErrorInfo[] | undefined;
}

export class RemoteServiceErrorResponse implements IRemoteServiceErrorResponse {
    error?: RemoteServiceErrorInfo;

    constructor(data?: IRemoteServiceErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? RemoteServiceErrorInfo.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RemoteServiceErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRemoteServiceErrorResponse {
    error?: RemoteServiceErrorInfo;
}

export class RemoteServiceValidationErrorInfo implements IRemoteServiceValidationErrorInfo {
    message?: string | undefined;
    members?: string[] | undefined;

    constructor(data?: IRemoteServiceValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoteServiceValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data;
    }
}

export interface IRemoteServiceValidationErrorInfo {
    message?: string | undefined;
    members?: string[] | undefined;
}

export class ClaimTypeDto implements IClaimTypeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    required?: boolean;
    isStatic?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
    valueTypeAsString?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IClaimTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.required = _data["required"];
            this.isStatic = _data["isStatic"];
            this.regex = _data["regex"];
            this.regexDescription = _data["regexDescription"];
            this.description = _data["description"];
            this.valueType = _data["valueType"];
            this.valueTypeAsString = _data["valueTypeAsString"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): ClaimTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["required"] = this.required;
        data["isStatic"] = this.isStatic;
        data["regex"] = this.regex;
        data["regexDescription"] = this.regexDescription;
        data["description"] = this.description;
        data["valueType"] = this.valueType;
        data["valueTypeAsString"] = this.valueTypeAsString;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IClaimTypeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    required?: boolean;
    isStatic?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
    valueTypeAsString?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class CreateClaimTypeDto implements ICreateClaimTypeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    required?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;

    constructor(data?: ICreateClaimTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.required = _data["required"];
            this.regex = _data["regex"];
            this.regexDescription = _data["regexDescription"];
            this.description = _data["description"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): CreateClaimTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClaimTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["required"] = this.required;
        data["regex"] = this.regex;
        data["regexDescription"] = this.regexDescription;
        data["description"] = this.description;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface ICreateClaimTypeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    required?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
}

export class ExternalLoginProviderDto implements IExternalLoginProviderDto {
    name?: string | undefined;
    canObtainUserInfoWithoutPassword?: boolean;

    constructor(data?: IExternalLoginProviderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.canObtainUserInfoWithoutPassword = _data["canObtainUserInfoWithoutPassword"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["canObtainUserInfoWithoutPassword"] = this.canObtainUserInfoWithoutPassword;
        return data;
    }
}

export interface IExternalLoginProviderDto {
    name?: string | undefined;
    canObtainUserInfoWithoutPassword?: boolean;
}

export enum IdentityProTwoFactorBehaviour {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum IdentityClaimValueType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IdentityLdapSettingsDto implements IIdentityLdapSettingsDto {
    enableLdapLogin?: boolean;
    ldapServerHost?: string | undefined;
    ldapServerPort?: string | undefined;
    ldapBaseDc?: string | undefined;
    ldapDomain?: string | undefined;
    ldapUserName?: string | undefined;
    ldapPassword?: string | undefined;

    constructor(data?: IIdentityLdapSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableLdapLogin = _data["enableLdapLogin"];
            this.ldapServerHost = _data["ldapServerHost"];
            this.ldapServerPort = _data["ldapServerPort"];
            this.ldapBaseDc = _data["ldapBaseDc"];
            this.ldapDomain = _data["ldapDomain"];
            this.ldapUserName = _data["ldapUserName"];
            this.ldapPassword = _data["ldapPassword"];
        }
    }

    static fromJS(data: any): IdentityLdapSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityLdapSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableLdapLogin"] = this.enableLdapLogin;
        data["ldapServerHost"] = this.ldapServerHost;
        data["ldapServerPort"] = this.ldapServerPort;
        data["ldapBaseDc"] = this.ldapBaseDc;
        data["ldapDomain"] = this.ldapDomain;
        data["ldapUserName"] = this.ldapUserName;
        data["ldapPassword"] = this.ldapPassword;
        return data;
    }
}

export interface IIdentityLdapSettingsDto {
    enableLdapLogin?: boolean;
    ldapServerHost?: string | undefined;
    ldapServerPort?: string | undefined;
    ldapBaseDc?: string | undefined;
    ldapDomain?: string | undefined;
    ldapUserName?: string | undefined;
    ldapPassword?: string | undefined;
}

export class IdentityLockoutSettingsDto implements IIdentityLockoutSettingsDto {
    allowedForNewUsers?: boolean;
    lockoutDuration?: number;
    maxFailedAccessAttempts?: number;

    constructor(data?: IIdentityLockoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowedForNewUsers = _data["allowedForNewUsers"];
            this.lockoutDuration = _data["lockoutDuration"];
            this.maxFailedAccessAttempts = _data["maxFailedAccessAttempts"];
        }
    }

    static fromJS(data: any): IdentityLockoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityLockoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowedForNewUsers"] = this.allowedForNewUsers;
        data["lockoutDuration"] = this.lockoutDuration;
        data["maxFailedAccessAttempts"] = this.maxFailedAccessAttempts;
        return data;
    }
}

export interface IIdentityLockoutSettingsDto {
    allowedForNewUsers?: boolean;
    lockoutDuration?: number;
    maxFailedAccessAttempts?: number;
}

export class IdentityOAuthSettingsDto implements IIdentityOAuthSettingsDto {
    enableOAuthLogin?: boolean;
    clientId!: string;
    clientSecret?: string | undefined;
    authority!: string;
    scope?: string | undefined;
    requireHttpsMetadata?: boolean;
    validateEndpoints?: boolean;
    validateIssuerName?: boolean;

    constructor(data?: IIdentityOAuthSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableOAuthLogin = _data["enableOAuthLogin"];
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.authority = _data["authority"];
            this.scope = _data["scope"];
            this.requireHttpsMetadata = _data["requireHttpsMetadata"];
            this.validateEndpoints = _data["validateEndpoints"];
            this.validateIssuerName = _data["validateIssuerName"];
        }
    }

    static fromJS(data: any): IdentityOAuthSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityOAuthSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableOAuthLogin"] = this.enableOAuthLogin;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["scope"] = this.scope;
        data["requireHttpsMetadata"] = this.requireHttpsMetadata;
        data["validateEndpoints"] = this.validateEndpoints;
        data["validateIssuerName"] = this.validateIssuerName;
        return data;
    }
}

export interface IIdentityOAuthSettingsDto {
    enableOAuthLogin?: boolean;
    clientId: string;
    clientSecret?: string | undefined;
    authority: string;
    scope?: string | undefined;
    requireHttpsMetadata?: boolean;
    validateEndpoints?: boolean;
    validateIssuerName?: boolean;
}

export class IdentityPasswordSettingsDto implements IIdentityPasswordSettingsDto {
    requiredLength?: number;
    requiredUniqueChars?: number;
    requireNonAlphanumeric?: boolean;
    requireLowercase?: boolean;
    requireUppercase?: boolean;
    requireDigit?: boolean;

    constructor(data?: IIdentityPasswordSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requiredLength = _data["requiredLength"];
            this.requiredUniqueChars = _data["requiredUniqueChars"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireUppercase = _data["requireUppercase"];
            this.requireDigit = _data["requireDigit"];
        }
    }

    static fromJS(data: any): IdentityPasswordSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityPasswordSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requiredLength"] = this.requiredLength;
        data["requiredUniqueChars"] = this.requiredUniqueChars;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireLowercase"] = this.requireLowercase;
        data["requireUppercase"] = this.requireUppercase;
        data["requireDigit"] = this.requireDigit;
        return data;
    }
}

export interface IIdentityPasswordSettingsDto {
    requiredLength?: number;
    requiredUniqueChars?: number;
    requireNonAlphanumeric?: boolean;
    requireLowercase?: boolean;
    requireUppercase?: boolean;
    requireDigit?: boolean;
}

export class IdentityRoleClaimDto implements IIdentityRoleClaimDto {
    roleId?: string;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityRoleClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): IdentityRoleClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IIdentityRoleClaimDto {
    roleId?: string;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class IdentityRoleCreateDto implements IIdentityRoleCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    isDefault?: boolean;
    isPublic?: boolean;

    constructor(data?: IIdentityRoleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): IdentityRoleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        return data;
    }
}

export interface IIdentityRoleCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    isDefault?: boolean;
    isPublic?: boolean;
}

export class IdentityRoleDto implements IIdentityRoleDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    isDefault?: boolean;
    isStatic?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IIdentityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isStatic = _data["isStatic"];
            this.isPublic = _data["isPublic"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    isDefault?: boolean;
    isStatic?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | undefined;
}

export class IdentityRoleLookupDto implements IIdentityRoleLookupDto {
    id?: string;
    name?: string | undefined;

    constructor(data?: IIdentityRoleLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdentityRoleLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IIdentityRoleLookupDto {
    id?: string;
    name?: string | undefined;
}

export class IdentityRoleUpdateDto implements IIdentityRoleUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    isDefault?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IIdentityRoleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    isDefault?: boolean;
    isPublic?: boolean;
    concurrencyStamp?: string | undefined;
}

export class IdentitySecurityLogDto implements IIdentitySecurityLogDto {
    id?: string;
    tenantId?: string | undefined;
    applicationName?: string | undefined;
    identity?: string | undefined;
    action?: string | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    tenantName?: string | undefined;
    clientId?: string | undefined;
    correlationId?: string | undefined;
    clientIpAddress?: string | undefined;
    browserInfo?: string | undefined;
    creationTime?: Date;
    extraProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IIdentitySecurityLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.applicationName = _data["applicationName"];
            this.identity = _data["identity"];
            this.action = _data["action"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.tenantName = _data["tenantName"];
            this.clientId = _data["clientId"];
            this.correlationId = _data["correlationId"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.browserInfo = _data["browserInfo"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): IdentitySecurityLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentitySecurityLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["applicationName"] = this.applicationName;
        data["identity"] = this.identity;
        data["action"] = this.action;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["tenantName"] = this.tenantName;
        data["clientId"] = this.clientId;
        data["correlationId"] = this.correlationId;
        data["clientIpAddress"] = this.clientIpAddress;
        data["browserInfo"] = this.browserInfo;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IIdentitySecurityLogDto {
    id?: string;
    tenantId?: string | undefined;
    applicationName?: string | undefined;
    identity?: string | undefined;
    action?: string | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    tenantName?: string | undefined;
    clientId?: string | undefined;
    correlationId?: string | undefined;
    clientIpAddress?: string | undefined;
    browserInfo?: string | undefined;
    creationTime?: Date;
    extraProperties?: { [key: string]: any; } | undefined;
}

export class IdentitySettingsDto implements IIdentitySettingsDto {
    password?: IdentityPasswordSettingsDto;
    lockout?: IdentityLockoutSettingsDto;
    signIn?: IdentitySignInSettingsDto;
    user?: IdentityUserSettingsDto;

    constructor(data?: IIdentitySettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"] ? IdentityPasswordSettingsDto.fromJS(_data["password"]) : <any>undefined;
            this.lockout = _data["lockout"] ? IdentityLockoutSettingsDto.fromJS(_data["lockout"]) : <any>undefined;
            this.signIn = _data["signIn"] ? IdentitySignInSettingsDto.fromJS(_data["signIn"]) : <any>undefined;
            this.user = _data["user"] ? IdentityUserSettingsDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IdentitySettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentitySettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password ? this.password.toJSON() : <any>undefined;
        data["lockout"] = this.lockout ? this.lockout.toJSON() : <any>undefined;
        data["signIn"] = this.signIn ? this.signIn.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIdentitySettingsDto {
    password?: IdentityPasswordSettingsDto;
    lockout?: IdentityLockoutSettingsDto;
    signIn?: IdentitySignInSettingsDto;
    user?: IdentityUserSettingsDto;
}

export class IdentitySignInSettingsDto implements IIdentitySignInSettingsDto {
    requireConfirmedEmail?: boolean;
    enablePhoneNumberConfirmation?: boolean;
    requireConfirmedPhoneNumber?: boolean;

    constructor(data?: IIdentitySignInSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requireConfirmedEmail = _data["requireConfirmedEmail"];
            this.enablePhoneNumberConfirmation = _data["enablePhoneNumberConfirmation"];
            this.requireConfirmedPhoneNumber = _data["requireConfirmedPhoneNumber"];
        }
    }

    static fromJS(data: any): IdentitySignInSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentitySignInSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireConfirmedEmail"] = this.requireConfirmedEmail;
        data["enablePhoneNumberConfirmation"] = this.enablePhoneNumberConfirmation;
        data["requireConfirmedPhoneNumber"] = this.requireConfirmedPhoneNumber;
        return data;
    }
}

export interface IIdentitySignInSettingsDto {
    requireConfirmedEmail?: boolean;
    enablePhoneNumberConfirmation?: boolean;
    requireConfirmedPhoneNumber?: boolean;
}

export class IdentityUserClaimDto implements IIdentityUserClaimDto {
    userId?: string;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityUserClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): IdentityUserClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IIdentityUserClaimDto {
    userId?: string;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class IdentityUserCreateDto implements IIdentityUserCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName!: string;
    name?: string | undefined;
    surname?: string | undefined;
    email!: string;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | undefined;
    organizationUnitIds?: string[] | undefined;
    password!: string;
    sendConfirmationEmail?: boolean;

    constructor(data?: IIdentityUserCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            if (Array.isArray(_data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of _data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
            this.password = _data["password"];
            this.sendConfirmationEmail = _data["sendConfirmationEmail"];
        }
    }

    static fromJS(data: any): IdentityUserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        data["password"] = this.password;
        data["sendConfirmationEmail"] = this.sendConfirmationEmail;
        return data;
    }
}

export interface IIdentityUserCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName: string;
    name?: string | undefined;
    surname?: string | undefined;
    email: string;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | undefined;
    organizationUnitIds?: string[] | undefined;
    password: string;
    sendConfirmationEmail?: boolean;
}

export class IdentityUserDto implements IIdentityUserDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    tenantId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    supportTwoFactor?: boolean;
    twoFactorEnabled?: boolean;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    isLockedOut?: boolean;
    lockoutEnd?: Date | undefined;
    concurrencyStamp?: string | undefined;
    roleNames?: string[] | undefined;
    accessFailedCount?: number;

    constructor(data?: IIdentityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.supportTwoFactor = _data["supportTwoFactor"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.isLockedOut = _data["isLockedOut"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["supportTwoFactor"] = this.supportTwoFactor;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["isLockedOut"] = this.isLockedOut;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    tenantId?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    supportTwoFactor?: boolean;
    twoFactorEnabled?: boolean;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    isLockedOut?: boolean;
    lockoutEnd?: Date | undefined;
    concurrencyStamp?: string | undefined;
    roleNames?: string[] | undefined;
    accessFailedCount?: number;
}

export class IdentityUserSettingsDto implements IIdentityUserSettingsDto {
    isUserNameUpdateEnabled?: boolean;
    isEmailUpdateEnabled?: boolean;

    constructor(data?: IIdentityUserSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUserNameUpdateEnabled = _data["isUserNameUpdateEnabled"];
            this.isEmailUpdateEnabled = _data["isEmailUpdateEnabled"];
        }
    }

    static fromJS(data: any): IdentityUserSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUserNameUpdateEnabled"] = this.isUserNameUpdateEnabled;
        data["isEmailUpdateEnabled"] = this.isEmailUpdateEnabled;
        return data;
    }
}

export interface IIdentityUserSettingsDto {
    isUserNameUpdateEnabled?: boolean;
    isEmailUpdateEnabled?: boolean;
}

export class IdentityUserUpdateDto implements IIdentityUserUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    userName!: string;
    name?: string | undefined;
    surname?: string | undefined;
    email!: string;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | undefined;
    organizationUnitIds?: string[] | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IIdentityUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.isActive = _data["isActive"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            if (Array.isArray(_data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of _data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityUserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["isActive"] = this.isActive;
        data["lockoutEnabled"] = this.lockoutEnabled;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityUserUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    userName: string;
    name?: string | undefined;
    surname?: string | undefined;
    email: string;
    phoneNumber?: string | undefined;
    isActive?: boolean;
    lockoutEnabled?: boolean;
    roleNames?: string[] | undefined;
    organizationUnitIds?: string[] | undefined;
    concurrencyStamp?: string | undefined;
}

export class IdentityUserUpdatePasswordInput implements IIdentityUserUpdatePasswordInput {
    newPassword!: string;

    constructor(data?: IIdentityUserUpdatePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): IdentityUserUpdatePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdatePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IIdentityUserUpdatePasswordInput {
    newPassword: string;
}

export class IdentityUserUpdateRolesDto implements IIdentityUserUpdateRolesDto {
    roleNames!: string[];

    constructor(data?: IIdentityUserUpdateRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityUserUpdateRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserUpdateRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }
}

export interface IIdentityUserUpdateRolesDto {
    roleNames: string[];
}

export class ImportExternalUserInput implements IImportExternalUserInput {
    provider!: string;
    userNameOrEmailAddress!: string;
    password?: string | undefined;

    constructor(data?: IImportExternalUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ImportExternalUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportExternalUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface IImportExternalUserInput {
    provider: string;
    userNameOrEmailAddress: string;
    password?: string | undefined;
}

export class OrganizationUnitCreateDto implements IOrganizationUnitCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName!: string;
    parentId?: string | undefined;

    constructor(data?: IOrganizationUnitCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): OrganizationUnitCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        return data;
    }
}

export interface IOrganizationUnitCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName: string;
    parentId?: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    roles?: OrganizationUnitRoleDto[] | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(OrganizationUnitRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationUnitDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    roles?: OrganizationUnitRoleDto[] | undefined;
}

export class OrganizationUnitLookupDto implements IOrganizationUnitLookupDto {
    id?: string;
    displayName?: string | undefined;

    constructor(data?: IOrganizationUnitLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): OrganizationUnitLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IOrganizationUnitLookupDto {
    id?: string;
    displayName?: string | undefined;
}

export class OrganizationUnitMoveInput implements IOrganizationUnitMoveInput {
    newParentId?: string | undefined;

    constructor(data?: IOrganizationUnitMoveInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): OrganizationUnitMoveInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitMoveInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newParentId"] = this.newParentId;
        return data;
    }
}

export interface IOrganizationUnitMoveInput {
    newParentId?: string | undefined;
}

export class OrganizationUnitRoleDto implements IOrganizationUnitRoleDto {
    creationTime?: Date;
    creatorId?: string | undefined;
    organizationUnitId?: string;
    roleId?: string;

    constructor(data?: IOrganizationUnitRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IOrganizationUnitRoleDto {
    creationTime?: Date;
    creatorId?: string | undefined;
    organizationUnitId?: string;
    roleId?: string;
}

export class OrganizationUnitRoleInput implements IOrganizationUnitRoleInput {
    roleIds?: string[] | undefined;

    constructor(data?: IOrganizationUnitRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): OrganizationUnitRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        return data;
    }
}

export interface IOrganizationUnitRoleInput {
    roleIds?: string[] | undefined;
}

export class OrganizationUnitUpdateDto implements IOrganizationUnitUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName!: string;
    concurrencyStamp?: string | undefined;

    constructor(data?: IOrganizationUnitUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): OrganizationUnitUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IOrganizationUnitUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName: string;
    concurrencyStamp?: string | undefined;
}

export class OrganizationUnitUserInput implements IOrganizationUnitUserInput {
    userIds?: string[] | undefined;

    constructor(data?: IOrganizationUnitUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
        }
    }

    static fromJS(data: any): OrganizationUnitUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        return data;
    }
}

export interface IOrganizationUnitUserInput {
    userIds?: string[] | undefined;
}

export class OrganizationUnitWithDetailsDto implements IOrganizationUnitWithDetailsDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    roles?: IdentityRoleDto[] | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IOrganizationUnitWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierId = _data["lastModifierId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterId = _data["deleterId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(IdentityRoleDto.fromJS(item));
            }
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): OrganizationUnitWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierId"] = this.lastModifierId;
        data["isDeleted"] = this.isDeleted;
        data["deleterId"] = this.deleterId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IOrganizationUnitWithDetailsDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    lastModificationTime?: Date | undefined;
    lastModifierId?: string | undefined;
    isDeleted?: boolean;
    deleterId?: string | undefined;
    deletionTime?: Date | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    roles?: IdentityRoleDto[] | undefined;
    concurrencyStamp?: string | undefined;
}

export class UpdateClaimTypeDto implements IUpdateClaimTypeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    required?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateClaimTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.required = _data["required"];
            this.regex = _data["regex"];
            this.regexDescription = _data["regexDescription"];
            this.description = _data["description"];
            this.valueType = _data["valueType"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateClaimTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClaimTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["required"] = this.required;
        data["regex"] = this.regex;
        data["regexDescription"] = this.regexDescription;
        data["description"] = this.description;
        data["valueType"] = this.valueType;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateClaimTypeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    required?: boolean;
    regex?: string | undefined;
    regexDescription?: string | undefined;
    description?: string | undefined;
    valueType?: IdentityClaimValueType;
    concurrencyStamp?: string | undefined;
}

export class CreateLanguageDto implements ICreateLanguageDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName?: string | undefined;
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;

    constructor(data?: ICreateLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): CreateLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface ICreateLanguageDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName?: string | undefined;
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
}

export class CultureInfoDto implements ICultureInfoDto {
    displayName?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICultureInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CultureInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CultureInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        return data;
    }
}

export interface ICultureInfoDto {
    displayName?: string | undefined;
    name?: string | undefined;
}

export class LanguageDto implements ILanguageDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    displayName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
    isDefaultLanguage?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: ILanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorId = _data["creatorId"];
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
            this.isDefaultLanguage = _data["isDefaultLanguage"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): LanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorId"] = this.creatorId;
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        data["isDefaultLanguage"] = this.isDefaultLanguage;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ILanguageDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    creationTime?: Date;
    creatorId?: string | undefined;
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    displayName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
    isDefaultLanguage?: boolean;
    concurrencyStamp?: string | undefined;
}

export class LanguageResourceDto implements ILanguageResourceDto {
    name?: string | undefined;

    constructor(data?: ILanguageResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LanguageResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ILanguageResourceDto {
    name?: string | undefined;
}

export class LanguageTextDto implements ILanguageTextDto {
    resourceName?: string | undefined;
    cultureName?: string | undefined;
    baseCultureName?: string | undefined;
    baseValue?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: ILanguageTextDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceName = _data["resourceName"];
            this.cultureName = _data["cultureName"];
            this.baseCultureName = _data["baseCultureName"];
            this.baseValue = _data["baseValue"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LanguageTextDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceName"] = this.resourceName;
        data["cultureName"] = this.cultureName;
        data["baseCultureName"] = this.baseCultureName;
        data["baseValue"] = this.baseValue;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ILanguageTextDto {
    resourceName?: string | undefined;
    cultureName?: string | undefined;
    baseCultureName?: string | undefined;
    baseValue?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
}

export class UpdateLanguageDto implements IUpdateLanguageDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
    concurrencyStamp?: string | undefined;

    constructor(data?: IUpdateLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
            this.isEnabled = _data["isEnabled"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): UpdateLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        data["isEnabled"] = this.isEnabled;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IUpdateLanguageDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName?: string | undefined;
    flagIcon?: string | undefined;
    isEnabled?: boolean;
    concurrencyStamp?: string | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    displayName?: string | undefined;
    readonly twoLetterISOLanguageName?: string | undefined;
    flagIcon?: string | undefined;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cultureName = _data["cultureName"];
            this.uiCultureName = _data["uiCultureName"];
            this.displayName = _data["displayName"];
            (<any>this).twoLetterISOLanguageName = _data["twoLetterISOLanguageName"];
            this.flagIcon = _data["flagIcon"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["twoLetterISOLanguageName"] = this.twoLetterISOLanguageName;
        data["flagIcon"] = this.flagIcon;
        return data;
    }
}

export interface ILanguageInfo {
    cultureName?: string | undefined;
    uiCultureName?: string | undefined;
    displayName?: string | undefined;
    twoLetterISOLanguageName?: string | undefined;
    flagIcon?: string | undefined;
}

export class NameValue implements INameValue {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name?: string | undefined;
    value?: string | undefined;
}

export class ApplicationDto implements IApplicationDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    clientId?: string | undefined;
    displayName?: string | undefined;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;

    constructor(data?: IApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.clientSecret = _data["clientSecret"];
            this.consentType = _data["consentType"];
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            this.allowPasswordFlow = _data["allowPasswordFlow"];
            this.allowClientCredentialsFlow = _data["allowClientCredentialsFlow"];
            this.allowAuthorizationCodeFlow = _data["allowAuthorizationCodeFlow"];
            this.allowRefreshTokenFlow = _data["allowRefreshTokenFlow"];
            this.allowHybridFlow = _data["allowHybridFlow"];
            this.allowImplicitFlow = _data["allowImplicitFlow"];
            this.allowLogoutEndpoint = _data["allowLogoutEndpoint"];
            this.allowDeviceEndpoint = _data["allowDeviceEndpoint"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
        }
    }

    static fromJS(data: any): ApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["clientSecret"] = this.clientSecret;
        data["consentType"] = this.consentType;
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        data["allowPasswordFlow"] = this.allowPasswordFlow;
        data["allowClientCredentialsFlow"] = this.allowClientCredentialsFlow;
        data["allowAuthorizationCodeFlow"] = this.allowAuthorizationCodeFlow;
        data["allowRefreshTokenFlow"] = this.allowRefreshTokenFlow;
        data["allowHybridFlow"] = this.allowHybridFlow;
        data["allowImplicitFlow"] = this.allowImplicitFlow;
        data["allowLogoutEndpoint"] = this.allowLogoutEndpoint;
        data["allowDeviceEndpoint"] = this.allowDeviceEndpoint;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        return data;
    }
}

export interface IApplicationDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    clientId?: string | undefined;
    displayName?: string | undefined;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
}

export class CreateApplicationInput implements ICreateApplicationInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    clientId!: string;
    displayName!: string;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;

    constructor(data?: ICreateApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.clientId = _data["clientId"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.clientSecret = _data["clientSecret"];
            this.consentType = _data["consentType"];
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            this.allowPasswordFlow = _data["allowPasswordFlow"];
            this.allowClientCredentialsFlow = _data["allowClientCredentialsFlow"];
            this.allowAuthorizationCodeFlow = _data["allowAuthorizationCodeFlow"];
            this.allowRefreshTokenFlow = _data["allowRefreshTokenFlow"];
            this.allowHybridFlow = _data["allowHybridFlow"];
            this.allowImplicitFlow = _data["allowImplicitFlow"];
            this.allowLogoutEndpoint = _data["allowLogoutEndpoint"];
            this.allowDeviceEndpoint = _data["allowDeviceEndpoint"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
        }
    }

    static fromJS(data: any): CreateApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["clientId"] = this.clientId;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["clientSecret"] = this.clientSecret;
        data["consentType"] = this.consentType;
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        data["allowPasswordFlow"] = this.allowPasswordFlow;
        data["allowClientCredentialsFlow"] = this.allowClientCredentialsFlow;
        data["allowAuthorizationCodeFlow"] = this.allowAuthorizationCodeFlow;
        data["allowRefreshTokenFlow"] = this.allowRefreshTokenFlow;
        data["allowHybridFlow"] = this.allowHybridFlow;
        data["allowImplicitFlow"] = this.allowImplicitFlow;
        data["allowLogoutEndpoint"] = this.allowLogoutEndpoint;
        data["allowDeviceEndpoint"] = this.allowDeviceEndpoint;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        return data;
    }
}

export interface ICreateApplicationInput {
    extraProperties?: { [key: string]: any; } | undefined;
    clientId: string;
    displayName: string;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
}

export class UpdateApplicationInput implements IUpdateApplicationInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    clientId!: string;
    displayName!: string;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;

    constructor(data?: IUpdateApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.clientId = _data["clientId"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.clientSecret = _data["clientSecret"];
            this.consentType = _data["consentType"];
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            this.allowPasswordFlow = _data["allowPasswordFlow"];
            this.allowClientCredentialsFlow = _data["allowClientCredentialsFlow"];
            this.allowAuthorizationCodeFlow = _data["allowAuthorizationCodeFlow"];
            this.allowRefreshTokenFlow = _data["allowRefreshTokenFlow"];
            this.allowHybridFlow = _data["allowHybridFlow"];
            this.allowImplicitFlow = _data["allowImplicitFlow"];
            this.allowLogoutEndpoint = _data["allowLogoutEndpoint"];
            this.allowDeviceEndpoint = _data["allowDeviceEndpoint"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
        }
    }

    static fromJS(data: any): UpdateApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["clientId"] = this.clientId;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["clientSecret"] = this.clientSecret;
        data["consentType"] = this.consentType;
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        data["allowPasswordFlow"] = this.allowPasswordFlow;
        data["allowClientCredentialsFlow"] = this.allowClientCredentialsFlow;
        data["allowAuthorizationCodeFlow"] = this.allowAuthorizationCodeFlow;
        data["allowRefreshTokenFlow"] = this.allowRefreshTokenFlow;
        data["allowHybridFlow"] = this.allowHybridFlow;
        data["allowImplicitFlow"] = this.allowImplicitFlow;
        data["allowLogoutEndpoint"] = this.allowLogoutEndpoint;
        data["allowDeviceEndpoint"] = this.allowDeviceEndpoint;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        return data;
    }
}

export interface IUpdateApplicationInput {
    extraProperties?: { [key: string]: any; } | undefined;
    clientId: string;
    displayName: string;
    type?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    redirectUris?: string[] | undefined;
    allowPasswordFlow?: boolean;
    allowClientCredentialsFlow?: boolean;
    allowAuthorizationCodeFlow?: boolean;
    allowRefreshTokenFlow?: boolean;
    allowHybridFlow?: boolean;
    allowImplicitFlow?: boolean;
    allowLogoutEndpoint?: boolean;
    allowDeviceEndpoint?: boolean;
    scopes?: string[] | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
}

export class CreateScopeInput implements ICreateScopeInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    displayName?: string | undefined;
    description?: string | undefined;
    resources?: string[] | undefined;

    constructor(data?: ICreateScopeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateScopeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScopeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item);
        }
        return data;
    }
}

export interface ICreateScopeInput {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    displayName?: string | undefined;
    description?: string | undefined;
    resources?: string[] | undefined;
}

export class ScopeDto implements IScopeDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    buildIn?: boolean;
    resources?: string[] | undefined;

    constructor(data?: IScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.buildIn = _data["buildIn"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(item);
            }
        }
    }

    static fromJS(data: any): ScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["buildIn"] = this.buildIn;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item);
        }
        return data;
    }
}

export interface IScopeDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
    buildIn?: boolean;
    resources?: string[] | undefined;
}

export class UpdateScopeInput implements IUpdateScopeInput {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    displayName?: string | undefined;
    description?: string | undefined;
    resources?: string[] | undefined;

    constructor(data?: IUpdateScopeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateScopeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScopeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item);
        }
        return data;
    }
}

export interface IUpdateScopeInput {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    displayName?: string | undefined;
    description?: string | undefined;
    resources?: string[] | undefined;
}

export class GetPermissionListResultDto implements IGetPermissionListResultDto {
    entityDisplayName?: string | undefined;
    groups?: PermissionGroupDto[] | undefined;

    constructor(data?: IGetPermissionListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityDisplayName = _data["entityDisplayName"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(PermissionGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPermissionListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityDisplayName"] = this.entityDisplayName;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPermissionListResultDto {
    entityDisplayName?: string | undefined;
    groups?: PermissionGroupDto[] | undefined;
}

export class PermissionGrantInfoDto implements IPermissionGrantInfoDto {
    name?: string | undefined;
    displayName?: string | undefined;
    parentName?: string | undefined;
    isGranted?: boolean;
    allowedProviders?: string[] | undefined;
    grantedProviders?: ProviderInfoDto[] | undefined;

    constructor(data?: IPermissionGrantInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.parentName = _data["parentName"];
            this.isGranted = _data["isGranted"];
            if (Array.isArray(_data["allowedProviders"])) {
                this.allowedProviders = [] as any;
                for (let item of _data["allowedProviders"])
                    this.allowedProviders!.push(item);
            }
            if (Array.isArray(_data["grantedProviders"])) {
                this.grantedProviders = [] as any;
                for (let item of _data["grantedProviders"])
                    this.grantedProviders!.push(ProviderInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGrantInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrantInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["parentName"] = this.parentName;
        data["isGranted"] = this.isGranted;
        if (Array.isArray(this.allowedProviders)) {
            data["allowedProviders"] = [];
            for (let item of this.allowedProviders)
                data["allowedProviders"].push(item);
        }
        if (Array.isArray(this.grantedProviders)) {
            data["grantedProviders"] = [];
            for (let item of this.grantedProviders)
                data["grantedProviders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGrantInfoDto {
    name?: string | undefined;
    displayName?: string | undefined;
    parentName?: string | undefined;
    isGranted?: boolean;
    allowedProviders?: string[] | undefined;
    grantedProviders?: ProviderInfoDto[] | undefined;
}

export class PermissionGroupDto implements IPermissionGroupDto {
    name?: string | undefined;
    displayName?: string | undefined;
    displayNameKey?: string | undefined;
    displayNameResource?: string | undefined;
    permissions?: PermissionGrantInfoDto[] | undefined;

    constructor(data?: IPermissionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.displayNameKey = _data["displayNameKey"];
            this.displayNameResource = _data["displayNameResource"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionGrantInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["displayNameKey"] = this.displayNameKey;
        data["displayNameResource"] = this.displayNameResource;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGroupDto {
    name?: string | undefined;
    displayName?: string | undefined;
    displayNameKey?: string | undefined;
    displayNameResource?: string | undefined;
    permissions?: PermissionGrantInfoDto[] | undefined;
}

export class ProviderInfoDto implements IProviderInfoDto {
    providerName?: string | undefined;
    providerKey?: string | undefined;

    constructor(data?: IProviderInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.providerName = _data["providerName"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): ProviderInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["providerName"] = this.providerName;
        data["providerKey"] = this.providerKey;
        return data;
    }
}

export interface IProviderInfoDto {
    providerName?: string | undefined;
    providerKey?: string | undefined;
}

export class UpdatePermissionDto implements IUpdatePermissionDto {
    name?: string | undefined;
    isGranted?: boolean;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        return data;
    }
}

export interface IUpdatePermissionDto {
    name?: string | undefined;
    isGranted?: boolean;
}

export class UpdatePermissionsDto implements IUpdatePermissionsDto {
    permissions?: UpdatePermissionDto[] | undefined;

    constructor(data?: IUpdatePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UpdatePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdatePermissionsDto {
    permissions?: UpdatePermissionDto[] | undefined;
}

export class EmailSettingsDto implements IEmailSettingsDto {
    smtpHost?: string | undefined;
    smtpPort?: number;
    smtpUserName?: string | undefined;
    smtpPassword?: string | undefined;
    smtpDomain?: string | undefined;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress?: string | undefined;
    defaultFromDisplayName?: string | undefined;

    constructor(data?: IEmailSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): EmailSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data;
    }
}

export interface IEmailSettingsDto {
    smtpHost?: string | undefined;
    smtpPort?: number;
    smtpUserName?: string | undefined;
    smtpPassword?: string | undefined;
    smtpDomain?: string | undefined;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress?: string | undefined;
    defaultFromDisplayName?: string | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    senderEmailAddress!: string;
    targetEmailAddress!: string;
    subject!: string;
    body?: string | undefined;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderEmailAddress = _data["senderEmailAddress"];
            this.targetEmailAddress = _data["targetEmailAddress"];
            this.subject = _data["subject"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderEmailAddress"] = this.senderEmailAddress;
        data["targetEmailAddress"] = this.targetEmailAddress;
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data;
    }
}

export interface ISendTestEmailInput {
    senderEmailAddress: string;
    targetEmailAddress: string;
    subject: string;
    body?: string | undefined;
}

export class UpdateEmailSettingsDto implements IUpdateEmailSettingsDto {
    smtpHost?: string | undefined;
    smtpPort?: number;
    smtpUserName?: string | undefined;
    smtpPassword?: string | undefined;
    smtpDomain?: string | undefined;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress!: string;
    defaultFromDisplayName!: string;

    constructor(data?: IUpdateEmailSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
        }
    }

    static fromJS(data: any): UpdateEmailSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        return data;
    }
}

export interface IUpdateEmailSettingsDto {
    smtpHost?: string | undefined;
    smtpPort?: number;
    smtpUserName?: string | undefined;
    smtpPassword?: string | undefined;
    smtpDomain?: string | undefined;
    smtpEnableSsl?: boolean;
    smtpUseDefaultCredentials?: boolean;
    defaultFromAddress: string;
    defaultFromDisplayName: string;
}

export class RestoreTemplateContentInput implements IRestoreTemplateContentInput {
    templateName!: string;
    cultureName?: string | undefined;

    constructor(data?: IRestoreTemplateContentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            this.cultureName = _data["cultureName"];
        }
    }

    static fromJS(data: any): RestoreTemplateContentInput {
        data = typeof data === 'object' ? data : {};
        let result = new RestoreTemplateContentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["cultureName"] = this.cultureName;
        return data;
    }
}

export interface IRestoreTemplateContentInput {
    templateName: string;
    cultureName?: string | undefined;
}

export class TemplateDefinitionDto implements ITemplateDefinitionDto {
    name?: string | undefined;
    displayName?: string | undefined;
    isLayout?: boolean;
    layout?: string | undefined;
    isInlineLocalized?: boolean;
    defaultCultureName?: string | undefined;

    constructor(data?: ITemplateDefinitionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isLayout = _data["isLayout"];
            this.layout = _data["layout"];
            this.isInlineLocalized = _data["isInlineLocalized"];
            this.defaultCultureName = _data["defaultCultureName"];
        }
    }

    static fromJS(data: any): TemplateDefinitionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDefinitionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isLayout"] = this.isLayout;
        data["layout"] = this.layout;
        data["isInlineLocalized"] = this.isInlineLocalized;
        data["defaultCultureName"] = this.defaultCultureName;
        return data;
    }
}

export interface ITemplateDefinitionDto {
    name?: string | undefined;
    displayName?: string | undefined;
    isLayout?: boolean;
    layout?: string | undefined;
    isInlineLocalized?: boolean;
    defaultCultureName?: string | undefined;
}

export class TextTemplateContentDto implements ITextTemplateContentDto {
    name?: string | undefined;
    cultureName?: string | undefined;
    content?: string | undefined;

    constructor(data?: ITextTemplateContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.cultureName = _data["cultureName"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): TextTemplateContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TextTemplateContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["cultureName"] = this.cultureName;
        data["content"] = this.content;
        return data;
    }
}

export interface ITextTemplateContentDto {
    name?: string | undefined;
    cultureName?: string | undefined;
    content?: string | undefined;
}

export class UpdateTemplateContentInput implements IUpdateTemplateContentInput {
    templateName!: string;
    cultureName?: string | undefined;
    content?: string | undefined;

    constructor(data?: IUpdateTemplateContentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            this.cultureName = _data["cultureName"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): UpdateTemplateContentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTemplateContentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["cultureName"] = this.cultureName;
        data["content"] = this.content;
        return data;
    }
}

export interface IUpdateTemplateContentInput {
    templateName: string;
    cultureName?: string | undefined;
    content?: string | undefined;
}

export class UserData implements IUserData {
    id?: string;
    tenantId?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    isActive?: boolean;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;

    constructor(data?: IUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.isActive = _data["isActive"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
        }
    }

    static fromJS(data: any): UserData {
        data = typeof data === 'object' ? data : {};
        let result = new UserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["isActive"] = this.isActive;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        return data;
    }
}

export interface IUserData {
    id?: string;
    tenantId?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    isActive?: boolean;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
}

export class IStringValueType implements IIStringValueType {
    readonly name?: string | undefined;
    readonly properties?: { [key: string]: any; } | undefined;
    validator?: IValueValidator;

    constructor(data?: IIStringValueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IStringValueType {
        data = typeof data === 'object' ? data : {};
        let result = new IStringValueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIStringValueType {
    name?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
    validator?: IValueValidator;
}

export class IValueValidator implements IIValueValidator {
    readonly name?: string | undefined;
    readonly properties?: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
}

export class PlanDto implements IPlanDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): PlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IPlanDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class PaymentRequestProductDto implements IPaymentRequestProductDto {
    paymentRequestId?: string;
    code?: string | undefined;
    name?: string | undefined;
    unitPrice?: number;
    count?: number;
    totalPrice?: number;
    paymentType?: PaymentType;
    readonly planId?: string;
    extraProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IPaymentRequestProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentRequestId = _data["paymentRequestId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.unitPrice = _data["unitPrice"];
            this.count = _data["count"];
            this.totalPrice = _data["totalPrice"];
            this.paymentType = _data["paymentType"];
            (<any>this).planId = _data["planId"];
            if (_data["extraProperties"]) {
                this.extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>this.extraProperties)![key] = _data["extraProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PaymentRequestProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentRequestId"] = this.paymentRequestId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["unitPrice"] = this.unitPrice;
        data["count"] = this.count;
        data["totalPrice"] = this.totalPrice;
        data["paymentType"] = this.paymentType;
        data["planId"] = this.planId;
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        return data;
    }
}

export interface IPaymentRequestProductDto {
    paymentRequestId?: string;
    code?: string | undefined;
    name?: string | undefined;
    unitPrice?: number;
    count?: number;
    totalPrice?: number;
    paymentType?: PaymentType;
    planId?: string;
    extraProperties?: { [key: string]: any; } | undefined;
}

export enum PaymentRequestState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class PaymentRequestWithDetailsDto implements IPaymentRequestWithDetailsDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    products?: PaymentRequestProductDto[] | undefined;
    currency?: string | undefined;
    state?: PaymentRequestState;
    failReason?: string | undefined;
    emailSendDate?: Date | undefined;
    gateway?: string | undefined;
    externalSubscriptionId?: string | undefined;
    totalPrice?: number;
    creationTime?: Date;

    constructor(data?: IPaymentRequestWithDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(PaymentRequestProductDto.fromJS(item));
            }
            this.currency = _data["currency"];
            this.state = _data["state"];
            this.failReason = _data["failReason"];
            this.emailSendDate = _data["emailSendDate"] ? new Date(_data["emailSendDate"].toString()) : <any>undefined;
            this.gateway = _data["gateway"];
            this.externalSubscriptionId = _data["externalSubscriptionId"];
            this.totalPrice = _data["totalPrice"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentRequestWithDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRequestWithDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["currency"] = this.currency;
        data["state"] = this.state;
        data["failReason"] = this.failReason;
        data["emailSendDate"] = this.emailSendDate ? this.emailSendDate.toISOString() : <any>undefined;
        data["gateway"] = this.gateway;
        data["externalSubscriptionId"] = this.externalSubscriptionId;
        data["totalPrice"] = this.totalPrice;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPaymentRequestWithDetailsDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    products?: PaymentRequestProductDto[] | undefined;
    currency?: string | undefined;
    state?: PaymentRequestState;
    failReason?: string | undefined;
    emailSendDate?: Date | undefined;
    gateway?: string | undefined;
    externalSubscriptionId?: string | undefined;
    totalPrice?: number;
    creationTime?: Date;
}

export enum PaymentType {
    _0 = 0,
    _1 = 1,
}

export class EditionCreateDto implements IEditionCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName!: string;
    planId?: string | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.planId = _data["planId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["planId"] = this.planId;
        return data;
    }
}

export interface IEditionCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName: string;
    planId?: string | undefined;
}

export class EditionDto implements IEditionDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    displayName?: string | undefined;
    planId?: string | undefined;
    planName?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.planId = _data["planId"];
            this.planName = _data["planName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): EditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["planId"] = this.planId;
        data["planName"] = this.planName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IEditionDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    displayName?: string | undefined;
    planId?: string | undefined;
    planName?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class EditionLookupDto implements IEditionLookupDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    displayName?: string | undefined;

    constructor(data?: IEditionLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EditionLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEditionLookupDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    displayName?: string | undefined;
}

export class EditionUpdateDto implements IEditionUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    displayName!: string;
    planId?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IEditionUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.planId = _data["planId"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): EditionUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["planId"] = this.planId;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IEditionUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    displayName: string;
    planId?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class SaasTenantConnectionStringsDto implements ISaasTenantConnectionStringsDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    default?: string | undefined;
    databases?: SaasTenantDatabaseConnectionStringsDto[] | undefined;

    constructor(data?: ISaasTenantConnectionStringsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.default = _data["default"];
            if (Array.isArray(_data["databases"])) {
                this.databases = [] as any;
                for (let item of _data["databases"])
                    this.databases!.push(SaasTenantDatabaseConnectionStringsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaasTenantConnectionStringsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantConnectionStringsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["default"] = this.default;
        if (Array.isArray(this.databases)) {
            data["databases"] = [];
            for (let item of this.databases)
                data["databases"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaasTenantConnectionStringsDto {
    extraProperties?: { [key: string]: any; } | undefined;
    default?: string | undefined;
    databases?: SaasTenantDatabaseConnectionStringsDto[] | undefined;
}

export class SaasTenantCreateDto implements ISaasTenantCreateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    editionId?: string | undefined;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    editionEndDateUtc?: Date | undefined;
    adminEmailAddress!: string;
    adminPassword!: string;
    connectionStrings?: SaasTenantConnectionStringsDto;

    constructor(data?: ISaasTenantCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.editionId = _data["editionId"];
            this.activationState = _data["activationState"];
            this.activationEndDate = _data["activationEndDate"] ? new Date(_data["activationEndDate"].toString()) : <any>undefined;
            this.editionEndDateUtc = _data["editionEndDateUtc"] ? new Date(_data["editionEndDateUtc"].toString()) : <any>undefined;
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.connectionStrings = _data["connectionStrings"] ? SaasTenantConnectionStringsDto.fromJS(_data["connectionStrings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaasTenantCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["editionId"] = this.editionId;
        data["activationState"] = this.activationState;
        data["activationEndDate"] = this.activationEndDate ? this.activationEndDate.toISOString() : <any>undefined;
        data["editionEndDateUtc"] = this.editionEndDateUtc ? this.editionEndDateUtc.toISOString() : <any>undefined;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionStrings"] = this.connectionStrings ? this.connectionStrings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISaasTenantCreateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    editionId?: string | undefined;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    editionEndDateUtc?: Date | undefined;
    adminEmailAddress: string;
    adminPassword: string;
    connectionStrings?: SaasTenantConnectionStringsDto;
}

export class SaasTenantDatabaseConnectionStringsDto implements ISaasTenantDatabaseConnectionStringsDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    databaseName?: string | undefined;
    connectionString?: string | undefined;

    constructor(data?: ISaasTenantDatabaseConnectionStringsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.databaseName = _data["databaseName"];
            this.connectionString = _data["connectionString"];
        }
    }

    static fromJS(data: any): SaasTenantDatabaseConnectionStringsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantDatabaseConnectionStringsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["databaseName"] = this.databaseName;
        data["connectionString"] = this.connectionString;
        return data;
    }
}

export interface ISaasTenantDatabaseConnectionStringsDto {
    extraProperties?: { [key: string]: any; } | undefined;
    databaseName?: string | undefined;
    connectionString?: string | undefined;
}

export class SaasTenantDatabasesDto implements ISaasTenantDatabasesDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    databases?: string[] | undefined;

    constructor(data?: ISaasTenantDatabasesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            if (Array.isArray(_data["databases"])) {
                this.databases = [] as any;
                for (let item of _data["databases"])
                    this.databases!.push(item);
            }
        }
    }

    static fromJS(data: any): SaasTenantDatabasesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantDatabasesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        if (Array.isArray(this.databases)) {
            data["databases"] = [];
            for (let item of this.databases)
                data["databases"].push(item);
        }
        return data;
    }
}

export interface ISaasTenantDatabasesDto {
    extraProperties?: { [key: string]: any; } | undefined;
    databases?: string[] | undefined;
}

export class SaasTenantDto implements ISaasTenantDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    editionId?: string | undefined;
    editionEndDateUtc?: Date | undefined;
    editionName?: string | undefined;
    hasDefaultConnectionString?: boolean;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: ISaasTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.editionId = _data["editionId"];
            this.editionEndDateUtc = _data["editionEndDateUtc"] ? new Date(_data["editionEndDateUtc"].toString()) : <any>undefined;
            this.editionName = _data["editionName"];
            this.hasDefaultConnectionString = _data["hasDefaultConnectionString"];
            this.activationState = _data["activationState"];
            this.activationEndDate = _data["activationEndDate"] ? new Date(_data["activationEndDate"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): SaasTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["editionId"] = this.editionId;
        data["editionEndDateUtc"] = this.editionEndDateUtc ? this.editionEndDateUtc.toISOString() : <any>undefined;
        data["editionName"] = this.editionName;
        data["hasDefaultConnectionString"] = this.hasDefaultConnectionString;
        data["activationState"] = this.activationState;
        data["activationEndDate"] = this.activationEndDate ? this.activationEndDate.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ISaasTenantDto {
    extraProperties?: { [key: string]: any; } | undefined;
    id?: string;
    name?: string | undefined;
    editionId?: string | undefined;
    editionEndDateUtc?: Date | undefined;
    editionName?: string | undefined;
    hasDefaultConnectionString?: boolean;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    concurrencyStamp?: string | undefined;
}

export class SaasTenantSetPasswordDto implements ISaasTenantSetPasswordDto {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: ISaasTenantSetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SaasTenantSetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantSetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ISaasTenantSetPasswordDto {
    username?: string | undefined;
    password?: string | undefined;
}

export class SaasTenantUpdateDto implements ISaasTenantUpdateDto {
    readonly extraProperties?: { [key: string]: any; } | undefined;
    name!: string;
    editionId?: string | undefined;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    editionEndDateUtc?: Date | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: ISaasTenantUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["extraProperties"]) {
                (<any>this).extraProperties = {} as any;
                for (let key in _data["extraProperties"]) {
                    if (_data["extraProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extraProperties)![key] = _data["extraProperties"][key];
                }
            }
            this.name = _data["name"];
            this.editionId = _data["editionId"];
            this.activationState = _data["activationState"];
            this.activationEndDate = _data["activationEndDate"] ? new Date(_data["activationEndDate"].toString()) : <any>undefined;
            this.editionEndDateUtc = _data["editionEndDateUtc"] ? new Date(_data["editionEndDateUtc"].toString()) : <any>undefined;
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): SaasTenantUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new SaasTenantUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.extraProperties) {
            data["extraProperties"] = {};
            for (let key in this.extraProperties) {
                if (this.extraProperties.hasOwnProperty(key))
                    (<any>data["extraProperties"])[key] = (<any>this.extraProperties)[key];
            }
        }
        data["name"] = this.name;
        data["editionId"] = this.editionId;
        data["activationState"] = this.activationState;
        data["activationEndDate"] = this.activationEndDate ? this.activationEndDate.toISOString() : <any>undefined;
        data["editionEndDateUtc"] = this.editionEndDateUtc ? this.editionEndDateUtc.toISOString() : <any>undefined;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface ISaasTenantUpdateDto {
    extraProperties?: { [key: string]: any; } | undefined;
    name: string;
    editionId?: string | undefined;
    activationState?: TenantActivationState;
    activationEndDate?: Date | undefined;
    editionEndDateUtc?: Date | undefined;
    concurrencyStamp?: string | undefined;
}

export class GetEditionUsageStatisticsResultDto implements IGetEditionUsageStatisticsResultDto {
    data?: { [key: string]: number; } | undefined;

    constructor(data?: IGetEditionUsageStatisticsResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetEditionUsageStatisticsResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionUsageStatisticsResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface IGetEditionUsageStatisticsResultDto {
    data?: { [key: string]: number; } | undefined;
}

export enum TenantActivationState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}